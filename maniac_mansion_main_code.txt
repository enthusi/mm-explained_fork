;Video-related addresses
; C800 C828	CBF8
; CC00 CC28 CFF8
; CAD0-CB90
; 6D89-7030
; D800			character base/color?
; D828-DACF 	color
; F800-FC00

; Row #00 - Message bar
; CC00-CC27		Message bar video matrix
; D800-D827		Message bar color
; F800-FC00		Dot-data for text characters

; Rows #01-#11 - Room scene
; 6D89-6AE0		Room scene color RAM buffer (copied to color RAM at D828-DACF)
; 6AE1
; C800-CACF		Room scene video matrix frame buffer #1
; CC28-CECF		Room scene video matrix frame buffer #2
; D828-DACF		Room scene color (multicolor text mode)
; D000-D800?	Dot-data
;
; Row #12 - Sentence bar
; CED0-CEF7		Sentence bar video matrix
; DAD0-DAF7		Sentence bar color
; F800-FC00		Dot-data for text characters

; Rows #13-15 - Verbs
; CEF8-CF6F		Verbs video matrix
; DAF8-DB6F		Verbs color
; F800-FC00		Dot-data for text characters
; 
; E200/E300/E400/E500	Actor buffer for sprites set #1
; EA00/EB00/EC00/ED00	Actor buffer for sprites set #2
; F040			Cursor crosshair sprite dot-data
; F080			Cursor snail sprite dot-data

;
; Multicolor text mode
; The mode is enabled by setting bit 4 of the D016 register
; irq_handler3, init_memory_sound_and_video set multicolor on (when drawing the room scene)
; irq_handler17 sets multicolor off (when rendering text outside the room scene) - using normal text mode

;
;
; 2 bits per dot - 4 colors possible (0 = bkg color, transparent) - 1-3 = character colors
; Background color is controlled by Background Color Register 0 (D021)
; Character colors are controlled by Background Color Registers 1-2 (D022-D023)
; D022 controls the color for the 01 bit-pair
; D023 controls the color for the 10 bit-pair
;
; Characters are 4 dots wide x 8 dots high (in multicolor text mode)
; A character row requires one nibble, and a total of 8 nibbles vertically
;
; Characters dot-data is stored in the "Text character dot-data" region
; The region's base address is controlled by bits 1-3 of the Memory Control Register (D018)
; Screen codes for characters are stored in the "Video matrix" region
; The region's base address is controlled by bits 4-7 of the Memory Control Register (D018)
;
; Sprite Data Pointers are determined by last 8 bytes of screen memory area (x7F8-x7FF)
; Number in pointer times 64 equals address of first byte in the VIC-II address range
; Sprites are 24 dots wide x 21 dots high
; This means 3 bytes of memory make up one row of a sprite
; In total, then, 3 * 21 = 63 bytes of memory make up one full sprite
; Each bit corresponds to a dot. 1 = use sprite color, 0 = use background color (transparent)
; The color of the sprite is controlled by the Sprite Color Register (D027-D02E)


;IRQ handlers
;
;	Handler				Raster line		Sprite Y coordinate		Screen area of invocation
;	------------		-----------		-------------------		-------------------------
;	irq_handler1		#FB	(251)								bottom of visible screen
;	irq_handler2		#29 (41)		#32 (50)				before top bar
;	irq_handler3		#3A (58)		#47 (71)				start of room scene
;	irq_handler4		#45 (69)				
;	irq_handler5		#4F	(79)		#5C (92)
;	irq_handler6		#59 (89)
;	irq_handler7		#63 (99)		#71 (113)
;	irq_handler8		#6D (109)
;	irq_handler9		#77	(119)		#86 (134)
;	irq_handler10		#81 (129)
;	irq_handler11		#8B	(139)		#9B (155)
;	irq_handler12		#95	(149)			
;	irq_handler13		#9F	(159)		#B0 (176)
;	irq_handler14		#A9 (169)
;	irq_handler15		#B1	(177)		#C5 (197)
;	irq_handler16		#BD (189)
;	irq_handler17		#C3	(195)		#FD (253)				start of interaction area
;	
; Only scan lines 50-249 are visible on the screen
; The top 8 visible lines (50-57) cover the "top bar" area
; The middle 135 visible lines (58-193) cover the "room scene" area
; The bottom 48 visible lines (rows 194-249) cover the "interaction" area (sentence bar, verbs and inventory)
;
;
; Sprite's Y coordinates are separated 21 rows apart (the height of a sprite)
;
; irq_handler2
;		-set sprites horizontal positions
;		-set sprites shapes
;		-color all sprites gray if lights are off
;		-set cursor sprite color
;		-set sprites vertical positions to #32


; Character set for text
; ----------------------
; #01	left-half of up arrow (for inventory)
; #02	right-half of up arrow (for inventory)
; #03	left-half of down arrow (for inventory)
; #04	right-half of down arrow (for inventory)
; #05-1C	Assorted block graphics (straight lines, tees, curves, etc.)
; #1D	Empty diamond
; #1E	Full diamond
; #22	Exclamation sign
; #23	Double quotes
; #24	Hash
; #26	Ellipsis
; #27	Ampersand
; #28	Apostrophe
; #29	Open round bracket
; #2A 	Close round bracket
; #2B	Asterisk
; #2C	Plus
; #2D	Comma
; #2E	Hyphen
; #2F	Dot
; #30	Forward slash
; #31-9	Digits (0-9)
; #3A	Colon
; #3B	Semicolon
; #3C	Open angle bracket
; #3D	Copyright
; #3E	Close angle bracket
; #3F	Question mark
; #40	Dash
; #41-5B	Uppercase letters
; #5C	Open square bracket
; #5D	Pound
; #5E	Close square bracket
; #5F	small up arrow
; #60	small left arrow
; #61	double quotes
; #62-7A	Lowercase letters
; #7B	check sign
; #7C	big up arrow
; #7D	big down arrow
; #7E	big left arrow
; #7F	big right arrow


BLACK_COLOR = #$00

;=========================
;Verbs
;=========================
OPEN_VERB = #$01
CLOSE_VERB = #$02
GIVE_VERB = #$03
TURN_ON_VERB = #$04
TURN_OFF_VERB = #$05
FIX_VERB = #$06
NEW_KID_VERB = #$07
UNLOCK_VERB = #$08
PUSH_VERB = #$09
PULL_VERB = #$0A
USE_VERB = #$0B
READ_VERB = #$0C
WALK_TO_VERB = #$0D
PICK_UP_VERB = #$0E
WHAT_IS_VERB = #$0F

;=========================
;Prepositions
;=========================
PREPOSITION_NONE_NEEDED = #$00
PREPOSITION_WITH = #$02
PREPOSITION_TO = #$04

MAX_INVENTORY_INDEX = #$2C

;=========================
;Control modes
;=========================
CUTSCENE_CONTROL_MODE = #$00
KEYPAD_CONTROL_MODE = #$01
NO_KID_CHANGE_CONTROL_MODE = #$02
NORMAL_CONTROL_MODE = #$03

;=========================
; Actor vars bitmasks
;=========================
ACTOR_IS_INVISIBLE = #$80
ACTOR_IS_FROZEN = #$40

;Actors
;01 - Syd
;02 - Razor
;03 - Dave
;04 - Michael
;05 - Bernard
;06 - Wendy
;07 - Jeff
;08 - Radiation Suit
;09 - Dr. Fred
;10 - Nurse Edna
;11 - Weird Ed
;12 - Dead Cousin Ted
;13 - Purple Tentacle
;14 - Green Tentacle
;15 - Meteor Police
;16 - Meteor
;17 - Mark Eteer
;18 - Talkshow host
;19 - Chuck the Plant
;20 - Meteor radiation
;21 - Edsel car
;22 - Meteor
;23 - Sandy
;24 - Sandy


;========================================================
; Object resource data layout
;========================================================
;#00-01	Resource size
;#02	Resource type (always #01 for an object)
;#03	Inventory index (if in inventory)
;#04	Object index lo
;#05	Object index hi
;		#00 = a "mutable" object (it might be removed from a room or mutated into a different object or state)
;		#01 = an "immutable" object (it can't be removed or mutated into a different object)
;		Mutable objects have an associated graphic.
;			For instance, doors have an associated "opened" graphic that replaces the default "closed" one.
;			Objects that can be picked up have the associated "removed" graphic that replaces their "in-place" one.
;		Immovable objects don't have an associated graphic, as they can't change, so they are already represented 
;		in the room scene graphics.
;		
;#06	X start
;#07	Bit 7 - if set, parent object exists
;		Bit 6-0 - Y start
;#08	Width
;#09	Parent object index
;#0A	X destination
;#0B	Bits 7-5 - Preposition index for the verb "Use"
;		Bits 4-0 - Y destination / 4
;#0C	Bits 7-3 - Height 
;		Bits 2-0 - Nonzero = X destination and Y destination active
;#0D	Offset to name
;#0E	Start of verb handler offsets

;========================================================
; Room resource data layout (not including the 4-byte header)
;========================================================
;#00		Room width
;#01		Room height	(it's always #11)
;#02		Unknown video flag (it's always #00)
;#03-05		Background colors
;#06-07	 	room_tile_definitions_offset - offset to room scene tile definitions (compressed)
;				decompressed into D800-E000 (total decompressed data size: #0800 bytes)
;#08-09		tile_matrix_offset - offset to tile matrix layer (compressed) - decompressed size: room_width * room_height
;#0A-0B		color_layer_offset - offset to color layer (compressed) - decompressed size: room_width * room_height
;#0C-0D		mask_layer_offset - offset to mask layer (compressed) - decompressed size: room_width * room_height
;#0E-0F		mask_indexes_offset - offset to global mask indexes (compressed)
;				First 2 bytes: data size
;				Followed by compressed data
;			Each bit pattern (decompressed) occupies 8 bytes
;
;#10		total number of objects
;#11		offset to boundary boxes start
;#12		total number of sounds
;#13		total number of scripts
;#14-15		Exit script offset
;#16-17		Entry script offset
;#18-19		Offsets for objects compressed graphic layers
;#1A-1B		Offsets for objects data (each data follows the object layout described earlier)
;#1C		Start of objects section
;			Start of sounds section
;			Start of scripts section
;
;			At the beginning of each compressed data section,
;			the first 4 bytes (#00-#03) contain the symbol dictionary needed for decompression
;========================================================
; Room graphics
;========================================================
; The visible room (what I call the "room scene") is not stored as a full frame of individual pixels, as would usually happen on modern machines. 
; Due to technology limitations, "tiles" are used, which can be reused and repeated.
; This is very similar to the way the NES/Famicom handles graphics (with name tables, patterns, etc.).
;
; In this way, one can define the tiles first and then compose them as a "mosaic".
; A "tile layer" is used to represent the mosaic of tiles, by using 1 byte per tile.
; This allows a maximum of 256 different tiles.
; 
; A crude example of a 2x6 tile layer would be:
;
; 	0	1	1	0	2	54
;	32	32	30	49  42  99
;
; Each room scene has a tile layer, then, whose dimensions are exactly: room_width * room_height, as the dimensions are expressed in tile units.
;
; Tile definitions are stored in one section. There's actually always 128 tiles defined for each room (even if some are unused).
; Each tile represents a 4x8 group of pixels, where each pixel takes 2 bits (to specify multiple colors). 
; It thus occupies: 4x8x2 bits = 64 bits = 8 bytes.
;
; 2 bits per pixel would allow 4 different color values.
; To allow more colors, one of the 4 values is used to represent a "foreground" color, and the other 3 correspond to 3 different "background" palette colors.
; This can be summarized as:
;
;		Bit value		Color represented
;		=========		=================
;			00			Background color #0
;			01			Background color #1
;			10			Background color #2
;			11			Foreground color
;
;
; An example of a tile's pixels could be:
;
;		BG0	BG0	BG1 BG0
;		FG	FG	BG2 BG2
;		FG	FG	BG2 BG0
;		FG	FG	FG	FG
;		FG	FG	FG	FG
;		BG0	BG0	BG0	BG0
;		BG1	BG1	BG1	BG1
;		BG2	BG2	BG2	BG2
;
;	Where	FG = foreground color
;			BG0 = background color 0
;			BG1 = background color 1
;			BG2 = background color 2
;
; This would be represented in bits as:
;
;		00	00	01	00
;		11	11	10	10
;		11	11	10	00
;		11	11	11	11
;		11	11	11	11
;		00	00	00	00	
;		01	01	01	01
;		10	10	10	10
;
; The different foreground colors are taken from a subset of the C64's palette of 16 possible colors. 
; Specifically, 8 of those 16 can be used. This means the foreground color index requires 3 bits.
; As clearly 3 bits don't fit into 1, these other 3 bits have to be stored somewhere.
;
; The C64 uses a separate "color layer" (also referred to as Color RAM) to store the foreground colors.
; The color layer has exactly the same dimensions as the tile layer. 
; Each byte in the color layer defines the foreground color used for that particular tile position.
; Note that only 3 bits are used, instead of 8, for the foreground color, so bits 7-3 are ignored.
; 
; To continue with the previous example, these are an invented example of tile and color layers:
;
;	Tile layer positions			Tile layer values
;
; 	T00 T01 T02 T03 T04 T05			0	1	1	0   2   54
;	T10	T11 T12 T13 T14 T15			32	32	30	49  42  99
;
;	Color layer	positions			Color layer values
;
;	C00	C01	C02	C03	C04	C05			3	3	3	1	0	1
;	C10	C11	C12	C13	C14	C15			5	7	2	2	2	1
;
;	Note: Txy means Tile index at tile row x, tile column y. Same thing for Cxy.
;
; So at tile row 1, tile column 2, the value at position T12 will be used for the tile, and the value at position C12 will be used for the foreground color.
; This would be tile number 30 and foreground color 2.
;
; To tie everything up with actual colors, let's consider these background colors for our example:
;
;	BG color 0:		1 (white)
;	BG color 1:		6 (blue)
;	BG color 2:		0 (black)
;
; At tile position T12, C12 has value 2, which is the color red.
; Then the real colors used for the tile, when rendered at tile position row 1, column 2, would be: white, blue, black (for the BG colors) and red (for the FG color)
;
;		white	white	blue	white
;		red		red		black	black
;		red		red		black	white
;		red		red		red		red
;		red		red		red		red
;		white	white	white	white
;		blue	blue	blue	blue
;		black 	black 	black 	black
;
; To save storage space, these 2 layers (the tile and color layers), as well as the tile definitions, are stored compressed on disk.
; The 3 background colors are part of the room's data.


;========================================================
; Graphics masking
;========================================================
; To allow the depiction of depth, actors can move in front of or behind certain parts of the background, or certain objects.
; By default, the actors graphics are copied on top of whatever is in the background.
; But when the actor is behind a graphic layer, its graphics need to be obstructed by the foreground.
; This is achieved by storing information about the foreground in a separate layer.
; The foreground graphics need to "mask" the actor's graphics.
;
; It's not necessary to fully duplicate the background pixels into the foreground (that is, tiles, colors and tile patterns).
; The simple algorithm used is:
;
;	-draw the background fully
;	-get masking information for the actor's position
;	-mask out the actor's graphics as needed
;	-copy the masked actor's graphics to the room scene
;
; If an actor's pixel is masked, then it's not drawn to the scene, and the background pixel remains visible.
; Otherwise, the actor's pixel is drawn on the scene, obstructing the background pixel.
;
; For example, this is a hypothetical 8x8 mask pattern:
;
; 	11001100
;	00110011
;	11110000
;	11110000
;	00001111
;	00001111
;	00110011
;	00110011
;
; So we need 8 bytes to fully define a "tile mask pattern". 1 byte per row.
;
; In a similar manner to the background, mask tiles and mask tile patterns are used.
; A whole "mask tile layer" is defined, with dimensions = room_width * room height.
; One mask tile index is stored per byte.
; Each tile index defines the tile pattern to be used as mask.
;
; For example:
;
;	Mask layer positions			Mask layer values
;
; 	M00 M01 M02 M03 M04 M05			3	3	3	3   6   3
;	M10	M11 M12 M13 M14 M15			3	3	5	7   6   5
;
;
; Instead of a tile index referring directly to a pattern definition, there's one extra level of indirection.
; The game engine uses 256 hardcoded mask bit patterns (see the mask_bit_patterns comment for details).
; I call these "global mask bit patterns", as they are shared across all rooms.
;
; Each room will have its own set of "mask tile definitions". But instead of the definitions specifying patterns directly,
; each byte is an index into the global patterns table.
;
; So the example above will use the room's mask definition 3 for tiles at positions M00-M04, then the mask definition 6 for M04, etc.
;
; For example, a room's mask tile definitions looks like this:
;
; 00 00 00 00 00 00 00 00		Mask definition 0
; 55 55 55 55 55 55 55 55		Mask definition 1
; AA AA AA AA AA AA AA AA		Mask definition 2
; FF FF FF FF FF FF FF FF		Mask definition 3
; 01 02 03 AA 03 04 05 05		Mask definition 4
;
; The first mask definition takes up 8 bytes, which are all #00. #00 doesn't mean that the patterns have value 00000000.
; It means that the global pattern number #00 is to be used (which _coincidentally_ defines a bit pattern of #00).
; So all rows of mask definition 0 use global pattern #00.
; All rows of mask definition 1 use global pattern #55, and so on.
;
;


;0064-007B section - precomputed decompression values for each room's scene row
;	(Also referred as pointers to room resource type 4 A) 
;========================================================
;Offsets within memory block (type 4 A) - 2 bytes per offset
;Offsets are calculated by adding room_byte_0 to each previous offset
;
;#64-6B		4 offsets for compressed data at room_tile_matrix_offset
;#6C-73		4 offsets for compressed data at room_color_layer_offset
;#74-7B		4 offsets for compressed data at room_mask_layer_offset

;========================================================
;Resource type 4 A
;========================================================
;This resource contains precomputed values for decompression of each
;room scene's column.
;========================================================
;Boundary boxes list format
;========================================================
;#-2		Offset to box topology list
;#-1		???
;#00		left edge		
;#01		right edge
;#02		top edge
;#03		bottom edge
;#04		Attribute
;			Values observed: #00, #03, #04	- #03 (used in stairs)
;			with bit 7 set
;				#84		Bit 2 set
;				#88		Bit 3 set - upward diagonal slope (as in left edge of walled room)
;				#8B		Bits 3, 1, 0 set
;				#8C		Bits 2, 3 set - downward diagonal slope (as in right edge of walled room)
;				#8F		Bits 3, 2, 1, 0 set
;
;			Horizontal edges are contained within the room's width
;			Vertical edges are in the range #00-#45
;			A value of #FF for the left edge marks the end of the list

;Box topology
;Each item in the list corresponds to each walkbox
;Each item contains one or more connected box indexes
;For instance, this is the topology for room #02
;0: [1, 3]
;1: [2, 3, 0]
;2: [4, 1]
;3: [1, 4, 0]
;4: [3, 2, 7, 6, 5]
;5: [4]
;6: [4]
;7: [4]


;========================================================
;Processor port (wired to address $0001) bits meaning
;========================================================
; Bits 7-6 are not used
; Bits 5-3 are used for the cassette
; Bits 2-0 are used for memory mapping
;
; Bit 7		not connected
; Bit 6		not connected
; Bit 5		Cassette Motor Control (1 = turn motor on, 0 = off)
; Bit 4		Cassette Switch Sense (0 = button pressed, 1 = no buttons pressed)
; Bit 3		Cassette Data Output line
; Bit 2		CHAREN signal - Select what's mapped at D000-DFFF. 1 = I/O registers or RAM bank, 0 = Character ROM
;				Whether I/O registers or a RAM bank are mapped, depends on the LORAM signal apparently (1 = I/O registers, 0 = RAM)
; Bit 1		HIRAM signal - Select what's mapped at E000-FFFF. 1 = KERNAL ROM, 0 = RAM
; Bit 0 	LORAM signal - Select what's mapped at A000-BFFF. 1 = BASIC ROM, 0 = RAM. Also controls mapping of I/O registers as explained above.
;
; 
; During the main execution of the game engine, KERNAL and BASIC ROMs are mapped out of the memory space permanently,
; and RAM banks are mapped in, in their place. The only range that is alternately mapped in and out is the I/O registers range.
; The range is mapped in only when the I/O registers are needed. The rest of the time, I/O registers are mapped out,
; and a RAM bank is mapped in instead.
;
; To perform these two primitives ("map in I/O" or "map out I/O"), the corresponding value needs to be written to the processor port.
; Bits 2-0 must be set to 101 to map in the I/O registers, and to 100 to map in a RAM bank at D000-DFFF.
; In the code, we will see repeated storage of #24 and #25 values to the processor port.
; Ignoring the hi nibble, the low nibble contains bits 2-0 as "101" in the case of #25, and "100" in the case of #24.
; 
; So, to summarize, writing #24 maps in RAM instead of the I/O registers.
; Writing #25 maps in the I/O registers instead of RAM.
; We'll just mention this as "map_out_io" or "map_in_io" as a comment.
;
;====================================================
processor_data_direction_reg = $00
processor_port_register = $01
;Video memory mode values
;	#00		Do nothing
;	#01		Character base: D800	Video matrix: C800	Sprite shape: CBF8
;	#02		Character base: D800	Video matrix: CC00	Sprite shape: CFF8
;	#03		Copy color data only
video_memory_mode = $22
;This variable (frame_buffer) can only take values of #01 or #02, it's just the index
frame_buffer = $23
frame_buffer_base = $24		;Base address of frame buffer
processor_port_reg_copy = $26
kbd_keycode = $30
joy_state = $33

;Mask bit patterns (to be applied when masking an actor's sprites with foreground)
global_mask_index_ptr_1 = $43
global_mask_index_ptr_2 = $45
global_mask_index_ptr_3 = $47

;Values observed
;#00	Scroll right
;#FF	Scroll left
;#C8	No scroll
;#01	Room scene rendering starts (by opening the "lens" outwards)
screen_scroll_flag = $4e

tile_matrix_compressed_lo = $64
tile_matrix_compressed_hi = $66
tile_matrix_mode_counter = $68
tile_matrix_value_to_repeat = $6a
color_layer_compressed_lo = $6c
color_layer_compressed_hi = $6e
color_layer_mode_counter = $70
color_layer_value_to_repeat = $72
mask_layer_compressed_lo = $74
mask_layer_compressed_hi = $76
mask_layer_mode_counter = $78
mask_layer_value_to_repeat = $7a

sprite_shape_data_ptr = $8c
video_update_signal = $8e			;A synchronization flag - NOT to be confused with vsync
room_bkg_color_copy_0 = $8f
room_bkg_color_copy_1 = $90
rebuild_action_sentence = $95
raster_setup_needed = $96
voice_read_ptr = $ba
sound_read_ptr = $bc
vic_memory_layout = $be

;Possible values: 
;#00 (entering reset_talking)
;#01 (end of message reached)
;#FF (after copying a new message, after printing a line break, after filling the top msg bar)
top_bar_msg_mode = $c9		
source_msg_offset = $CA
current_message_delay = $CB
standard_message_delay = $CD
text_delay = $CF
actor = $d8
irq_handler1_section_entry_count = $d9
random_1 = $dd
random_2 = $de
random_3 = $df
irq_lock = $e3

decomp_dict4 = $0100
;Base address for message bar source buffers
source_msg_base = $0200

kernal_irq_vector = $0314
kernal_brk_vector = $0316
kernal_nmi_vector = $0318

;===========================================================
;Camera variables
;===========================================================
room_scene_left_edge = $0664	;Left column for the visible room scene
room_scene_right_edge = $0665	;Right column for the visible room scene
camera_desired_position = $0666
camera_current_position = $0667
camera_mode = $066a				;#02 = follow costume, #03 = pan to position
camera_costume_to_follow = $066b	;Index of costume to follow
pan_camera_to = $066c				;Position to pan camera to
actor_follow_needs_pan = $066d		

remove_obj_from_inv_flag = $0670
action_bar_current_text_length = $0e72

;===========================================================
; Sprite variables
;===========================================================
sprite_0_x_lo = $0fca
sprite_1_x_lo = $0fcb
sprite_2_x_lo = $0fcc
sprite_3_x_lo = $0fcd
sprite_4_x_lo = $0fce
sprite_5_x_lo = $0fcf
sprite_6_x_lo = $0fd0
cursor_sprite_x_lo = $0fd1
sprite_0_color = $0fd2
sprite_1_color = $0fd3
sprite_2_color = $0fd4
sprite_3_color = $0fd5
sprite_4_color = $0fd6
sprite_5_color = $0fd7
sprite_6_color = $0fd8
cursor_sprite_color = $0FD9
relative_sprite_0 = $0fda
relative_sprite_1 = $0fdb
relative_sprite_2 = $0fdc
relative_sprite_3 = $0fdd
relative_sprite_4 = $0fde
relative_sprite_5 = $0fdf
relative_sprite_6 = $0fe0
sprite_horizontal_expansion = $0fea
sprite_0_x_hi = $0fe1
sprite_1_x_hi = $0fe2
sprite_2_x_hi = $0fe3
sprite_3_x_hi = $0fe4
sprite_4_x_hi = $0fe5
sprite_5_x_hi = $0fe6
sprite_6_x_hi = $0fe7
cursor_sprite_x_hi = $0fe8
sprites_x_hi_combined = $0fe9
cursor_sprite_y = $0FEB

;These are the sprite shapes to be used by the successive raster IRQ handlers
sprite_shape_1 = $1661
sprite_shape_2 = $1662
sprite_shape_3 = $1663
sprite_shape_4 = $1664
sprite_shape_5 = $1665
sprite_shape_6 = $1666
sprite_shape_7 = $1667
sprite_shape_8 = $1668
;===========================================================
sprite_shape_cursor = $1669
sprite_shapes_set_to_use = $166a
irq_handler1_video_processed_signal = $166b

;===========================================================
;Cursor variables
hide_cursor = $166c	;#01 if cursor needs to be hidden, #00 otherwise

;Each time irq_handler1 is executed, the wait counter is decremented
;As the start value for the counter is #06, the cursor color will be updated 
;every 6 executions of irq_handler1
cursor_color_wait_counter = $166d
cursor_color_index = $166e
;The reset value for the wait counter (#06)
cursor_color_wait_start = $166f
first_cursor_color_index = $1670
;===========================================================
color_ram_data_copied = $1677
general_semaphore = $1678 ;Semaphore used to control access to a section in irq_handler1
game_paused = $1679	;#01 if game is paused, #00 otherwise

disk_error_msg = $3b81

decompression_region_mode = $41fd
sector_chain_index = $463B

;===========================================================
; Sound variables
;===========================================================
voice_freq_register_offsets = $4755
set_bitmasks = $475c
clear_bitmasks = $4763
voice_attack_delays = $476c
voice_sustain_releases = $476f
sound_id_to_start_on_voice = $4772
voice_data_base_lo = $4779
voice_data_base_hi = $4780
voice_data_offsets_lo = $4787
voice_data_offsets_hi = $478e
voice_priority_0 = $4795
voice_priority_1 = $4796
voice_priority_2 = $4797
voice_priority_3 = $4798
voice_priority_4 = $4799
voice_priority_5 = $479A
voice_priority_6 = $479B
rsrc_for_voice_0 = $479c
rsrc_for_voice_1 = $479d
rsrc_for_voice_2 = $479e
rsrc_for_voice_3 = $479f
rsrc_for_voice_4 = $47a0
rsrc_for_voice_5 = $47a1
rsrc_for_voice_6 = $47a2
instruction_for_voice = $47a3
instruction_repeat_counter = $47aa
voice_controls = $47b1
voice_instruction_ptr_lo = $47b8
voice_instruction_ptr_hi = $47bf
voice_frequencies_lo = $47c6
filter_cutoff_freq_lo = $47c9
voice_frequencies_hi = $47cd
filter_cutoff_freq_hi = $47d0
sound_duration_lo = $47d4
sound_duration_hi = $47db
glissando_lo = $47e2
glissando_hi = $47e9
voice_base_addr_lo = $47f0
voice_base_addr_hi = $47f7
voice_instruction_offset_lo = $47fe
voice_instruction_offset_hi = $4805
voices_executing_instruction = $480c	;Bitmask that holds which voices are currently executing sound instructions

x_lower_than_3 = $4811	;#00 if X < 3, #FF otherwise

music_playback_in_progress = $4816
music_voices_in_use = $4817
music_voices_in_use_2 = $4818		;A bitmask used to represent which voices are being used by music

sound_processing_disabled = $4819	;#00 = false, #FF = true
stop_sound_mode = $481A				;#01 = stop, dereference sound, stop arpeggio, #FF = just stop
sound_starting = $4cf1
starting_sound_with_priority_1 = $4cf2 ;#01 = True, #00 = false
voice3_in_use = $4CF5				;#00 = false, #FF = true
default_filter_control_value = $4cfa
total_real_voices_available = $4cff
;Values observed: #01, #02, #07, #0A, #64, #6E, #73, #78
; 00000001		#01		14 times	Sink water, Shower water, Radio untuned, Dial tone, tentacle noise, 
;									Reactor alarm 1, Scratched record (x2), Typewriter, Glass-breaking noise,
;									Zom-b-matic, Meteor angry, Meteor happy, Meteor panicked
; 00000010		#02		2 times		Hunk-o-matic up/down
; 00000111		#07		6 times		Piano music (x2), Main theme - short version (x2), Intro music (x2)
; 00001010		#0A		2 times		Crickets, Comet burn
; 01100100		#64		35 times - Door open, close, Piggy bank break, Coin inserted, Light switch, Lab door open
;								Microwave bell, Microwave rotation, Hamster explosion, Keypad beep, Busy tone, Edna phone ring, 
;								Library phone ring, Window glass crack, Alien, Pendulum clock, Radio being tuned, Reactor alarm 2,
;								Water flow, Water valve, Unused melody, Tape being stopped, Select kid, Comet crash, Meltdown countdown, Unknown, 
;								Shower curtain open, Videogame, Tentacle blocking, Meteor police, Door bell, Garage door open, 
;								Car rocket ignition, Car rocket liftoff, Reactor explosion

; 01101110		#6E		1 time		Radiation
; 01110011		#73		1 time		Close steel door
; 01111000		#78		1 time		Zom-b-matic shutdown

sound_priority = $4d01		
sound_to_start = $4d05
voices_allocated = $4d07	;Bitmask that holds which voices are currently allocated (not necessarily actively executing sound instructions)
sound_to_stop = $4d08

;Combine multiple notes in one voice by arpeggio
arpeggio_ongoing = $5160	; #00 = disabled, #FF = enabled
arpeggio_active_2 = $5161		; #00 = disabled, #FF = enabled
arpeggio_active_1 = $5162		; #00 = disabled, #FF = enabled
filter_enable_flag = $5164			; #00 = filter voice, #FF = stop filtering voice
filter_pass_select = $5166
all_alt_settings_cleared = $5167	; #00 = false, #FF = true

alt_voice_attack_delays = $5168
alt_voice_sustain_releases = $516a
alt_voice_data_ptrs_lo = $516c
alt_voice_data_ptrs_hi = $516f
alt_voice_controls = $517e
alt_voice_frequencies_lo = $5187
alt_voice_frequencies_hi = $518a
alt_sound_duration_lo = $518d
alt_sound_duration_hi = $5190
alt_glissando_lo = $5193
alt_glissando_hi = $5196

music_in_progress_ptr = $547c
;Relative offset constants lo/hi for each sound track
music_track_offsets_lo = $547e
music_track_offsets_hi = $5487
;Sound track pointers
music_track_ptrs_lo = $5490
music_track_ptrs_hi = $5499


;===========================================================
; Resource variables
;===========================================================
;Read pointer of the current script
script_read_pointer_lo = $5e15
script_read_pointer_hi = $5e16

;Resource types
; #01	object
; #02	costume
; #03	room
; #04	???
; #05	script
; #06	sound 
resource_type = $5677
resource_index = $5676

inventory_objects = $7031
object_rsrc_ptrs_lo = $705e
object_rsrc_ptrs_hi = $708b
;===================================================
; Concurrent script engine variables
;===================================================
current_script_slot = $70B8	;Script slot of script being executed
script_offsets_hi = $70B9
script_offsets_lo = $70C9
;Script states
;Bit 7 set = frozen for cutscene
;#00	Inactive (no script)
;#01	Paused
;#02	Running
script_state_for_script_slot = $70D9
script_pause_counter_1 = $70e9
script_pause_counter_2 = $70f9
script_pause_counter_3 = $7109
;Script types
;#00 = object script
;#01 = room script
;#02 = global script
script_type_for_script_slot = $7119
resource_index_for_script_slot = $7129
;===================================================

room_data = $7139
room_width = $7139
room_height = $713a
room_bkg_color_0 = $713b
room_bkg_colors = $713b
room_tile_definitions_offset = $713f
room_tile_matrix_offset = $7141
room_color_layer_offset = $7143
room_mask_layer_offset = $7145
room_mask_indexes_offset = $7147
current_room = $7149
symbol_dictionary_for_tile_matrix = $714a
symbol_dictionary_for_color_layer = $714e
symbol_dictionary_for_mask_layer = $7152
room_exit_script = $7156
room_entry_script = $7158
current_room_rsrc = $715A
total_objects_in_room = $715c

;===========================================================
;Room objects variables
;===========================================================
object_x_start = $715d
object_y_start = $7179
object_width = $7195
object_height = $71b1
object_x_destination = $71cd
object_y_destination = $71e9
object_destination_active = $7205
room_object_index_hi = $7221
room_object_index_lo = $723d
parent_object = $7259
parent_object_possible = $7275
compressed_object_data_offsets = $7291
room_object_offsets_lo = $72c9		;Offsets of objects in a room resource
room_object_offsets_hi = $72ca
object_attributes = $7301		
;-------------------------------------------------
; Object attributes
;-------------------------------------------------
;Bit 7 - object currently stored in a parent object
;Bit 6 - unused
;Bit 5 - object removed from room 
;			(if the cursor is clicked inside the object's original location in a room, the object's location is ignored)
;Bits 3-0 (low nibble) = object owner
;			Special values for owners
;				#0F - in a room (no owner, it's in a room)
;				#0D = limbo
;				#01-07	- index of kid owner
;
;The only ownership that's actually checked in the game scripts is kid's ownership.
;Objects given to other characters are not "owned" by them. 
;In those cases, the change is handled by changing states of game variables.
;
;Some objects are in a "limbo" location before being materialized into the world.
;For instance, the batteries inside the portable radio.
;When the radio is picked up, the batteries are put in the limbo.
;When the radio is opened, the batteries owner changes from limbo to the current kid.
;
;Limbo is modeled by setting the owner for the object to #0D.
;#0D would be the owner index for the Green Tentacle, but in reality, it's limbo.
;In some cases, scripts set the owner of an object to #00 instead of #0D. It has the same effect.

;===========================================================
; Resource disk storage data
;===========================================================
;This includes all of the disk side, track and sector information for all resources.
;
;Let's call "disk location" as a specific disk side, track and sector combination.
;Room resources always start at the beginning of a sector.
;To read a room resource, a disk location then perfectly defines the exact place to start reading from.
;
;To avoid storing disk locations for every other resource (of which we have hundreds),
;a design decision was made to save some space: all non-room resources are "child" resources of a room.
;
;So, for example, to read sound X, the parent room needs to be looked up first.
;Then the location of the parent room is fetched.
;A room's data will normally occupy multiple sectors. Immediately after it, the child resources data will start.
;And that will very likely happen right in the middle of a sector.
;
;So to start reading a child resource directly, it's necessary to know:
;	-the parent room's disk location
;	-how many sectors from the room's data start to skip
;	-how many bytes in the resource's sector to skip
;
; I call the sectors skip "sector_index", and the bytes to skip "offset_in_sector".
;-----------------------------------------------------------
disk_side_for_room = $7401
disk_track_sector_for_room = $7438
room_for_costume = $74a6
costume_offset_in_sector = $74bf
costume_sector_index = $74c0
room_for_script = $74f1
global_script_read_offsets = $7591
global_script_sector_index = $7592
room_script_offset_in_sector = $7691
room_script_sector_index = $7692
room_for_sound = $76d1
sound_offset_in_sector = $7717
sound_sector_index = $7718

;===========================================================
; Resource pointers and memory attributes
;===========================================================
;Memory attributes consist of a single byte.
;Bit 7 represents the locked state (set = locked, clear = unlocked).
;Locked resources cannot be released.
;Unlocked ones can be, if nedeed.
;For rooms, LRU (Least Recently Used) is used as the algorithm for eviction.
;The low nibble of the attribute represents an age for the resource.
;
;Resources other than rooms do not use LRU for eviction.
;
;When sound eviction is activated, all evictable sounds are released.
;The same thing applies to scripts.
;
;For costumes, only the first evictable costume is released, 
; counting downwards from the maximum costume index.
;
;Rooms memory age work as follows:
;
;	-When a room is loaded
;		-If the loaded room is the "current room" (the one where the player is present), its age is set to 0
;		-If the loaded room is not the current room, its age is set to 1.
;		This can happen if only a room's subresource (script, sound, etc.) was needed.
;		But subresources require loading a whole room.
;	-After a room is loaded, all loaded rooms with nonzero age have their age incremented by 1
;	-When a room is released, its age is set to 0
;
costume_memory_attrs = $77a3
room_memory_attrs = $77bc
room_rsrc_ptrs_hi = $77f3		;Total rooms: 55
room_rsrc_ptrs_lo = $782a
costume_rsrc_ptrs_hi = $7861	;Total costumes: 25
costume_rsrc_ptrs_lo = $787A
sound_rsrc_ptrs_hi = $78C5		;Total sounds: 70
sound_rsrc_ptrs_lo = $790B
sound_memory_attrs = $7951
sound_1_memory_attr = $7952
sound_2_memory_attr = $7953
script_rsrc_ptrs_hi = $7997		;Total scripts: 160
script_rsrc_ptrs_lo = $7a37
script_memory_attrs = $7ad7
script_2_mem_attr = $7ad9
room_layers_rsrc_hi = $7b77		;Total type 4 resources: 2	- room scene graphic layers
room_layers_rsrc_lo = $7b79
mask_bit_patterns_rsrc_hi = $7b78		
mask_bit_patterns_rsrc_lo = $7b7a
;The room layers and the mask bit patterns resources don't have memory attributes - they are tied to the current room's lifetime


;===========================================================
vic_bank_base = $c000
text_bar_length = #$27


;===========================================================
; Actor path variables
;===========================================================
path_delta_x_direction = $cb58	;#00 = left, #01 = right
path_delta_y_direction = $cb59	;#00 = up, #01 = down	
path_dominant_axis = $cb66	;Which axis of movement is dominant, #00 = horizontal, #01 = vertical

saved_position_x_for_actor = $cb5a
saved_position_y_for_actor = $cb5b
saved_layer_depth_for_actor = $cb5d
saved_current_box_for_actor = $cb5e
saved_path_update_needed_for_actor = $cb5f
								
;===========================================================
; Cursor variables
;===========================================================
;Multicolor bitmap mode has a resolution of 160x200
cursor_h_xor_mask = $cb7b
cursor_v_xor_mask = $cb7c
cursor_drag_power = $cb7d
cursor_x_pixel = $cb7f		;Range: 00-9F (00-159 dec)
cursor_y_pixel = $cb81		;Range: 08-BF (08-191 dec)
cursor_x_speed_lo = $cb82
cursor_x_speed_hi = $cb83
cursor_y_speed_lo = $cb84
cursor_y_speed_hi = $cb85
cursor_x_grid = $cb86		
cursor_y_grid = $cb87		;Range: 01-17 (01-23 decimal)

;===========================================================
; Interaction region variables
;===========================================================
interaction_region = $cb88
joystick_button_pressed = $cb89
button_presses = $cb8a
inv_display_item_offset = $cb8b
region_text_color = $cb8f

;CBF8 - sprite shape area
msg_bar_text_base = $cc00
;CC00-CECF - graphics area (including parts not visible)
SENTENCE_BAR_BASE = $ced0
sentence_bar_2nd_kid_name_offset = $CEDD
sentence_bar_3rd_kid_name_offset = $CEEA

opcode_handlers_lo = $d000
opcode_handlers_hi = $d100

;===========================================================
; I/O Video registers
;===========================================================
;Sprite 7 is always the cursor
sprite0_x_lo_register = $d000
sprite0_y_register = $d001
sprite1_y_register = $d003
sprite2_y_register = $d005
sprite3_y_register = $d007
sprite4_y_register = $d009
sprite5_y_register = $d00b
sprite6_y_register = $d00d
sprite7_y_register = $d00f
sprite7_x_lo_register = $d00e
;This register controls bit 8 of ALL 8 sprites
;Each bit corresponds to each of the 8 sprites
;Bit 4 set means that sprite 4 has the bit 8 of its X coordinate set to 1
sprites_x_hi_combined_reg = $d010

;======================================
;Screen control register 1 bits meaning
;======================================
;	Bit 7	High bit of raster compare register (D012)
;	Bit 6	Enable extended color mode
;	Bit 5 	Enable bitmap graphics mode
;	Bit 4	Blank entire screen to same color as border (0 = blank)
;	Bit 3	1 = 25 row display, 0 = 24 rows
;	Bits 0-2	Fine scroll display vertically by X scan lines (0-7)
;--------------------------------------
;Values used throughout the game for this register
;--------------------------------------
;
; #00	0000 0000	Blank screen, 24 rows, vertical scroll 0
; #0B	0000 1011	Blank screen, 25 rows, vertical scroll 3
; #1B	0001 1011	25 rows, vertical scroll 3
; #1C	0001 1100	25 rows, vertical scroll 4
; #1D	0001 1101	25 rows, vertical scroll 5
vic_screen_control_register_1 = $d011
vic_sprite_enable_register = $d015

;======================================
;Screen control register 2 bits meaning
;======================================
; Bits 7-6	Unused
; Bit 5		Video chip reset (0 = normal operation)
; Bit 4		1 = multicolor on, 0 = multicolor off
; Bit 3		1 = 40 columns text display, 0 = 38 columns
; Bits 0-2	Fine scroll display horizontally by X dot positions (0-7)
;--------------------------------------
;Values used throughout the game for this register
;--------------------------------------
;irq_handler3, init_memory_sound_and_video set #18
;irq_handler17 sets #09
;
;#18	0001 1000		Multicolor on, 40 columns, fine scroll 0
;#09	0000 1001		Multicolor off, 40 columns, fine scroll 1
vic_screen_control2_reg = $d016


;============================================
;Screen memory control register bits meaning
;============================================
; Bit 0 	always 0 (ignored)
;
; Bits 1-3	Text character dot-data	address within VIC-II address space
;			Bits value * 2K = base address
;			Bits	Value	Base address
;			----	-----	------------
;			000		0		0
;			001		1		2K
;			010		2		4K
;			011		3		6K
;			100		4		8K
;			101		5		10K
;			110		6		12K
;			111		7		14K
;
; Bits 4-7	Video matrix base address within VIC-II address space
;			Bits value * 1K = base address
;--------------------------------------
;Values used throughout the game for this register
;--------------------------------------
;
; vic_memory_layout ($BE) 
;	Possible values: #18, #1C, #26, #36
;(irq_handler3 & init_memory_sound_and_video) - can take values of #26 or #36
; #3E (irq_handler17 & print_message_wait_for_button)
;
;	#18		0001 100 0	->	Text character dot-data base address: 8K	($C000 + $2000 = E000)
;							Video matrix base address: 1K				($C000 + $0400 = C400)
;
;	#1C		0001 110 0	->	Text character dot-data base address: 6K	($C000 + $1800 = D800)
;							Video matrix base address: 1K				($C000 + $0400 = C400)
;
;	#26		0010 011 0	->	Text character dot-data base address: 6K	($C000 + $1800 = D800)
;							Video matrix base address: 2K				($C000 + $0800 = C800)
;
;	#36		0011 011 0	-> 	Text character dot-data base address: 6K	($C000 + $1800 = D800)
;							Video matrix base address: 3K				($C000 + $0C00 = CC00)
;
;	#3E		0011 111 0	->	Text character dot-data base address: 14K	($C000 + $3800 = F800)
;							Video matrix base address: 3K				($C000 + $0C00 = CC00)
;
; To summarize:
;	Value		Dot-data base		Video matrix base
;	-----		-------------		-----------------
;	#18			E000				C400
;	#1C			D800				C400
;	#26			D800				C800
;	#36			D800				CC00
;	#3E			F800				CC00
;
; For video matrix:
; 	First 1024 bytes are screen codes for characters
;	Last 8 bytes are pointers to 64-byte blocks for sprites shape data
vic_memory_control_register = $d018
vic_irq_flag_register = $d019
vic_irq_mask_register = $d01a
vic_sprite_hor_expansion_reg = $d01d
vic_border_color_register = $d020
vic_bkg_color0_register = $d021
vic_sprite_mcolor0_reg = $d025
vic_sprite_mcolor1_reg = $d026
vic_sprite0_color_reg = $d027
vic_sprite7_color_reg = $d02e
;===========================================================
; Graphics constants and variables (living in RAM)
;===========================================================
sprite_row_offsets_hi = $d508
sprite_row_offsets_lo = $d5a8
room_scene_row_offsets_lo = $d640
room_scene_row_offsets_hi = $d659
actor_text_color = $d672

;D800 = Color RAM in _normal_ text mode
;Each byte controls foreground color of character
;16 colors are available, which means only 4 bits are needed to represent a color index
;Only the low nibble of each byte will be used
;
;In multicolor text mode, only 8 colors are available, so only the bits 2-0 are used
color_ram = $d800

;===========================================================
; I/O CIA registers
;===========================================================
cia1_port_a_data_register = $dc00
cia1_port_b_data_register = $dc01
cia1_port_a_data_direction_reg = $dc02
cia1_port_b_data_direction_reg = $dc03
cia1_timer_b_hi_register = $dc07
cia1_irq_status_register = $dc0d
cia1_control_timer_a_reg = $dc0e
cia1_control_timer_b_reg = $dc0f

;CIA #2 Port A bits 0-1 control the base VIC-II address space (which is 16K long)
; Bits		Address space
;	00		C000-FFFF
;	01		8000-BFFF
;	10		4000-7FFF
;	11		0000-3FFF
; The game engine sets these bits to #00 (at Program Counter 836B)
; which means the range C000-FFFF
cia2_port_a_data_register = $dd00
cia2_port_b_data_register = $dd01
cia2_port_a_data_direction_reg = $dd02
cia2_port_b_data_direction_reg = $dd03
cia2_irq_status_register = $dd0d

;===========================================================
; Game engine constants
;===========================================================
character_sprite_bkg_colors = $f0c0	  ;Background colors for each character
character_animation_settings = $f0d9 ; Check detailed description at the f0d9 address in this listing
verb_pointers_hi = $f20b
verb_pointers_lo = $f21b
preposition_pointers_hi = $f22a
preposition_pointers_lo = $f22e
click_handlers = $f2f2
region_dehighlight_handlers = $f2fc
joy_direction_indexes = $f694
joy_direction_hdeltas = $f6a4
joy_direction_vdeltas = $f6ad

;===========================================================
; Actor limb variables
;===========================================================
;There are 4 possible actors and 8 limbs per actor, for a total of 32 actor_limbs
;Multiple arrays store metadata about actor limbs. I've named them with the "actor_limb" prefix.
;The index for each element is computed as: actor * 8 + limb_index

;Animation set values
;0: Walking right/east
;1: Walking left/west
;2: Walking down/south
;3: Walking up/north
;4: Standing right/east
;5: Standing left/west
;6: Standing down/south
;7: Standing up/north

rsrc_ptr_for_active_costume_hi = $7893
rsrc_ptr_for_active_costume_lo = $78ac
limb_cell_list_for_actor_lo = $cb3a					;Address of limb cell list, for each actor, low byte
limb_cell_list_for_actor_hi = $cb3e					;Address of limb cell list, for each actor, hi byte
graphic_data_ptr_for_actor_lo = $cb42				;Address of the graphic section start, for each actor, low byte
graphic_data_ptr_for_actor_hi = $cb46				;Address of the graphic section start, for each actor, hi byte
cell_addresses_hi_offset_for_actor = $cb4a			;Offset of the list of hi bytes of cell addresses, for each actor
cell_addresses_hi_offset = $cb53					;Offset of the list of hi bytes of cell addresses of the current actor
animation_sets_for_actor_lo = $fe90					;Address of the animation sets, for each actor (lo word)
animation_sets_for_actor_hi = $fe94					;Address of the animation sets, for each actor (hi word)

actor_limb_flip = $fc05		;#00 = no horizontal flip for the limb, #80 = horizontal flip for the limb
actor_sprite_base = $fc2e						;Base address of the current sprite being drawn in memory
active_costume = $fc30
actor_sprite_index = $fc32
actor_index_8th_multiple = $fc36
character_sprite_y = $fc37
current_actor_limb = $fc41
actor_limb_animation_frame = $fc42	;Which animation cell to use as _current_ for the actor limb
actor_limb_current_base_cell = $fc82
actor_limb_desired_base_cell = $fca2	;Which animation cell to use as _base_ for the actor limb
;#00 = stop animation when frames are exhausted
;#FF = loop animation from the first frame when frames are exhausted
;any other value - counter until stop
actor_limb_current_argument = $fcc2		
actor_limb_desired_argument = $fce2
current_animation_set_for_actor = $fd02		;The current animation set for the actor
desired_animation_set_for_actor = $fd06		;The desired animation set for the actor
animation_argument_for_actor = $fd0a		;Values: #00, #01, #FF

;===========================================================
; Actor sprites, waypoint and position variables
;===========================================================
sprite_buffer = $fd14		;Sprite buffer index (#00 or #01)
;#03 = actor might be obscured by a foreground object
layer_depth_for_actor = $fd18
character_sprite_x_lo = $fd1c
character_sprite_x_hi = $fd39
active_waypoint_x_for_actor = $fd25
active_waypoint_y_for_actor = $fd2d
desired_waypoint_x_for_actor = $fd29
desired_waypoint_y_for_actor = $fd31
position_y_for_actor = $fd3d
position_x_for_actor = $fd41
position_to_waypoint_x_for_actor = $fd45
position_to_waypoint_y_for_actor = $fd49
actor_sprite_x_hi = $fd58
actor_sprite_x_lo = $fd60
;===========================================================
; Motion state for actor
;===========================================================
;	Values
;
;	Bit 7 set = when standing and turning, clear = when not turning
;	#04 = traversing intermediate box horizontally
;	#03 = traversing intermediate box vertically
;	#02 = stopped
;	#01 = about to stop
;	#00 = moving
;
;When current and destination boxes overlap, value is set to #01
;When about to move actor on path, if bits 6-0 are equal to #01, animate actor
;
;If a new waypoint is made active, motion state low nibble is set to 0
;
;After checking for path deltas (result is #00 or #01), the result is set as the low nibble
;
;When doing the walking animation, if low nibble is #01, resets animation state
;If low nibble is #03, move on the Y axis
;If low nibble is #04, move on the X axis
;If low nibble is #00, update one or both axes
;
;When updating motion state:
;	If bit 7 is set, will copy path_delta_directions_for_actor as path_direction_for_actor
;When resetting animation state, the full value will be set to #02
;When advancing the characters animations, if motion state bits 6-0 are not equal to #02, 
;	it will skip updating the actor's sprites and positions
;When updating all actors after scroll, if the low nibble is not #02, it will skip it
;		If it's #02, it will set bit 5 of the animation state
;When initializing an actor for a costume, the initial value will be set to #02
;Opcodes 56 and D6, copy the value to a destination variable
;Scripts will wait for value #02 to wait until an actor stops moving
;
motion_state_for_actor = $fd68
room_scene_mask_layer_ptr = $fd6d
visibility_in_scene_for_actor = $fd6f
room_scene_clicked = $fd77
relative_sprite_for_actor = $fd7c

;===========================================================
;Animation state for actor
;===========================================================
;Only 2 bits are used, bit 5 (#20) and bit 0 (#01)
;Bit 5 set - draw the actor in the main loop - clear, ignore it in main loop
;Bit 0 set - refresh actor's visibility and graphics
;
; A refresh is triggered when:
;	-the actor gets behind a foreground layer
;	-an animation frame of a limb has changed
;	-a limb base cell has changed
;	-the animation is reset
;	-a camera is fixed on a new actor
;	-the animation counter has not expired
;
; An actor being updated in the main loop is triggered when:
;	-the animation is reset
;	-the actor is stopped
;	-the animation counter has not expired
;
animation_state_for_actor = $FD97

;===========================================================
; Actor walkbox and pathing variables
;===========================================================
layer_1_for_actor = $fda0
layer_2_for_actor = $fda4
layer_3_for_actor = $fda8
closest_box_index = $fdac
destination_box_for_actor = $fdd5
current_box_for_actor = $fdcd
last_box_for_actor = $fdd1
destination_x_for_actor = $fdd9
destination_y_for_actor = $fddd
path_update_needed_for_actor = $fde1
x_destination = $fde6
y_destination = $fde7
animation_argument = $fde8 
desired_animation_set = $fde9
room_destination = $fdea
path_direction_for_actor = $fdeb		;#00 = right, #01 = left, #80 = down, #81 = up
path_delta_directions_for_actor = $fdef	;#00 = right, #01 = left, #80 = down, #81 = up
path_delta_dominant_for_actor = $fdf3	;The dominant delta value (the largest between the deltas for the 2 axis)
path_delta_x_step_for_actor = $fdf7		;Value of delta x step (how much to move along this axis on each step to match the rate of motion on the other axis)
path_delta_y_step_for_actor = $fdfb		;Value of delta y step
path_delta_y_for_actor = $fdff			;Absolute value of delta between current position and path destination (Y axis)
path_delta_x_for_actor = $fe03			;Absolute value of delta between current position and path destination (X axis)
path_delta_x_direction_for_actor = $fe07 ;#00 = left, #01 = right
path_delta_y_direction_for_actor = $fe0b ;#00 = up, #01 = down	

;===========================================================
;Index in the sentence queue
sentence_queue_index = $fe17
sentence_queue_free_capacity = $fe18	
active_verb = $fe19
active_object_lo = $fe1a
active_object_hi = $fe1b
active_preposition = $fe1c
active_indirect_object = $fe1d
active_indirect_object_hi = $fe1e
sentence_parts = $fe1f
current_verb = $fe1f

direct_object_idx_lo = $fe20
direct_object_idx_hi = $fe21
preposition = $fe22
;Indirect object idx hi has the following meaning:
;#02 - Can be a recipient with a "Give" instruction
indirect_object_idx_lo = $fe23
indirect_object_idx_hi = $fe24

;Queued sentence parts (verbs, direct objects, indirect objects, prepositions)
;Each queue has a maximum size of 6 elements
queued_sentence_verbs = $fe25
queued_sentence_direct_objects_lo = $fe2b
queued_sentence_direct_objects_hi = $fe31
queued_sentence_prepositions = $fe37
queued_sentence_indirect_objects_lo = $fe3d
queued_sentence_indirect_objects_hi = $fe43

refresh_sentence_bar_flag = $fe49	;#00 = don't refresh the sentence bar, #01 = refresh it
									;By "refresh", we mean to update its contents
rsrc_has_been_released = $fe4a

item_index_saved = $fe52
costume_for_actor = $fe53			;#FF = actor not in use
actor_for_costume = $fe57		;Bit 7 set - actor moving, clear - not moving

reload_snd_rsrc_ptrs = $FE70	;#01 if the sound resource needs to be reloaded, #00 otherwise
new_sound_instructions_allowed = $fe71	;#00 = not allowed, nonzero = allowed
walkbox_room = $FE74
box_search_depth_for_actor = $fe75	

;Flashlight beam coordinates (used for checking if the beam of light moved when in flashlight mode)
flashlight_beam_x = $fe79
flashlight_beam_y = $fe7a
cursor_y_pixel_half = $fe7d				;Vertical range #08-63 (08-99)
cursor_x_pixel_quarter_relative = $fe7e			;Horizontal range #00-27 (00-39)			
cursor_y_pixel_half_off_by_8 = $fe7f	;Vertical range #00-5B (00-91)
cursor_x_pixel_quarter_absolute = $fe80	;Horizontal range #07-2E (07-46)
current_script_slot = $fe89			;Script engine's slot index for script being executed
current_script_rsrc_base_lo = $fe8a			;Resource base address of script being executed
current_script_rsrc_base_hi = $fe8b
opcode = $fe8c
reset_sentence_queue_system_flag = $fe8f

current_room_layers_rsrc = $fe98

character_talking = $fe9a
message_owner = $fe9b	;#FF means nobody's talking (and thus the msg bar must be cleared)
						;Otherwise, it has the same value as character_talking
desired_disk_id = $fe9c ;This represents the desired Disk ID (the ID that identifies each of the game's disk sides)
						;Once check_disk_id is called, this parameter is set and execution will not resume until the proper disk side is inserted
;Possible mouth state values
;---------------------------
;When an actor is speaking, the main_loop will automatically switch between
; the speaking states (01 and FF), thus opening and closing the mouth.
;
;#00	closed	(default)
;#01	speaking and closed	
;#FF	speaking and open
;#80	permanently open	(will stay open until explicitly closed)
mouth_state_for_actor = $fe9d	

music_to_start_ptr = $fea1
music_index = $fea3
interrupted_script_offset_lo = $fea4
interrupted_script_offset_hi = $fea5
saved_script_index = $fea6
interrupted_script_index = $fea7
;Control mode values
;#00 - cutscene
;#01 - push only, verb forcefully set to "push" (no walking possible) - used for keypad interaction and start screen
;#02 - normal play, disable kid change via Function keys
;#03 - normal play, enable kid change via Function keys
control_mode = $fea8
saved_control_mode = $fea9
saved_room = $feaa
;Lights_status values
;#00	environment lights off, flashlights off
;#01	environment lights off, flashlight on
;#02	environment lights on
lights_status = $feab
engine_vars = $feac

;Actor_vars bit meanings when bit is set
;Bit 7 - actor invisible (dead, game won or in the radiation suit)
;Bit 6 - actor frozen (for instance, when it's captured by Edna, Ed or the tentacle)
;Bit 3 - is Weird Ed's enemy 
;Bit 2 - has watched the TV commercial (and thus knows where to send the envelope)
;Bit 1 - is Green Tentacle's friend (after giving him a recording contract)
;Bit 0 - is strong (after doing exercise with the Hunk-o-matic)
actor_vars = $fee3
;The current room for each costume
room_for_character = $fefc
costume_y_destination = $ff15
costume_x_destination = $ff2e
animation_set_for_costume = $ff47		;The animation set for a costume, limited to the standing range of sets (#04-#07)
										;This is used by scripts to determine the direction a costume is facing 
										;See the details for "animation sets"

;===========================================================
;Memory management - free blocks
;===========================================================
first_free_block = $ff63
last_free_block = $ff65

;===========================================================
; Game script variables
;===========================================================
current_kid = $ff67
game_vars = $ff67
;These vars are copies of some game engine variables.
;I did not find any usage of them in the final scripts.
;They were definitely intended as debugging aids.
var_camera_position = $ff69			;This would be var[2]
var_msg_flag = $ff6a				;This would be var[3]
var_current_room = $ff6b			;This would be var[4]
var_active_indirect_object = $ff6c	;This would be var[5]
var_destination_x = $ff6d			;This would be var[6]
var_destination_y = $ff6e			;This would be var[7]
var_music_playback_in_progress = $ff6f	;This would be var[8]
var_active_verb = $ff70				;This would be var[9]
var_message_length = $ff71			;This would be var[10]
;FF72 and onwards are no longer used as debugging variables
kid_ids = $ffc8
first_kid_id = $FFC8
second_kid_id = $FFC9
third_kid_id = $FFCA
;===========================================================
; Interrupt handlers
;===========================================================
nmi_handler_lo = $fffa
nmi_handler_hi = $fffb
irq_handler = $fffe

;===========================================
; Initializes the compression dictionary with 4 symbols.
;
; Arguments:	decomp_src_ptr		pointer to compressed data
;
; This routine will also reset the repeat counter and value to #00.
; After reading the dictionary, the decomp_src_ptr will be advanced by 4.
;===========================================
decomp_emit_mode = $29
decomp_src_ptr = $27
decomp_emit_rem = $2a
decomp_run_symbol = $2b

decomp_dict4_init:
;Use .Y as offset, start at #03, go downwards
.C:0104  A0 03       LDY #$03
;------------------------------------------------
copy_loop:
.C:0106  B1 27       LDA (decomp_src_ptr),Y
.C:0108  99 00 01    STA decomp_dict4,Y
.C:010b  88          DEY
.C:010c  10 F8       BPL copy_loop
;------------------------------------------------
;Add 4 to read pointer
.C:010e  18          CLC
.C:010f  A5 27       LDA <decomp_src_ptr
.C:0111  69 04       ADC #$04
.C:0113  85 27       STA <decomp_src_ptr
.C:0115  A5 28       LDA >decomp_src_ptr
.C:0117  69 00       ADC #$00
.C:0119  85 28       STA >decomp_src_ptr
;------------------------------------------------
;Reset mode counter and mode
.C:011b  A9 00       LDA #$00
.C:011d  85 2A       STA decomp_emit_rem
.C:011f  85 29       STA decomp_emit_mode
.C:0121  60          RTS
;===========================================
; Get the next decompressed byte
;
; Arguments:	decomp_dict4		dictionary of symbols
;				decomp_src_ptr		pointer to compressed data
;
; Returns:		.A					decompressed symbol
;
; This is the main generic decompression logic routine.
;
; Run length encoding allows compressing repetitions of a value.
; It's expressed as a run-length and a symbol to be repeated.
;
; The decompression algorithm combines run-length encoding (RLE)
; with a symbol dictionary of 4 elements.
;
; The dictionary's purpose is to hold the symbols having the highest frequencies.
; This allows using just 2 bits (for the 4 elements) to reference each symbol,
; while leaving the remaining bits of the byte to express a run length.
; This obviously saves space.
;
; We can partition the set of symbols into two groups:
;	-symbols in the dictionary
;	-symbols not in the dictionary
;
; Thus, runs can reference a dictionary symbol or an ad-hoc (non-dictionary) symbol.
;
; When using RLE doesn't make sense (because symbols are not being repeated), we need to
; store the symbols directly as in their original form. Otherwise, we would be 
; actually increasing the space needed.
;
; "Direct" mode is thus also needed to properly handle these cases.
 
; There are then 3 main operations defined:
;
;	-repeat an ad-hoc value				expressed as a run-length and the ad-hoc repeated symbol
;	-repeat a dictionary value			expressed as a run-length and the dictionary symbol index
;	-direct mode						expressed as a counter, followed by one or more symbols
;
; Bits 7 and 6 are used to differentiate between these three operations.
;
;	Bit 7 set				dictionary run
;								bits 6-5 represent the symbol index
;								bits 4-0 represent the run length
;	Bit 7 clear, 6 set		ad-hoc run
;								bits 5-0 represent the run length
;								The following byte represents the symbol
;	Bits 7 and 6 clear		direct mode
;								byte represents the direct "run" length (how many direct bytes follow)
;								Following bytes represent symbols
;
; Note that the symbol dictionary has to be set up first, before calling this routine.
; This is done via decomp_dict4_init.
;===========================================
decomp_emit_mode = $29
decomp_emit_rem = $2a
decomp_run_symbol = $2b
y_temp = $2d
DIRECT_MODE = #$00
RUN_MODE = #$FF

decomp_stream_next:
;Save .Y as we'll overwrite it
.C:0122  84 2D       STY y_temp
;Is there an ongoing repetition? (decomp_emit_rem != 0)
;If so, handle the repetition
.C:0124  A5 2A       LDA decomp_emit_rem
.C:0126  D0 36       BNE repeat_operation
;--------------------------------------------------
;No counter ongoing
;Read a new byte
.C:0128  20 6F 01    JSR read_next_compressed_data
;Switch operation based on byte value
.C:012b  C9 40       CMP #$40
.C:012d  B0 07       BCS byte_ge_40
;--------------------------------------------------
;Byte < #40 - direct mode
;--------------------------------------------------
;Set the byte read as the repetition counter
;As this is necessarily < #40, this limits long runs expressed in this manner to 64 repetitions
.C:012f  85 2A       STA decomp_emit_rem
;Set the mode, as we'll need to read another byte later to get the value to be repeated
.C:0131  A9 00       LDA DIRECT_MODE
.C:0133  4C 59 01    JMP set_mode
;--------------------------------------------------
byte_ge_40:
.C:0136  C9 80       CMP #$80
.C:0138  B0 0A       BCS byte_ge_80
;--------------------------------------------------
; 40 <= Byte < 80 - ad-hoc run
;--------------------------------------------------
;Bits 5-0 are the run-length
.C:013a  29 3F       AND #$3F
.C:013c  85 2A       STA decomp_emit_rem
;The symbol to repeat is the next byte in the input data
.C:013e  20 6F 01    JSR read_next_compressed_data
.C:0141  4C 55 01    JMP set_symbol_to_repeat
;--------------------------------------------------
;Byte >= 80 - dictionary run
;--------------------------------------------------
byte_ge_80:
;Use bits 4-0 as the run-length
.C:0144  AA          TAX
.C:0145  29 1F       AND #$1F		
.C:0147  85 2A       STA decomp_emit_rem
.C:0149  8A          TXA
;Use bits 5 and 6 as the index to dictionary
.C:014a  4A          LSR A
.C:014b  4A          LSR A
.C:014c  4A          LSR A
.C:014d  4A          LSR A
.C:014e  4A          LSR A
.C:014f  29 03       AND #$03	
.C:0151  AA          TAX
;Load the symbol from the dictionary 
.C:0152  BD 00 01    LDA decomp_dict4,X
;--------------------------------------------------
;Set the new symbol to be repeated
set_symbol_to_repeat:
.C:0155  85 2B       STA decomp_run_symbol
;Set mode to "run"
.C:0157  A9 FF       LDA RUN_MODE
set_mode:
.C:0159  85 29       STA decomp_emit_mode
;We have just set a new mode, so skip the operation counter decrement
.C:015b  4C 60 01    JMP check_mode
;--------------------------------------------------
repeat_operation:
; Decrement the counter
.C:015e  C6 2A       DEC decomp_emit_rem
;--------------------------------------------------
check_mode:
;Which mode are we running on? Run (#FF) or direct (#00)? 
;Bit 7 is enough to differentiate them
.C:0160  24 29       BIT decomp_emit_mode
.C:0162  30 06       BMI run_mode
;--------------------------------------------------
; Direct mode
;--------------------------------------------------
;The symbol to return comes next in the input data
;Read it and return it in .A
.C:0164  20 6F 01    JSR read_next_compressed_data
.C:0167  4C 6C 01    JMP exit
;--------------------------------------------------
; Run mode
;--------------------------------------------------
run_mode:
;The symbol to return is already set
;Read it and return it in .A
.C:016a  A5 2B       LDA decomp_run_symbol
exit:
;Restore .Y from stack
.C:016c  A4 2D       LDY y_temp
.C:016e  60          RTS
;===========================================
; Reads one byte from the pointer to compressed data
;
; Arguments:	decomp_src_ptr		pointer to compressed data
; Returns:		.A						byte read
;
; Advances decomp_src_ptr by 1 after reading
;===========================================
decomp_src_ptr = $27

read_next_compressed_data:
.C:016f  A0 00       LDY #$00
.C:0171  B1 27       LDA (decomp_src_ptr),Y
.C:0173  E6 27       INC <decomp_src_ptr
.C:0175  D0 02       BNE exit
.C:0177  E6 28       INC >decomp_src_ptr
exit:
.C:0179  60          RTS
;===========================================
; Skips over a specific amount of compressed data (16-bit counter version)
;
; Arguments:	decomp_skip_rem		size of decompressed data to skip over
;
; Note that this routine runs the decompression but doesn't write any
; decompressed data anywhere. It's only useful for skipping over specific
; portions of compressed information.
;===========================================
decomp_skip_rem = $2e

decomp_skip_16:
;Is there a count pending? If not, exit now
.C:017a  A5 2E       LDA <decomp_skip_rem
.C:017c  05 2F       ORA >decomp_skip_rem
.C:017e  D0 01       BNE next_byte
.C:0180  60          RTS
;---------------------------------
next_byte:
.C:0181  20 22 01    JSR decomp_stream_next
.C:0184  A5 2E       LDA <decomp_skip_rem
.C:0186  D0 02       BNE dec_lo_counter
;---------------------------------
;decomp_skip_rem lo is zero, decrement decomp_skip_rem hi as well
.C:0188  C6 2F       DEC >decomp_skip_rem
dec_lo_counter:
.C:018a  C6 2E       DEC <decomp_skip_rem
.C:018c  4C 7A 01    JMP decomp_skip_16
;===========================================
; Skips over a specific amount of compressed data (8-bit counter version)
;
; Arguments:	decomp_skip_rem		size of decompressed data to skip over
;
; Note that this routine runs the decompression but doesn't write any
; decompressed data anywhere. It's only useful for skipping over specific
; portions of compressed information.
;===========================================
decomp_skip_rem = $2e

decomp_skip_8:
;Is there a count pending? If not, exit now
.C:018f  A4 2E       LDY decomp_skip_rem
.C:0191  D0 01       BNE next_byte
.C:0193  60          RTS
next_byte:
.C:0194  20 22 01    JSR decomp_stream_next
.C:0197  88          DEY
.C:0198  D0 FA       BNE next_byte
.C:019a  60          RTS
;===========================================
; Main game code entry
;
; After the multiple loaders have finished their work,
; execution starts right here.
;===========================================
game_code_entry:
;Init stack pointer
.C:0400  A2 FF       LDX #$FF
.C:0402  9A          TXS
;Set Blank screen, 24 rows, vertical scroll 0
.C:0403  A9 00       LDA #$00
.C:0405  8D 11 D0    STA vic_screen_control_register_1
.C:0408  78          SEI
;map_out_io
.C:0409  A0 24       LDY #$24		
.C:040b  84 01       STY processor_port_register
.C:040d  20 F1 82    JSR init_memory_sound_and_video
.C:0410  20 86 85    JSR init_game_engine
reset_game_engine:
;Set raster setup as needed
.C:0413  A9 01       LDA #$01
.C:0415  85 96       STA raster_setup_needed
.C:0417  20 E0 33    JSR init_sprites_sound
.C:041a  20 F7 48    JSR init_more_sound
;Fill "heap" ($7B7B-C800) with #00
;Note: this overwrites the setup code in the range 7FFF-85E3
.C:041d  A9 7B       LDA #$7B
.C:041f  85 19       STA $19
.C:0421  A9 7B       LDA #$7B
.C:0423  85 1A       STA $1A
.C:0425  A9 85       LDA #$85
.C:0427  85 1B       STA $1B
.C:0429  A9 4C       LDA #$4C
.C:042b  85 1C       STA $1C
.C:042d  A2 00       LDX #$00
.C:042f  20 35 04    JSR fill_memory_with_value
.C:0432  4C 4F 04    JMP start_game
;===========================================
; Fills memory with a specific value
;
; Arguments: 	.X 				value to write
;				dest_pointer	pointer to destination
;				byte_counter	total number of bytes to write
;===========================================
dest_pointer = $19
byte_counter = $1B

fill_memory_with_value:
;We'll move the base pointer instead of Y, which will stay set at #00
.C:0435  A0 00       LDY #$00
.C:0437  8A          TXA
;Store fill value in memory
.C:0438  91 19       STA (dest_pointer),Y
;Move pointer
.C:043a  E6 19       INC <dest_pointer
.C:043c  D0 02       BNE counter_decrement
.C:043e  E6 1A       INC >dest_pointer
counter_decrement:
.C:0440  A5 1B       LDA <byte_counter
.C:0442  D0 02       BNE counter_lo_decrement
.C:0444  C6 1C       DEC >byte_counter
counter_lo_decrement:
.C:0446  C6 1B       DEC <byte_counter
;OR'ing both counter bytes will yield zero if both are zero
.C:0448  A5 1B       LDA <byte_counter
.C:044a  05 1C       ORA >byte_counter
.C:044c  D0 E7       BNE fill_memory_with_value
.C:044e  60          RTS
;===========================================
; Starts a game
;
; This will:
; 	-read all object's intial attribute values
;	-read the disk storage information for all resources
;	-init the frame buffer
;	-init the current kid, camera mode and actor to follow
;	-init the script engine
;	-clear all engine and game variables
;	-lock music tracks and the most used sounds
;	-setup raster interrupts
;	-start global script #01 (kid selection screen)
;
; After this, execution will fall through to the main loop
;===========================================
start_game:
.C:044f  20 1A 5D    JSR clear_engine_state
;Ensure disk side 1 is in the drive
.C:0452  A9 31       LDA #$31		
.C:0454  20 EB 3A    JSR check_disk_side
;Setup disk read from track 1 sector 0, starting from byte offset #02
.C:0457  A2 00       LDX #$00
.C:0459  A0 01       LDY #$01
.C:045b  20 D3 44    JSR disk_init_chain
.C:045e  A2 02       LDX #$02
.C:0460  A0 00       LDY #$00
.C:0462  20 F7 44    JSR disk_seek_read
;Load all object's attributes
;The object attributes section starts at $7301
.C:0465  A2 01       LDX #$01
.C:0467  A0 73       LDY #$73
.C:0469  A9 00       LDA #$00
.C:046b  8D 3C 46    STA disk_copy_count_lo
.C:046e  A9 01       LDA #$01
.C:0470  8D 3D 46    STA disk_copy_count_hi
.C:0473  20 1F 45    JSR disk_stream_copy
;Setup disk read from track 1 sector 1, starting from byte offset #02
.C:0476  A2 02       LDX #$02
.C:0478  A0 01       LDY #$01
.C:047a  20 F7 44    JSR disk_seek_read
;Load game resources' disk storage data to memory
;The storage data section starts at $7401
.C:047d  A2 01       LDX #$01
.C:047f  A0 74       LDY #$74
.C:0481  A9 A2       LDA #$A2
.C:0483  8D 3C 46    STA disk_copy_count_lo
.C:0486  A9 03       LDA #$03
.C:0488  8D 3D 46    STA disk_copy_count_hi
.C:048b  20 1F 45    JSR disk_stream_copy
;Set frame_buffer to #01 ('lights on' memory layout)
.C:048e  A9 01       LDA #$01
.C:0490  85 23       STA frame_buffer
.C:0492  A9 28       LDA #$28
.C:0494  85 24       STA <frame_buffer_base
.C:0496  A9 CC       LDA #$CC
.C:0498  85 25       STA >frame_buffer_base
;Set current kid to #03 (Dave)
.C:049a  A9 03       LDA #$03
.C:049c  8D 67 FF    STA current_kid
;Set camera mode to #02 (follow costume)
.C:049f  A9 02       LDA #$02
.C:04a1  8D 6A 06    STA camera_mode
;Set costume to follow = current kid
.C:04a4  AD 67 FF    LDA current_kid
.C:04a7  8D 6B 06    STA camera_costume_to_follow
;Set current script slot to #FF (no script)
.C:04aa  A9 FF       LDA #$FF
.C:04ac  8D B8 70    STA current_script_slot
;Clear engine variables (FEAC-FF14)
.C:04af  A2 68       LDX #$68
clear_engine_vars:
.C:04b1  A9 00       LDA #$00
.C:04b3  9D AC FE    STA engine_vars,X
.C:04b6  CA          DEX
.C:04b7  D0 F8       BNE clear_engine_vars
;Clear game state variables (FF67-FFF2)
.C:04b9  A2 8B       LDX #$8B
clear_game_variables:
.C:04bb  A9 00       LDA #$00
.C:04bd  9D 67 FF    STA game_vars,X
.C:04c0  CA          DEX
.C:04c1  D0 F8       BNE clear_game_variables
;Lock sounds 3, 4, 5, 6, 8 and 9
; 3, 4 and 5 are special sound resources embedded in code, used as playback tracks for music
; 6 is the footstep sound
; 8 and 9 are the door open/close sounds
.C:04c3  A9 80       LDA #$80
.C:04c5  8D 54 79    STA sound_memory_attrs + 3 
.C:04c8  8D 55 79    STA sound_memory_attrs + 4
.C:04cb  8D 56 79    STA sound_memory_attrs + 5
.C:04ce  8D 57 79    STA sound_memory_attrs + 6
.C:04d1  8D 59 79    STA sound_memory_attrs + 8
.C:04d4  8D 5A 79    STA sound_memory_attrs + 9
;Set pointers to sounds 3, 4 and 5 (embedded in the middle of the code)
.C:04d7  A9 CD       LDA #$CD
.C:04d9  8D 0E 79    STA sound_rsrc_ptrs_lo + 3
.C:04dc  A9 53       LDA #$53
.C:04de  8D C8 78    STA sound_rsrc_ptrs_hi + 3
.C:04e1  A9 FA       LDA #$FA
.C:04e3  8D 0F 79    STA sound_rsrc_ptrs_lo + 4
.C:04e6  A9 53       LDA #$53
.C:04e8  8D C9 78    STA sound_rsrc_ptrs_hi + 4
.C:04eb  A9 27       LDA #$27
.C:04ed  8D 10 79    STA sound_rsrc_ptrs_lo + 5
.C:04f0  A9 54       LDA #$54
.C:04f2  8D CA 78    STA sound_rsrc_ptrs_hi + 5
;Setup raster interrupts
.C:04f5  20 1C 34    JSR raster_setup
;Start global script #01 (the kid selection screen)
.C:04f8  A9 01       LDA #$01
.C:04fa  20 8A 5E    JSR start_global_script
;Fall through to main loop
;===========================================
; The main loop of the game engine
;
; Execution happens either:
;	-inside this game loop, or
;	-inside one of the multiple IRQ handlers
; 
;
; The main loop will execute once every 4 iterations of the irq_handler1
;===========================================
main_loop:
;Do nothing - useful placeholder to invoke any debugging function we want
.C:04fd  20 7B 07    JSR do_nothing
;Reset the irq_handler1 entry count to #00
;We will execute the main loop once every 4 entries of the irq1_handler
.C:0500  A9 00       LDA #$00
.C:0502  85 D9       STA irq_handler1_section_entry_count
;--------------------------------------------------
; Key press handling
;--------------------------------------------------
;Check for keypresses and handle them
.C:0504  20 C2 28    JSR handle_keys
;--------------------------------------------------
; Debugging variables
;--------------------------------------------------
;Set debugging script variables
.C:0507  AD 67 FF    LDA current_kid
.C:050a  8D 67 FF    STA current_kid	;Redundant code
.C:050d  AD 66 06    LDA camera_desired_position
.C:0510  8D 69 FF    STA var_camera_position
.C:0513  A5 C9       LDA top_bar_msg_mode
.C:0515  8D 6A FF    STA var_msg_flag
.C:0518  AD 49 71    LDA current_room
.C:051b  8D 6B FF    STA var_current_room
.C:051e  AD 16 48    LDA music_playback_in_progress
.C:0521  8D 6F FF    STA var_music_playback_in_progress
;--------------------------------------------------
; Cursor coordinates conversion
;--------------------------------------------------
;Convert relative cursor coordinate (relative to the screen's left edge)
; to absolute cursor coordinates (relative to the room's left edge)
.C:0524  AD 7E FE    LDA cursor_x_pixel_quarter_relative
.C:0527  18          CLC
.C:0528  6D 64 06    ADC room_scene_left_edge
.C:052b  8D 80 FE    STA cursor_x_pixel_quarter_absolute
.C:052e  AD 7D FE    LDA cursor_y_pixel_half
.C:0531  38          SEC
.C:0532  E9 08       SBC #$08
.C:0534  8D 7F FE    STA cursor_y_pixel_half_off_by_8
;--------------------------------------------------
; Script execution
;--------------------------------------------------
;Execute scripts
.C:0537  20 71 5D    JSR execute_running_scripts
;--------------------------------------------------
; Inventory removal of objects
;--------------------------------------------------
;Do we need to remove objects from inventory?
.C:053a  AD 70 06    LDA remove_obj_from_inv_flag
;If not, skip this section
.C:053d  F0 1F       BEQ check_room
;We do, so clear the flag first
.C:053f  A9 00       LDA #$00
.C:0541  8D 70 06    STA remove_obj_from_inv_flag
;Remove objects from inventory as needed
;Use .Y as inventory index, start at #2D, count downwards
.C:0544  A0 2D       LDY #$2D
check_if_object_is_in_inventory:
;Fetch object index
.C:0546  BE 31 70    LDX inventory_objects,Y
;Fetch object attributes
.C:0549  BD 01 73    LDA object_attributes,X
;Is the object in limbo? (Used to signal removal from inventory)
.C:054c  29 0F       AND #$0F
.C:054e  C9 0D       CMP #$0D
;If not, proceed with next inventory object
.C:0550  D0 09       BNE next_inventory_object
;It is, save inventory index in stack
.C:0552  98          TYA
.C:0553  48          PHA
;Remove object from inventory
.C:0554  A9 00       LDA #$00
.C:0556  20 53 64    JSR remove_from_inventory
;Restore inventory index from stack
.C:0559  68          PLA
.C:055a  A8          TAY
next_inventory_object:
.C:055b  88          DEY
.C:055c  D0 E8       BNE check_if_object_is_in_inventory
;--------------------------------------------------
; Active room check
;--------------------------------------------------
check_room:
.C:055e  AD 49 71    LDA current_room
;Is there an active room?
.C:0561  D0 03       BNE active_room
;If not, loop back
.C:0563  4C FD 04    JMP main_loop
;--------------------------------------------------
; Sentence processing
;--------------------------------------------------
active_room:
;If there's a destination entity, walk to it and trigger action on contact
.C:0566  20 D0 0C    JSR trigger_action_on_entity_contact
.C:0569  20 7C 07    JSR process_sentence
.C:056c  20 9C 0B    JSR handle_sentence_queue
;--------------------------------------------------
; Flip mouth graphics of talking actors
;--------------------------------------------------
;Use .X as actor index, start at #03, go downwards
.C:056f  A2 03       LDX #$03
;Flip mouth states if the actor is speaking 
;This will be used later on to pick the correct mouth graphic
;
;An actor is speaking only when bit 0 is set (states #01 and #FF)
;States #00 and #80 don't get flipped as bit 0 is clear
flip_mouth_state:
.C:0571  BD 9D FE    LDA mouth_state_for_actor,X
;If bit 0 is clear, skip to next actor
.C:0574  29 01       AND #$01
.C:0576  F0 08       BEQ next_actor
;Bit 0 is set, flip all other bits (#01 <-> #FF)
.C:0578  BD 9D FE    LDA mouth_state_for_actor,X
.C:057b  49 FE       EOR #$FE
.C:057d  9D 9D FE    STA mouth_state_for_actor,X
next_actor:
.C:0580  CA          DEX
.C:0581  10 EE       BPL flip_mouth_state
;--------------------------------------------------
;Update all characters positions and limbs
.C:0583  20 61 33    JSR update_characters_positions_and_limbs
;Move camera as needed to pan or track actors
.C:0586  20 71 06    JSR move_camera
;Set scroll flag to "no scroll"
.C:0589  A9 C8       LDA #$C8
.C:058b  85 4E       STA screen_scroll_flag
;Has the camera reached its desired position?
;If not, we have to update the room scene
.C:058d  AE 66 06    LDX camera_desired_position
.C:0590  EC 67 06    CPX camera_current_position
.C:0593  F0 26       BEQ update_actors
;Draw the updated room scene
.C:0595  20 4D 40    JSR draw_room_scene
;Has the room scene rendering just started? If not, skip to advance animation
.C:0598  A5 4E       LDA screen_scroll_flag
.C:059a  C9 01       CMP #$01
.C:059c  D0 17       BNE advance_animation
;--------------------------------------------------
; Room scene rendering just started
;--------------------------------------------------
;Check if any actor is behind a foreground layer
.C:059e  A2 03       LDX #$03
check_layer_for_actor:
.C:05a0  BD 53 FE    LDA costume_for_actor,X
.C:05a3  30 0D       BMI next_actor
.C:05a5  BD 18 FD    LDA layer_depth_for_actor,X
.C:05a8  F0 08       BEQ next_actor
;Actor behind foreground layer - refresh animation
.C:05aa  A9 01       LDA #$01
.C:05ac  1D 97 FD    ORA animation_state_for_actor,X
.C:05af  9D 97 FD    STA animation_state_for_actor,X
next_actor:
.C:05b2  CA          DEX
.C:05b3  10 EB       BPL check_layer_for_actor
;--------------------------------------------------
advance_animation:
;Advance all actor's animation counters, moves sprites as needed
.C:05b5  20 44 30    JSR advance_characters_animation
;Toggle the frame buffer used for the room scene, for the next frame
.C:05b8  20 4E 07    JSR alternate_frame_buffer
;--------------------------------------------------
update_actors:
;Redraw all active actors that need a refresh
.C:05bb  20 8C 33    JSR redraw_actors_that_need_refresh
;Update the set of sprite shapes to use for actors
.C:05be  AD 14 FD    LDA sprite_buffer
.C:05c1  18          CLC
.C:05c2  69 01       ADC #$01
.C:05c4  8D 6A 16    STA sprite_shapes_set_to_use
;--------------------------------------------------
; Shutter effect check and execution
;--------------------------------------------------
;Do we have to perform the "open shutter" effect?
.C:05c7  AD 6E 06    LDA open_shutter_flag
;If not, continue
.C:05ca  F0 12       BEQ make_walk_sounds
;Are the environment lights on? If not, continue
.C:05cc  AD AB FE    LDA lights_status
.C:05cf  C9 02       CMP #$02
.C:05d1  D0 03       BNE show_cursor
;Environment lights on, do the shutter effect
.C:05d3  20 C6 D6    JSR open_shutter
show_cursor:
;Clear the "open shutter" flag
.C:05d6  A9 00       LDA #$00
.C:05d8  8D 6E 06    STA open_shutter_flag
;Show cursor
.C:05db  8D 6C 16    STA hide_cursor
;--------------------------------------------------
; Walking sounds generation
;--------------------------------------------------
make_walk_sounds:
.C:05de  20 14 07    JSR make_walking_sounds
;--------------------------------------------------
; Flashlight beam handling
;--------------------------------------------------
;Are env lights off and flashlight on? (lights_status == #01)
;If not, skip to next section
.C:05e1  AD AB FE    LDA lights_status
.C:05e4  C9 01       CMP #$01
.C:05e6  D0 2F       BNE synchronize_on_video_update
;Lights_status is #01, so flashlight is the only source of light
;Is the scroll set to "no scroll"?
.C:05e8  A5 4E       LDA screen_scroll_flag
.C:05ea  C9 C8       CMP #$C8
.C:05ec  D0 13       BNE flashlight_coords_changed
;Have the flashlight beam coordinates changed?
.C:05ee  AD 7E FE    LDA cursor_x_pixel_quarter_relative
.C:05f1  CD 79 FE    CMP flashlight_beam_x
.C:05f4  D0 0B       BNE flashlight_coords_changed
.C:05f6  AD 7D FE    LDA cursor_y_pixel_half
.C:05f9  CD 7A FE    CMP flashlight_beam_y
.C:05fc  D0 03       BNE flashlight_coords_changed
;If not, skip to next section
.C:05fe  4C 17 06    JMP synchronize_on_video_update
;--------------------------------------------------
flashlight_coords_changed:
;Flashlight beam has moved
;Clear the current flashlight area
.C:0601  20 73 32    JSR clear_flashlight_area
;Update the beam's coordinates based on the cursor's coordinates
.C:0604  AD 7E FE    LDA cursor_x_pixel_quarter_relative
.C:0607  8D 79 FE    STA flashlight_beam_x
.C:060a  AD 7D FE    LDA cursor_y_pixel_half
.C:060d  8D 7A FE    STA flashlight_beam_y
;Redraw the flashlight area
.C:0610  20 7F 32    JSR draw_flashlight_area
;Set video memory mode to only copy color data
.C:0613  A9 03       LDA #$03
.C:0615  85 22       STA video_memory_mode
;--------------------------------------------------
; Synchronization point
;--------------------------------------------------
synchronize_on_video_update:
;Set synchronization signal indicating video is ready to be updated
.C:0617  A9 01       LDA #$01
.C:0619  85 8E       STA video_update_signal
;Wait for the signal to be cleared (it will be handled and cleared by irq_handler1)
wait_for_signal_clear:
.C:061b  A5 8E       LDA video_update_signal
.C:061d  D0 FC       BNE wait_for_signal_clear
;--------------------------------------------------
;This is a second sweep at the actors draw update, after waiting for the video update
;This is similar code to redraw_actors_that_need_refresh, but iterating over all characters instead of just active actors
.C:061f  A9 00       LDA #$00
.C:0621  85 15       STA costume_index
costume_index = $15
check_if_costume_gets_drawn:
.C:0623  A6 15       LDX costume_index
;Is there an actor assigned for this costume? If not, skip it
.C:0625  BD 57 FE    LDA actor_for_costume,X
.C:0628  30 23       BMI next_costume
.C:062a  85 D8       STA actor
.C:062c  8E 30 FC    STX active_costume
.C:062f  A6 D8       LDX actor
;Does the actor need to be drawn on screen?
.C:0631  BD 97 FD    LDA animation_state_for_actor,X
.C:0634  29 20       AND #$20
;If not, continue with next character
.C:0636  F0 15       BEQ next_costume
;Clear the "need to be drawn" state
.C:0638  BD 97 FD    LDA animation_state_for_actor,X
.C:063b  29 DF       AND #$DF
.C:063d  9D 97 FD    STA animation_state_for_actor,X
;Does the actor have a sprite index assigned? If not, skip it
.C:0640  BD 32 FC    LDA actor_sprite_index,X
.C:0643  C9 FF       CMP #$FF
.C:0645  F0 06       BEQ next_costume
;Convert the actor's position to a sprite position
.C:0647  20 15 30    JSR convert_actor_pos_to_sprite_pos
;Draw the actor
.C:064a  20 52 22    JSR draw_actor
next_costume:
.C:064d  E6 15       INC costume_index
.C:064f  A5 15       LDA costume_index
.C:0651  C9 19       CMP #$19
.C:0653  D0 CE       BNE check_if_costume_gets_drawn
;--------------------------------------------------
.C:0655  AD 66 06    LDA camera_desired_position
.C:0658  8D 67 06    STA camera_current_position
wait_for_handler_entry_count:
;Wait for 4 executions of the IRQ handlers before looping again
.C:065b  A5 D9       LDA irq_handler1_section_entry_count
.C:065d  C9 04       CMP #$04
.C:065f  90 FA       BCC wait_for_handler_entry_count
.C:0661  4C FD 04    JMP main_loop
;===========================================
left_follow_threshold:
.C:0668  0A
right_follow_threshold:
.C:0669  1E 
;===========================================
; Move the camera as needed (to pan or follow an actor)
;===========================================
left_follow_threshold = $0668 ;(#0A)
right_follow_threshold = $0669 ;(#1E)

move_camera:
;Is camera mode "pan to position" (#03)?
.C:0671  AD 6A 06    LDA camera_mode
.C:0674  C9 03       CMP #$03
.C:0676  D0 18       BNE check_mode_02
;------------------------------------
;Camera mode: pan to position
;
; Move the camera one position to the left or right towards the desired position
;------------------------------------
camera_mode_pan:
.C:0678  AD 66 06    LDA camera_desired_position
.C:067b  CD 6C 06    CMP pan_camera_to
.C:067e  B0 06       BCS camera_pos_ge_pan_pos
;Camera position < pan position
;Move camera 1 position to the right
.C:0680  EE 66 06    INC camera_desired_position
.C:0683  4C 8D 06    JMP pan_exit
;Camera position >= pan position
camera_pos_ge_pan_pos:
.C:0686  90 05       BCC pan_exit
.C:0688  F0 03       BEQ pan_exit
;Move camera 1 position to the left
.C:068a  CE 66 06    DEC camera_desired_position
pan_exit:
;Ensure the camera stays within proper limits
.C:068d  4C E0 06    JMP camera_boundary_check
;------------------------------------
check_camera_mode_follow:
;Is camera mode "follow costume" (#02)?
.C:0690  C9 02       CMP #$02
.C:0692  F0 03       BEQ camera_mode_follow
.C:0694  4C 04 07    JMP calculate_visible_edges
;------------------------------------
;Camera mode: follow costume
;------------------------------------
camera_mode_follow:
;Get the X position for the actor being followed
.C:0697  AE 6B 06    LDX camera_costume_to_follow
.C:069a  BD 57 FE    LDA actor_for_costume,X
.C:069d  AA          TAX
.C:069e  BD 41 FD    LDA position_x_for_actor,X
;Check if the position of the actor has exceeded the "camera follow thresholds"
;That is, if the actor went too far to one side, the camera needs to follow it
;
;Check if position < left follow threshold
.C:06a1  38          SEC
.C:06a2  ED 64 06    SBC room_scene_left_edge
.C:06a5  CD 68 06    CMP left_follow_threshold
.C:06a8  B0 08       BCS check_right_follow_threshold
;Threshold exceeded - camera needs to pan
.C:06aa  A9 01       LDA #$01
.C:06ac  8D 6D 06    STA actor_follow_needs_pan
.C:06af  4C BE 06    JMP is_pan_needed
;------------------------------------
check_right_follow_threshold:
;Check if position > right follow threshold
.C:06b2  CD 69 06    CMP right_follow_threshold
.C:06b5  90 07       BCC is_pan_needed
.C:06b7  F0 05       BEQ is_pan_needed
;Threshold exceeded - camera needs to pan
.C:06b9  A9 01       LDA #$01
.C:06bb  8D 6D 06    STA actor_follow_needs_pan
;------------------------------------
is_pan_needed:
;Do we need to pan to follow the actor? If not, skip this part
.C:06be  AD 6D 06    LDA actor_follow_needs_pan
.C:06c1  F0 1D       BEQ camera_boundary_check
;We need to pan
;Compare the actor position and the camera position
.C:06c3  BD 41 FD    LDA position_x_for_actor,X
.C:06c6  CD 66 06    CMP camera_desired_position
.C:06c9  D0 08       BNE actor_pos_ne_camera_pos
;Actor and camera positions are equal
;Stop the pan and continue to the next section
.C:06cb  A9 00       LDA #$00
.C:06cd  8D 6D 06    STA actor_follow_needs_pan
.C:06d0  4C E0 06    JMP camera_boundary_check
;------------------------------------
actor_pos_ne_camera_pos:
;Actor and camera positions are not equal
;Increase or decrease the camera position as needed
.C:06d3  90 08       BCC actor_pos_le_camera_pos
.C:06d5  F0 06       BEQ actor_pos_le_camera_pos
;Actor position > camera position
.C:06d7  EE 66 06    INC camera_desired_position
.C:06da  4C E0 06    JMP camera_boundary_check
;------------------------------------
;Actor position <= camera position
actor_pos_le_camera_pos:
.C:06dd  CE 66 06    DEC camera_desired_position
;------------------------------------
camera_boundary_check:
;A room scene is #28 columns wide (the visible part of a room)
;The middle spot for a room scene is #14 columns from the visible left edge or right edge
;The camera cannot render a scene past the room's absolute left or right edges
;To achieve that, we have to make sure it's always centered at the right spot and doesn't move farther
;
;Is the camera position lower than the mid point for the room's absolute left edge?
.C:06e0  AD 66 06    LDA camera_desired_position
.C:06e3  38          SEC
.C:06e4  E9 14       SBC #$14
.C:06e6  B0 08       BCS check_right_anchor
;Anchor the room scene's left edge and then set the camera at exactly the visible mid point
;A room scene has #28 columns, so the mid point is #00 + #14
.C:06e8  A9 14       LDA #$14
.C:06ea  8D 66 06    STA camera_desired_position
.C:06ed  4C 04 07    JMP calculate_visible_edges
check_right_anchor:
;Is the camera position greater than the mid point for the room's absolute right edge?
.C:06f0  AD 66 06    LDA camera_desired_position
.C:06f3  18          CLC
.C:06f4  69 14       ADC #$14
.C:06f6  CD 39 71    CMP room_width
.C:06f9  90 09       BCC calculate_visible_edges
;Anchor the room scene's right edge and then set the camera at exactly the visible mid point
;A room scene has #28 columns, so the mid point is room_width - #14
.C:06fb  AD 39 71    LDA room_width
.C:06fe  38          SEC
.C:06ff  E9 14       SBC #$14
.C:0701  8D 66 06    STA camera_desired_position
;------------------------------------
calculate_visible_edges:
;Calculate the room scene's left and right edges
.C:0704  AD 66 06    LDA camera_desired_position
.C:0707  38          SEC
.C:0708  E9 14       SBC #$14
.C:070a  8D 64 06    STA room_scene_left_edge
.C:070d  18          CLC
.C:070e  69 27       ADC #$27
.C:0710  8D 65 06    STA room_scene_right_edge
.C:0713  60          RTS
;===========================================
; Make walking sounds as needed
;
; This routine will:
;	-check the current room (the mansion entrance rooms have cricket sounds; walking sounds don't apply there)
;	-check a routine entry counter (to avoid triggering the walking sound too often)
;	-for all actors in use, check if the motion bits == #02
;	-if so, it will play the walking sound for the costume as needed
;===========================================
entry_counter = $066f

make_walking_sounds:
;Are we in room #01 ("Front of mansion")? If so, exit - walking sounds don't apply here
.C:0714  AD 49 71    LDA current_room
.C:0717  C9 01       CMP #$01
.C:0719  D0 01       BNE check_room
.C:071b  60          RTS
check_room:
;Are we in room #2C ("Mansion road entrance")? If so, exit - walking sounds don't apply here
.C:071c  C9 2C       CMP #$2C
.C:071e  D0 01       BNE check_entry_counter
.C:0720  60          RTS
check_entry_counter:
;Decrease the routine entry counter
.C:0721  CE 6F 06    DEC entry_counter
;Did it reach a negative number? If not, exit
.C:0724  10 27       BPL exit
;It did, reset it to #02
.C:0726  A9 02       LDA #$02
.C:0728  8D 6F 06    STA entry_counter
;Use .X as actor index, start from #03, go downwards
.C:072b  A2 03       LDX #$03
check_actor:
;Is the actor in use? If not, continue with next actor
.C:072d  BC 53 FE    LDY costume_for_actor,X
.C:0730  30 18       BMI next_actor
;Is the actor stopped? If so, continue with next actor
.C:0732  BD 68 FD    LDA motion_state_for_actor,X
.C:0735  C9 02       CMP #$02
.C:0737  F0 11       BEQ next_actor
;Test character's animation settings for walking sound (bits 5-0)
.C:0739  B9 D9 F0    LDA character_animation_settings,Y
.C:073c  29 3F       AND #$3F
;If it's #00, there's no sound to be played, continue with next actor
.C:073e  F0 0A       BEQ next_actor
;Mark that no script is being executed
.C:0740  A0 FF       LDY #$FF
.C:0742  8C B8 70    STY current_script_slot
;Play the walking sound resulting from the AND
.C:0745  20 2E 66    JSR start_sound_entry2
;Set .X to #00 to break the loop
.C:0748  A2 00       LDX #$00
next_actor:
.C:074a  CA          DEX
.C:074b  10 E0       BPL check_actor
exit:
.C:074d  60          RTS
;===========================================
alternate_frame_buffer:
;If lights_status != #02 (environment lights on), exit
.C:074e  AD AB FE    LDA lights_status
.C:0751  C9 02       CMP #$02
.C:0753  D0 25       BNE exit
;Lights_status == #02, environment lights on
;Check current frame_buffer
.C:0755  A5 23       LDA frame_buffer
.C:0757  C9 01       CMP #$01
.C:0759  D0 11       BNE switch_to_frame_buffer_1
switch_to_frame_buffer_2:
;Set pointer to C828
.C:075b  A9 28       LDA #$28
.C:075d  85 24       STA <frame_buffer_base
.C:075f  A9 C8       LDA #$C8
.C:0761  85 25       STA >frame_buffer_base
;Set video memory mode #02 (CC00 base)
.C:0763  A9 02       LDA #$02
.C:0765  85 22       STA video_memory_mode
;Set frame buffer to #02
.C:0767  85 23       STA frame_buffer
.C:0769  4C 7A 07    JMP exit
switch_to_frame_buffer_1:
;Set pointer to CC28
.C:076c  A9 28       LDA #$28
.C:076e  85 24       STA <frame_buffer_base
.C:0770  A9 CC       LDA #$CC
.C:0772  85 25       STA >frame_buffer_base
;Set video memory mode #01 (C800 base)
.C:0774  A9 01       LDA #$01
.C:0776  85 22       STA video_memory_mode
;Set frame buffer to #01
.C:0778  85 23       STA frame_buffer
exit:
.C:077a  60          RTS
;===========================================
do_nothing:
.C:077b  60          RTS
;=========================================== 
; Process and execute a sentence as needed
;
; If the kid is dead or in a radiation suit, the only verb available is "New kid".
; If the control mode is "keypad", the verb is forced to "Push" (to push buttons just by clicking on them).
; The "Give" verb requires the indirect object to be an actor.
;=========================================== 
process_sentence:
;Do we need to reset the sentence? If not, continue
.C:077c  AD 8F FE    LDA reset_sentence_queue_system_flag
.C:077f  F0 19       BEQ limit_verbs
;-------------------------------------------
; Reset sentence
;-------------------------------------------
;Is there a preposition selected? If not, full reset is not needed
;Just clear the sentence reset flag and continue
.C:0781  AD 22 FE    LDA preposition
.C:0784  F0 11       BEQ clear_sentence_reset
;Clear all sentence parts
.C:0786  A9 00       LDA #$00
.C:0788  8D 22 FE    STA preposition
.C:078b  8D 23 FE    STA indirect_object_idx_lo
.C:078e  8D 24 FE    STA indirect_object_idx_hi
.C:0791  8D 20 FE    STA direct_object_idx_lo
.C:0794  8D 21 FE    STA direct_object_idx_hi
clear_sentence_reset:
.C:0797  8D 8F FE    STA reset_sentence_queue_system_flag
;-------------------------------------------
; Limit verbs if dead or in the radiation suit
;-------------------------------------------
limit_verbs:
;Check if the current kid is dead or in the radiation suit
;If so, the verbs are limited
;If not, continue
.C:079a  AE 67 FF    LDX current_kid
.C:079d  BD E3 FE    LDA actor_vars,X
.C:07a0  10 0C       BPL check_control_mode
;Kid is dead or in a suit, only "new kid" is allowed
;Is the verb "new kid"? If so, continue
.C:07a2  AD 1F FE    LDA current_verb
.C:07a5  C9 07       CMP NEW_KID_VERB
.C:07a7  F0 05       BEQ check_control_mode
;Otherwise clear the verb
.C:07a9  A9 00       LDA #$00
.C:07ab  8D 1F FE    STA current_verb
;-------------------------------------------
check_control_mode:
;Switch based on control_mode
.C:07ae  AD A8 FE    LDA control_mode
.C:07b1  C9 00       CMP CUTSCENE_CONTROL_MODE
.C:07b3  D0 03       BNE check_keypad_mode
;-------------------------------------------
;Case #00 - cutscene
;-------------------------------------------
;Check if the sentence is complete and execute it if so
.C:07b5  4C 74 08    JMP run_sentence_if_complete
;-------------------------------
check_keypad_mode:
.C:07b8  C9 01       CMP KEYPAD_CONTROL_MODE			
.C:07ba  D0 05       BNE normal_mode
;-------------------------------------------
;Case #01 - keypad mode (keypads and start screen)
;-------------------------------------------
;Force the verb to "Push" (as you can only push buttons)
.C:07bc  A9 09       LDA PUSH_VERB
.C:07be  8D 1F FE    STA current_verb
;-------------------------------------------
;Case #02 and #03 (normal play)
;-------------------------------------------
normal_mode:
;Is the verb "what is"?
.C:07c1  AD 1F FE    LDA current_verb
.C:07c4  C9 0F       CMP WHAT_IS_VERB
.C:07c6  D0 05       BNE check_trigger_sentence
;Verb "What is" - force a trigger of a sentence
.C:07c8  A9 01       LDA #$01
.C:07ca  8D 8E FE    STA click_trigger_sentence
check_trigger_sentence:
;Has a sentence trigger been set?
.C:07cd  AD 8E FE    LDA click_trigger_sentence
.C:07d0  C9 01       CMP #$01
.C:07d2  F0 03       BEQ sentence_forced_triggered
;Sentence has not been force-triggered, check if it's complete and execute it if so
.C:07d4  4C 74 08    JMP run_sentence_if_complete
;-------------------------------------------
; A sentence has been force triggered
;-------------------------------------------
sentence_forced_triggered:
;Clear the forced triggered flag
.C:07d7  A9 FF       LDA #$FF
.C:07d9  8D 8E FE    STA click_trigger_sentence
;If the verb is "Give", handle it separately (as it requires an actor as indirect object)
.C:07dc  AD 1F FE    LDA current_verb
.C:07df  C9 03       CMP GIVE_VERB
;Otherwise, handle all other verbs normally
.C:07e1  D0 0B       BNE find_object_under_cursor
;-------------------------------------------
;"Give" verb
;-------------------------------------------
;If the preposition is not set yet, it means we don't have a direct object yet
;Then find an object under the cursor - to get a direct object
.C:07e3  AD 22 FE    LDA preposition
.C:07e6  F0 06       BEQ find_object_under_cursor
;-------------------------------------------
;Preposition is already set for "give", which means a direct object has been set
;Now find the actor under the cursor - to determine the indirect object
.C:07e8  20 FD 3B    JSR find_actor_enclosing_cursor
.C:07eb  4C F1 07    JMP check_if_object_found
;-------------------------------------------
find_object_under_cursor:
;Find an object under the cursor's position
;If a valid object is found, .X/.A will contain the object lo/hi indexes
.C:07ee  20 3E 3C    JSR get_object_enclosing_cursor
;-------------------------------------------
check_if_object_found:
;Did we find an object? (.X != #00)
.C:07f1  E0 00       CPX #$00
.C:07f3  D0 15       BNE object_found
;-------------------------------------------
;No object found
;-------------------------------------------
;Is the verb "walk to"? 
;It doesn't strictly require a direct object, it can simply use the cursor's location
.C:07f5  AD 1F FE    LDA current_verb
.C:07f8  C9 0D       CMP WALK_TO_VERB
.C:07fa  D0 0B       BNE finalize_processing_3
;-------------------------------------------
;Verb "Walk to"
;Clear direct and indirect objects, and preposition
.C:07fc  A9 00       LDA #$00
.C:07fe  8D 20 FE    STA direct_object_idx_lo
.C:0801  8D 22 FE    STA preposition
.C:0804  8D 23 FE    STA indirect_object_idx_lo
finalize_processing_3:
.C:0807  4C 5F 08    JMP finalize_processing
;-------------------------------------------
; Object found
;-------------------------------------------
object_found:
;Do we have a preposition in place?
;If so, a direct object is already in place, we are finding an indirect object
;If not, we are finding a direct object
.C:080a  AC 22 FE    LDY preposition
.C:080d  F0 2C       BEQ check_for_new_direct_object
check_if_new_indirect_object:
;We do, see if the found indirect object is a _new_ indirect object
; (that is, if it's different from the current one)
.C:080f  EC 23 FE    CPX indirect_object_idx_lo
.C:0812  D0 09       BNE check_if_complements_are_identical
.C:0814  CD 24 FE    CMP indirect_object_idx_hi
.C:0817  D0 04       BNE check_if_complements_are_identical
;It's the same indirect object as before
.C:0819  A0 01       LDY #$01
.C:081b  84 95       STY rebuild_action_sentence
;-------------------------------------------
check_if_complements_are_identical:
;Just in case, is the indirect object (data in .X/.A) the same as the direct object?
.C:081d  EC 20 FE    CPX direct_object_idx_lo
.C:0820  D0 05       BNE set_new_indirect_object
.C:0822  CD 21 FE    CMP direct_object_idx_hi
;Indirect object is the same as the direct object, so finalize processing here
.C:0825  F0 11       BEQ finalize_processing_2
set_new_indirect_object:
;We definitely have a new indirect object, set it
.C:0827  8E 23 FE    STX indirect_object_idx_lo
.C:082a  8D 24 FE    STA indirect_object_idx_hi
;-------------------------------------------
;If we're in keypad mode, the sentence is not rendered, so don't rebuild it
.C:082d  AD A8 FE    LDA control_mode
.C:0830  C9 01       CMP KEYPAD_CONTROL_MODE
.C:0832  D0 04       BNE finalize_processing_2
;Rebuild the action sentence
.C:0834  A9 01       LDA #$01
.C:0836  85 95       STA rebuild_action_sentence
finalize_processing_2:
.C:0838  4C 5F 08    JMP finalize_processing
;-------------------------------------------
check_for_new_direct_object:
;See if the object we found (data in .X/.A) is a _new_ direct object
.C:083b  EC 20 FE    CPX direct_object_idx_lo
.C:083e  D0 09       BNE set_new_direct_object
.C:0840  CD 21 FE    CMP direct_object_idx_hi
.C:0843  D0 04       BNE set_new_direct_object
;It's the same direct object as before
.C:0845  A0 01       LDY #$01
.C:0847  84 95       STY rebuild_action_sentence
set_new_direct_object:
;We have a new direct object, set it
.C:0849  8E 20 FE    STX direct_object_idx_lo
.C:084c  8D 21 FE    STA direct_object_idx_hi
.C:084f  A9 01       LDA #$01
.C:0851  8D 49 FE    STA refresh_sentence_bar_flag
;-------------------------------------------
;If we're in keypad mode, the sentence is not rendered, so don't rebuild it
.C:0854  AD A8 FE    LDA control_mode
.C:0857  C9 01       CMP KEYPAD_CONTROL_MODE
.C:0859  D0 04       BNE finalize_processing
.C:085b  A9 01       LDA #$01
.C:085d  85 95       STA rebuild_action_sentence
;-------------------------------------------
finalize_processing:
;We're done updating the complements
;Set the sentence bar as needing a refresh
.C:085f  A9 01       LDA #$01
.C:0861  8D 49 FE    STA refresh_sentence_bar_flag
;Is the verb "walk to"?
.C:0864  AD 1F FE    LDA current_verb
.C:0867  C9 0D       CMP WALK_TO_VERB
.C:0869  D0 09       BNE run_sentence_if_complete
;Verb is "Walk to"
;Clear destination entity
.C:086b  A9 00       LDA #$00
.C:086d  8D 51 FE    STA destination_entity
;Rebuild the action sentence
.C:0870  A9 01       LDA #$01
.C:0872  85 95       STA rebuild_action_sentence
;Fall through
;===========================================
; Run a sentence, if all the necessary sentence parts are in place
;
; If all the parts are in place, it will invoke process_action.
; If parts are still missing, it will refresh the sentence bar but not execute the action.
;
; This will depend on the verb.
; For instance, "Walk to" only requires a cursor location. A direct object is optional.
; If the verb is "Walk to" and there's no direct object, it will execute the action.
;
; Most of the verbs require only a direct object (open, close, push, pull, turn on, turn off, read, pick up).
; Other verbs require an indirect object also (give, unlock, fix, use).
;===========================================
run_sentence_if_complete:
;Refresh the sentence bar before doing anything
.C:0874  20 C6 08    JSR refresh_sentence_bar
;Do we need to rebuild the sentence from scratch? If so, refresh the sentence bar
;This seems completely redundant as we have just done so
.C:0877  A5 95       LDA rebuild_action_sentence
.C:0879  F0 4B       BEQ refresh_sentence_bar
;Clear the rebuild flag, as we're rebuilding now
.C:087b  A9 00       LDA #$00
.C:087d  85 95       STA rebuild_action_sentence
;Is the verb empty?
.C:087f  AD 1F FE    LDA current_verb
.C:0882  D0 03       BNE check_new_kid_verb
;If so, refresh and exit
.C:0884  4C F0 0A    JMP check_refresh_sentence_2	;This is a JMP refresh_sentence_bar
check_new_kid_verb:
;Verb set - is it the "new kid" verb?
.C:0887  C9 07       CMP NEW_KID_VERB
.C:0889  D0 03       BNE check_walk_to_verb
;-----------------------
; "New kid" verb
;-----------------------
;New kid is a special case - handle it separately
.C:088b  4C 9B 09    JMP handle_new_kid_verb
;-----------------------
check_walk_to_verb:
;Is the verb "walk to"?
.C:088e  C9 0D       CMP WALK_TO_VERB
.C:0890  D0 03       BNE check_direct_object
;-----------------------
; "Walk to" verb
;-----------------------
;We have all necessary parts in place, as "walk to" doesn't strictly require a direct object
.C:0892  4C F3 0A    JMP process_action
;-----------------------
;All other verbs (which require a direct object)
check_direct_object:
;Do we have a direct object determined?
.C:0895  AD 20 FE    LDA direct_object_idx_lo
.C:0898  D0 06       BNE check_preposition
;We don't, refresh the sentence with what we have so far, and exit
.C:089a  4C F0 0A    JMP check_refresh_sentence_2
;.C:089d  4C C6 08    JMP refresh_sentence_bar	;Unreachable code
;-----------------------
check_preposition:
;We have a direct object - do we have a preposition determined?
.C:08a0  AD 22 FE    LDA preposition
;If not, determine one
.C:08a3  F0 0E       BEQ determine_preposition_2
;We do have a preposition - do we have an indirect object determined?
.C:08a5  AD 23 FE    LDA indirect_object_idx_lo
;If not, refresh the sentence with what we have so far, and exit
.C:08a8  F0 06       BEQ check_refresh_sentence_3
;We have all necessary parts in place, process the action
.C:08aa  4C F3 0A    JMP process_action
;.C:08ad  4C B3 08    JMP determine_preposition_2	;Unreachable code
check_refresh_sentence_3:
.C:08b0  4C F0 0A    JMP check_refresh_sentence_2	;This is a JMP refresh_sentence_bar
;-----------------------
determine_preposition_2:
;Determine the preposition
.C:08b3  20 BD 0A    JSR determine_preposition
;Do we actually need one? (determine_preposition will return #00 if one is not needed)
.C:08b6  D0 06       BNE preposition_needed
;No preposition needed - and no indirect object needed either
;Then we have all necessary parts in place, process the action
.C:08b8  4C F3 0A    JMP process_action
;.C:08bb  4C C6 08    JMP refresh_sentence_bar		;Unreachable code
;-----------------------
preposition_needed:
;There was a preposition needed and we determined it, save it
.C:08be  8D 22 FE    STA preposition
;Refresh the sentence with what we have so far
.C:08c1  A9 01       LDA #$01
.C:08c3  8D 49 FE    STA refresh_sentence_bar_flag
;Fall through
;===========================================
; Refresh the sentence bar contents
;
; The sentence bar will be refreshed only if both:
;
;	-the refresh_sentence_bar_flag is True (nonzero)
;	-control_mode is not keypad or cutscene
;===========================================
refresh_sentence_bar:
;Do we need to refresh the sentence bar?
;If not, exit
.C:08c6  AD 49 FE    LDA refresh_sentence_bar_flag
.C:08c9  D0 03       BNE check_control_mode
.C:08cb  4C 6E 09    JMP exit
check_control_mode:
;We have to refresh the sentence bar
;Clear the refresh sentence bar flag
.C:08ce  A9 00       LDA #$00
.C:08d0  8D 49 FE    STA refresh_sentence_bar_flag
;If we're in Cutscene or Keypad control mode, exit
.C:08d3  AD A8 FE    LDA control_mode
.C:08d6  C9 01       CMP #$01
.C:08d8  F0 02       BEQ exit
;Otherwise, continue printing the sentence bar text
.C:08da  B0 01       BCS print_sentence_bar_text
exit:
;Modes #00 (cutscene) and #01 (keypad), exit
.C:08dc  60          RTS
;===========================================
; Prints the text in the sentence bar
;
; This routine will process the current sentence parts (verb, direct object,
; indirect object and preposition) and append them in the correct order.
;
; It will also validate if the recipient for a "Give" verb is valid, and clear it out if not.
; If the verb is "New Kid", it will delegate that special case to the print_kid_names_on_sentence_bar routine.
;===========================================
word_to_append = $15

print_sentence_bar_text:
;Clear the sentence text
.C:08dd  20 82 0A    JSR setup_and_clear_sentence_bar
;Set text length to #00
.C:08e0  A9 00       LDA #$00
.C:08e2  8D 72 0E    STA action_bar_current_text_length
;Check if the verb is "New Kid"
.C:08e5  AD 1F FE    LDA current_verb
.C:08e8  C9 07       CMP NEW_KID_VERB		
.C:08ea  D0 03       BNE is_verb_empty
;----------------------------
;"New kid" verb - print the kids' names on the sentence bar and exit
.C:08ec  4C 6F 09    JMP print_kid_names_on_sentence_bar
;----------------------------
is_verb_empty:
.C:08ef  C9 00       CMP #$00
.C:08f1  D0 05       BNE append_verb
;Verb is empty - set "walk to" as default
.C:08f3  A9 0D       LDA WALK_TO_VERB
.C:08f5  8D 1F FE    STA current_verb
append_verb:
;Append the verb to the sentence text
.C:08f8  AA          TAX
.C:08f9  BD 0B F2    LDA verb_pointers_hi,X
.C:08fc  85 16       STA >word_to_append
.C:08fe  BD 1B F2    LDA verb_pointers_lo,X
.C:0901  85 15       STA <word_to_append
.C:0903  20 94 0A    JSR append_word
;----------------------------
;Is there a direct object?
.C:0906  AD 20 FE    LDA direct_object_idx_lo
;If not, exit
.C:0909  F0 63       BEQ exit
append_direct_object:
;Append the direct object's name to the sentence text
.C:090b  AA          TAX
.C:090c  AD 21 FE    LDA direct_object_idx_hi
.C:090f  20 E3 09    JSR get_object_name_pointer
.C:0912  20 94 0A    JSR append_word
;----------------------------
;Is there a preposition?
.C:0915  AD 22 FE    LDA preposition
.C:0918  D0 12       BNE check_preposition
;No, check if we need one
.C:091a  20 BD 0A    JSR determine_preposition
;If we don't need a preposition, continue
.C:091d  C9 00       CMP PREPOSITION_NONE_NEEDED
.C:091f  F0 0B       BEQ check_preposition
;Preposition determined
.C:0921  8D 22 FE    STA preposition
;Clear indirect object (as we've only just determined the preposition)
.C:0924  A9 00       LDA #$00
.C:0926  8D 23 FE    STA indirect_object_idx_lo
.C:0929  8D 24 FE    STA indirect_object_idx_hi
;----------------------------
check_preposition:
.C:092c  AD 22 FE    LDA preposition
.C:092f  F0 3D       BEQ exit
;Append the preposition's name to the sentence text
.C:0931  AA          TAX
.C:0932  BD 2A F2    LDA preposition_pointers_hi,X
.C:0935  85 16       STA >word_to_append
.C:0937  BD 2E F2    LDA preposition_pointers_lo,X
.C:093a  85 15       STA <word_to_append
.C:093c  20 94 0A    JSR append_word
;----------------------------
;Check if the verb is "Give", as it's a special case
.C:093f  AD 1F FE    LDA current_verb
.C:0942  C9 03       CMP GIVE_VERB		
.C:0944  D0 0F       BNE append_indirect_object
;----------------------------
;"Give" verb
;Is the current indirect object an object that _is allowed_ to be a "Give" indirect object?
;That is, index_hi must be #02
.C:0946  AD 24 FE    LDA indirect_object_idx_hi
.C:0949  C9 02       CMP #$02
;If so, we're ok, append it
.C:094b  F0 08       BEQ append_indirect_object
;It's not, so clear the indirect object
.C:094d  A9 00       LDA #$00
.C:094f  8D 23 FE    STA indirect_object_idx_lo
.C:0952  8D 24 FE    STA indirect_object_idx_hi
;----------------------------
append_indirect_object:
;If there's no indirect object, exit
.C:0955  AD 23 FE    LDA indirect_object_idx_lo
.C:0958  F0 14       BEQ exit
;Check if the indirect object is a character or an object
.C:095a  AA          TAX
.C:095b  AD 24 FE    LDA indirect_object_idx_hi
;Is it a character?
.C:095e  C9 02       CMP #$02
;If not, treat it as an object and get its name
.C:0960  D0 06       BNE append_object_name
;It's a character, prepare its name for the append
.C:0962  20 D8 09    JSR setup_character_name_append
.C:0965  4C 6B 09    JMP do_append
append_object_name:
.C:0968  20 E3 09    JSR get_object_name_pointer
do_append:
.C:096b  20 94 0A    JSR append_word
exit:
.C:096e  60          RTS
;===========================================
;Print each kid's name in their appropriate positions in the sentence bar
;
; Arguments: 	None
;===========================================
sentence_bar_text_ptr = $19

print_kid_names_on_sentence_bar:
;First kid
.C:096f  AE C8 FF    LDX first_kid_id		
;Append the kid's name
.C:0972  20 D8 09    JSR setup_character_name_append
.C:0975  20 94 0A    JSR append_word
;------------------
;Second kid
;Adjust destination text buffer (for the sentence bar) to point to the position
; where the 2nd kid name must be printed
.C:0978  A9 DD       LDA #<sentence_bar_2nd_kid_name_offset
.C:097a  85 19       STA <sentence_bar_text_ptr
.C:097c  A9 CE       LDA #>sentence_bar_2nd_kid_name_offset
.C:097e  85 1A       STA >sentence_bar_text_ptr
;Append the kid's name
.C:0980  AE C9 FF    LDX second_kid_id
.C:0983  20 D8 09    JSR setup_character_name_append
.C:0986  20 94 0A    JSR append_word
;------------------
;Third kid
;Adjust destination text buffer (for the sentence bar) to point to the position
; where the 3rd kid name must be printed
.C:0989  A9 EA       LDA #<sentence_bar_3rd_kid_name_offset
.C:098b  85 19       STA <sentence_bar_text_ptr
.C:098d  A9 CE       LDA #>sentence_bar_3rd_kid_name_offset
.C:098f  85 1A       STA >sentence_bar_text_ptr
;Append the kid's name
.C:0991  AE CA FF    LDX third_kid_id
.C:0994  20 D8 09    JSR setup_character_name_append
.C:0997  20 94 0A    JSR append_word
.C:099a  60          RTS
;===========================================
; Handle processing of the "new kid" verb
;
; This would be triggered by clicking on the "new kid" verb first,
; then on one of the 3 kid names displayed on the sentence bar.
;
; This routine will check if changing kids is allowed (based on control_mode).
;
; Arguments:	none explicitly
;				cursor coordinates are used to compute the kid number
;===========================================
SECOND_KID_NAME_COLUMN = #$0B
THIRD_KID_NAME_COLUMN = #$18

handle_new_kid_verb:
;New kid verb processing
;Is kid change is allowed? (Control mode must be == #03)
.C:099b  AD A8 FE    LDA control_mode
.C:099e  C9 03       CMP #$03
;If not, set verb to "walk to", refresh sentence and exit
.C:09a0  D0 2B       BNE set_walk_and_exit
;Kid change allowed
;Use the cursor's X position to find which kid was selected in the sentence bar
.C:09a2  AD 7E FE    LDA cursor_x_pixel_quarter_relative
.C:09a5  C9 0B       CMP SECOND_KID_NAME_COLUMN
.C:09a7  B0 05       BCS third_kid_check
;--------------------------------------
;First kid selected
.C:09a9  A9 00       LDA #$00
.C:09ab  4C BB 09    JMP select_kid
;--------------------------------------
third_kid_check:
.C:09ae  C9 18       CMP THIRD_KID_NAME_COLUMN
.C:09b0  90 07       BCC second_kid_selected
.C:09b2  F0 05       BEQ second_kid_selected
;--------------------------------------
;Third kid selected
.C:09b4  A9 02       LDA #$02
.C:09b6  4C BB 09    JMP select_kid
;--------------------------------------
second_kid_selected:
;Second kid selected
.C:09b9  A9 01       LDA #$01
;--------------------------------------
select_kid:
;Save the selected kid index in the stack
.C:09bb  48          PHA
;Reset the sentence back to "walk to"
.C:09bc  A9 0D       LDA WALK_TO_VERB
.C:09be  8D 1F FE    STA current_verb
;Refresh the sentence bar
.C:09c1  A9 01       LDA #$01
.C:09c3  8D 49 FE    STA refresh_sentence_bar_flag
.C:09c6  20 C6 08    JSR refresh_sentence_bar
;Restore the selected kid index and execute the kid change
.C:09c9  68          PLA
.C:09ca  20 AE 29    JSR validate_new_kid_change
;--------------------------------------
;Set verb to "walk to", refresh sentence again, and exit
set_walk_and_exit:
.C:09cd  A9 0D       LDA WALK_TO_VERB
.C:09cf  8D 1F FE    STA current_verb
.C:09d2  A9 01       LDA #$01
.C:09d4  8D 49 FE    STA refresh_sentence_bar_flag
.C:09d7  60          RTS
;===========================================
; Sets up a character's name so that it can be appended by append_word
;
; Argument: .X - word index
;===========================================
character_names_hi = $f0f2
character_names_lo = $f10a
word_buffer = $15

setup_character_name_append:
.C:09d8  BD F2 F0    LDA character_names_hi,X
.C:09db  85 16       STA >word_buffer
.C:09dd  BD 0A F1    LDA character_names_lo,X
.C:09e0  85 15       STA <word_buffer
.C:09e2  60          RTS
;===========================================
; Get an object's name pointer
;
; Arguments:	.X	object_index
;				.A	object_location
;					#00 - inventory
;					#01 - room
;				pointer		pointer to object's data
; Returns:		pointer		pointer to object's name
;===========================================
object_pointer = $15
get_object_name_pointer:
;Get object resource
.C:09e3  20 05 0A    JSR get_obj_resource
;Object found?
.C:09e6  C9 FF       CMP #$FF
.C:09e8  D0 04       BNE update_pointer
;If not, invalidate the sentence and return
.C:09ea  20 CC 29    JSR reset_sentence_queue_system
.C:09ed  60          RTS
update_pointer:
;Read offset to object's name from pointer + #0D
.C:09ee  A0 0D       LDY #$0D
.C:09f0  B1 15       LDA (object_pointer),Y
;Add the offset to the pointer
.C:09f2  18          CLC
.C:09f3  65 15       ADC <object_pointer
.C:09f5  85 15       STA <object_pointer
.C:09f7  90 02       BCC return_00
.C:09f9  E6 16       INC >object_pointer
return_00:
.C:09fb  A9 00       LDA #$00
.C:09fd  60          RTS
;===========================================
; Get an object's resource, if the object is not a character
;
; Arguments:	.X 	object index lo
; 				.A	object index hi
;
; Returns:		.A	#FF		if object is a character
;				otherwise, returns whatever get_obj_resource returns
;
; Characters have the object hi set to #02 (can be a recipient of a "Give" sentence)
;===========================================
get_obj_if_not_a_character:
;Is the object hi index (in .A) #02?
.C:09fe  C9 02       CMP #$02
;If not, get the object's resource
.C:0a00  D0 03       BNE get_obj_resource
;Object hi is #02, return #FF
.C:0a02  A9 FF       LDA #$FF
.C:0a04  60          RTS
;===========================================
; Get an object's resource pointer
;
;Arguments:		.X 	object index lo
; 				.A	object index hi
;					If #00, movable object, find it in the inventory
;					If nonzero, immovable object, find it in the room
;
;	
; Returns:		.A	#00		object found in inventory
;					#01		object found in room
;					#FF		object not found
;
;				object_ptr	pointer to object's data
;===========================================
;$15/$16 are used as input and output variables with different purposes
object_index_lo = $15
object_index_hi = $16
;Output parameter: pointer to object
object_ptr_lo = $15
object_ptr_hi = $16
object_offset_in_room_rsrc = $17

get_obj_resource:
;Store object indexes
.C:0a05  86 15       STX object_index_lo
.C:0a07  85 16       STA object_index_hi
;Is the index hi #00? 
;If not, it's an immovable object, it should be findable in the room
.C:0a09  C9 00       CMP #$00
.C:0a0b  D0 2A       BNE get_obj_resource_in_room
;Fetch attributes
.C:0a0d  BD 01 73    LDA object_attributes,X
;Mask the low nibble (object owner)
.C:0a10  29 0F       AND #$0F
;Is the owner "a room"? (#0F)
.C:0a12  C9 0F       CMP #$0F
;If so, search in a room
.C:0a14  F0 21       BEQ get_obj_resource_in_room
;-----------------------
; Search for object in the inventory
;-----------------------
.C:0a16  A0 2C       LDY MAX_INVENTORY_INDEX
check_inventory_object:
.C:0a18  B9 31 70    LDA inventory_objects,Y
.C:0a1b  C5 15       CMP object_index_lo
.C:0a1d  D0 15       BNE next_inventory_object
;Object found - copy object resource pointers
.C:0a1f  B9 8B 70    LDA object_rsrc_ptrs_hi,Y
.C:0a22  85 16       STA object_ptr_hi
.C:0a24  B9 5E 70    LDA object_rsrc_ptrs_lo,Y
.C:0a27  85 15       STA object_ptr_lo
;Clear the room object offset
.C:0a29  A9 00       LDA #$00
.C:0a2b  85 17       STA <object_offset_in_room_rsrc
.C:0a2d  A9 00       LDA #$00
.C:0a2f  85 18       STA >object_offset_in_room_rsrc
;Return #00 - object found in inventory
.C:0a31  A9 00       LDA #$00
.C:0a33  60          RTS
next_inventory_object:
.C:0a34  88          DEY
.C:0a35  10 E1       BPL check_inventory_object
;-----------------------
; Search for object in a room
;-----------------------
get_obj_resource_in_room:
.C:0a37  AC 5C 71    LDY total_objects_in_room
check_room_object:
.C:0a3a  B9 3D 72    LDA room_object_index_lo,Y
.C:0a3d  C5 15       CMP object_index_lo
.C:0a3f  D0 3B       BNE next_room_object
.C:0a41  B9 21 72    LDA room_object_index_hi,Y
.C:0a44  C5 16       CMP object_index_hi
.C:0a46  D0 34       BNE next_room_object
;Objects with hi index set to #00 are "movable" (they might or might not be currently present in a room)
;Objects with hi index set to #01 are "immovable" (they can't be moved or mutated into a different object)
;If hi index is #00, check if the object is effectively in the room
.C:0a48  C9 00       CMP #$00
.C:0a4a  F0 03       BEQ check_if_obj_in_room
.C:0a4c  4C 5A 0A    JMP object_found
check_if_obj_in_room:
;Fetch object attributes
.C:0a4f  A6 15       LDX object_index_lo
.C:0a51  BD 01 73    LDA object_attributes,X
;Mask low-nibble (object owner)
.C:0a54  29 0F       AND #$0F
;Is the owner "a room"? (#0F)
.C:0a56  C9 0F       CMP #$0F
;If not, continue
.C:0a58  D0 22       BNE next_room_object
object_found:
;Multiply room object index by 2, set it into .X
.C:0a5a  98          TYA
.C:0a5b  0A          ASL A
.C:0a5c  AA          TAX
;Copy the room object offsets
.C:0a5d  BD C9 72    LDA room_object_offsets_lo,X
.C:0a60  85 17       STA <object_offset_in_room_rsrc
.C:0a62  BD CA 72    LDA room_object_offsets_hi,X
.C:0a65  85 18       STA >object_offset_in_room_rsrc
;object_ptr = room_rsrc_ptrs + object_offset_in_room_rsrc
.C:0a67  AE 49 71    LDX current_room
.C:0a6a  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:0a6d  18          CLC
.C:0a6e  65 17       ADC <object_offset_in_room_rsrc
.C:0a70  85 15       STA object_ptr_lo
.C:0a72  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:0a75  65 18       ADC >object_offset_in_room_rsrc
.C:0a77  85 16       STA object_ptr_hi
;Return #01 - object found in room
.C:0a79  A9 01       LDA #$01
.C:0a7b  60          RTS
next_room_object:
.C:0a7c  88          DEY
.C:0a7d  10 BB       BPL check_room_object
;Return #FF - object not found
.C:0a7f  A9 FF       LDA #$FF
.C:0a81  60          RTS
;===========================================
; Setup and clear the sentence bar
; 
; Arguments: None
;
; This routine will fill the sentence bar's text buffer with zeroes.
; It will also set up sentence_bar_text_ptr to the correct address, so further write operations
; can append text to it correctly.
;===========================================
sentence_bar_text_ptr = $19
setup_and_clear_sentence_bar:
;Point sentence_bar_text_ptr to the beginning of the sentence bar
.C:0a82  A9 D0       LDA #<SENTENCE_BAR_BASE
.C:0a84  85 19       STA <sentence_bar_text_ptr
.C:0a86  A9 CE       LDA #>SENTENCE_BAR_BASE
.C:0a88  85 1A       STA >sentence_bar_text_ptr
;Use .Y as index counter, start from the end, go downwards
.C:0a8a  A0 27       LDY text_bar_length
;Set #00 in .A as the value to clear with
.C:0a8c  A9 00       LDA #$00
clear_next_char:
;Clear buffer byte
.C:0a8e  91 19       STA (sentence_bar_text_ptr),Y
;Move Y downwards, loop as needed
.C:0a90  88          DEY
.C:0a91  10 FB       BPL clear_next_char
.C:0a93  60          RTS
;===========================================
; Append word to text buffer
;
; Arguments:
;		word_buffer					pointer to word
;		sentence_bar_text_ptr		pointer to sentence bar (at the append position)
;
; The word data must be zero-terminated.
; If the append operation exceeds the text buffer length,
; the text will be trimmed accordingly.
;
; A byte of #40 in a byte read from word_buffer will force the termination of the append.
; Same thing with a value of #00.
;===========================================
word_buffer = $15
sentence_bar_text_ptr = $19

append_word:
;Use .Y as index, start at #FF (incremented to #00 in the first iteration), go upwards
.C:0a94  A0 FF       LDY #$FF
read_next_char:
.C:0a96  EE 72 0E    INC action_bar_current_text_length
.C:0a99  C8          INY
;Read next input character from word_buffer
.C:0a9a  B1 15       LDA (word_buffer),Y		
;If the char is #40, the word is finished
.C:0a9c  C9 40       CMP #$40					
.C:0a9e  F0 0F       BEQ check_word_termination
;Check if char is #00, store Z flag in stack
;Z will be set if the char is #00
.C:0aa0  C9 00       CMP #$00
.C:0aa2  08          PHP
;Have we exceeded the max length of the text bar?
.C:0aa3  AE 72 0E    LDX action_bar_current_text_length
.C:0aa6  E0 28       CPX text_bar_length + 1
;If we're exactly at the end, copy this last char
.C:0aa8  F0 02       BEQ write_char
;If we're past the end, don't copy this char - keep reading (effectively trim the text)
.C:0aaa  B0 02       BCS restore_zero_flag
write_char:
;Write character to sentence_bar_text_ptr
.C:0aac  91 19       STA (sentence_bar_text_ptr),Y
;We compared the character against #00 and stored flags in the stack
;Restore flags
restore_zero_flag:
.C:0aae  28          PLP
check_word_termination:
;Is the Z flag clear (char != #00)? If so, keep reading
.C:0aaf  D0 E5       BNE read_next_char
;Append finished - add word length to text buffer pointer
; so it points to the end again (and we can do future appends)
.C:0ab1  C8          INY
.C:0ab2  98          TYA
.C:0ab3  18          CLC
.C:0ab4  65 19       ADC <sentence_bar_text_ptr
.C:0ab6  85 19       STA <sentence_bar_text_ptr
.C:0ab8  90 02       BCC exit
.C:0aba  E6 1A       INC >sentence_bar_text_ptr
exit:
.C:0abc  60          RTS
;===========================================
; Determines the correct preposition for a given verb and object
;
; Arguments: none
; Returns: .A	preposition index (#00 if no preposition needed)
;===========================================
;Prepositions: in, with, on, to

determine_preposition:
.C:0abd  AD 1F FE    LDA current_verb
.C:0ac0  C9 0B       CMP USE_VERB		
.C:0ac2  D0 13       BNE give_verb_check
;The "Use" verb varies the preposition depending on the object
;Fetch the object index
.C:0ac4  AE 20 FE    LDX direct_object_idx_lo
.C:0ac7  AD 21 FE    LDA direct_object_idx_hi
;Get the object resource
.C:0aca  20 05 0A    JSR get_obj_resource
;Read preposition data
.C:0acd  A0 0B       LDY #$0B
.C:0acf  B1 15       LDA ($15),Y
;Shift right 5 times - so bits 7-5 of the original byte encode the preposition index
.C:0ad1  4A          LSR A
.C:0ad2  4A          LSR A
.C:0ad3  4A          LSR A
.C:0ad4  4A          LSR A
.C:0ad5  4A          LSR A
.C:0ad6  60          RTS
give_verb_check:
;Is it the "give" verb?
.C:0ad7  C9 03       CMP GIVE_VERB	
.C:0ad9  D0 03       BNE check_preposition_with
;If so, use the "to" preposition
.C:0adb  A9 04       LDA PREPOSITION_TO
.C:0add  60          RTS
;Does the verb use the preposition "with"?
;This includes "unlock", "fix" and "new kid"(?)
check_preposition_with:
.C:0ade  C9 07       CMP NEW_KID_VERB		
.C:0ae0  F0 0B       BEQ preposition_with
.C:0ae2  C9 08       CMP UNLOCK_VERB
.C:0ae4  F0 07       BEQ preposition_with
.C:0ae6  C9 06       CMP FIX_VERB	
.C:0ae8  F0 03       BEQ preposition_with
;The verb doesn't use a preposition
.C:0aea  A9 00       LDA PREPOSITION_NONE_NEEDED
.C:0aec  60          RTS
preposition_with:
;Use the "with" preposition
.C:0aed  A9 02       LDA PREPOSITION_WITH
.C:0aef  60          RTS
;===========================================
check_refresh_sentence_2:
.C:0af0  4C C6 08    JMP refresh_sentence_bar
;===========================================
; Process the action for a complete sentence
;
; In the special case of walking to a location ("Walk to" verb and no specific object clicked),
; handle it by converting the cursor's coordinates to destination coordinates, and then
; building a path to the intended location.
;
; For everything else, add all of the sentence parts to the sentence parts queue.
;===========================================
destination_obj_lo = $fe4f
destination_obj_hi = $fe50

process_action:
.C:0af3  A9 06       LDA #$06
.C:0af5  8D 18 FE    STA sentence_queue_free_capacity
.C:0af8  A9 FF       LDA #$FF
.C:0afa  8D 17 FE    STA sentence_queue_index
;If verb is "What is", return, as there's nothing else to do
.C:0afd  AD 1F FE    LDA current_verb
.C:0b00  C9 0F       CMP WHAT_IS_VERB
.C:0b02  D0 01       BNE is_verb_walk_to
.C:0b04  60          RTS
is_verb_walk_to:
.C:0b05  C9 0D       CMP WALK_TO_VERB
.C:0b07  D0 4D       BNE queue_sentence
;----------------------------------------------
;Verb is "Walk to"
;Is there a direct object determined?
.C:0b09  AD 20 FE    LDA direct_object_idx_lo
;If so, treat the sentence as a full action (we have a clear destination, the direct object)
;If not, determine the destination on screen
.C:0b0c  D0 48       BNE queue_sentence
;----------------------------------------------
; Walk to location on screen (no specific object)
;----------------------------------------------
;Set the current kid as the character/costume in action
.C:0b0e  AD 67 FF    LDA current_kid
.C:0b11  8D 30 FC    STA active_costume
;Get the actor for the character
.C:0b14  AE 30 FC    LDX active_costume
.C:0b17  BD 57 FE    LDA actor_for_costume,X
.C:0b1a  AA          TAX
.C:0b1b  86 D8       STX actor
;Get destination coordinates from cursor's coordinates
.C:0b1d  AD 80 FE    LDA cursor_x_pixel_quarter_absolute
.C:0b20  8D E6 FD    STA x_destination
.C:0b23  AD 7F FE    LDA cursor_y_pixel_half_off_by_8
.C:0b26  8D E7 FD    STA y_destination
;Adjust destination based on boundary boxes
.C:0b29  20 9B 1A    JSR adjust_coords_by_walkbox
;Copy destination coordinates to debug variables
.C:0b2c  A6 D8       LDX actor
.C:0b2e  AD E6 FD    LDA x_destination
.C:0b31  8D 6D FF    STA var_destination_x
.C:0b34  AD E7 FD    LDA y_destination
.C:0b37  8D 6E FF    STA var_destination_y
;Check if kid is frozen (when captured by an enemy)
;If so, we can't move, exit
.C:0b3a  AE 67 FF    LDX current_kid
.C:0b3d  BD E3 FE    LDA actor_vars,X
.C:0b40  29 40       AND ACTOR_IS_FROZEN
.C:0b42  D0 11       BNE exit
;Copy the destination coordinates to the actor's destination coords
.C:0b44  A6 D8       LDX actor
.C:0b46  AD E6 FD    LDA x_destination
.C:0b49  9D D9 FD    STA destination_x_for_actor,X
.C:0b4c  AD E7 FD    LDA y_destination
.C:0b4f  9D DD FD    STA destination_y_for_actor,X
;Build a path to the destination
.C:0b52  20 4A 1C    JSR build_path_to_destination
exit:
.C:0b55  60          RTS
;----------------------------------------------
queue_sentence:
.C:0b56  EE 17 FE    INC sentence_queue_index
.C:0b59  AE 17 FE    LDX sentence_queue_index
;Save each of the sentence parts into the queue
.C:0b5c  AD 1F FE    LDA current_verb
.C:0b5f  9D 25 FE    STA queued_sentence_verbs,X
.C:0b62  AD 20 FE    LDA direct_object_idx_lo
.C:0b65  9D 2B FE    STA queued_sentence_direct_objects_lo,X
.C:0b68  AD 21 FE    LDA direct_object_idx_hi
.C:0b6b  9D 31 FE    STA queued_sentence_direct_objects_hi,X
.C:0b6e  AD 22 FE    LDA preposition
.C:0b71  9D 37 FE    STA queued_sentence_prepositions,X
.C:0b74  AD 23 FE    LDA indirect_object_idx_lo
.C:0b77  9D 3D FE    STA queued_sentence_indirect_objects_lo,X
.C:0b7a  AD 24 FE    LDA indirect_object_idx_hi
.C:0b7d  9D 43 FE    STA queued_sentence_indirect_objects_hi,X
;Reset sentence parts after queuing
;If verb is "Walk to", we don't need to reset anything already, just exit
.C:0b80  AD 1F FE    LDA current_verb
.C:0b83  C9 0D       CMP WALK_TO_VERB
.C:0b85  F0 0F       BEQ exit
;Reset verb to "walk to", clear direct object and preposition
.C:0b87  A9 0D       LDA WALK_TO_VERB
.C:0b89  8D 1F FE    STA current_verb
.C:0b8c  A9 00       LDA #$00
.C:0b8e  8D 20 FE    STA direct_object_idx_lo
.C:0b91  A9 00       LDA #$00
.C:0b93  8D 22 FE    STA preposition
exit:
;Clear destination entity
.C:0b96  A9 00       LDA #$00
.C:0b98  8D 51 FE    STA destination_entity
.C:0b9b  60          RTS
;===========================================
; Handles the sentence queue
;
; This routine will:
;	-check if there's a preposition set (which means an indirect object)
;	-if there isn't, it will continue with the "active parts" section
;	-if there is one, it will check whether the complements are identical
;		-if they are, it will ignore the sentence and exit
;	-check if the complements are in the inventory
;
;	-if one of the complements is not in the inventory, it will try to pick it up
;		-but first, it will check if there's a script for "pick up" for that object
;		-if so, it will execute "pick up" on that object and exit
;		-if not, it will exit
;
;	Active parts section:
;	-if the direct object is not in the inventory, it will walk to it and exit
;	-if it is in the inventory and no indirect object is needed, then it will execute the verb handler
;	-if there's a preposition (and thus a direct object), then
;	-if the indirect object is not in the inventory, it will walk to it and exit
;	-if it is in the inventory, then all parts are present, it will continue with the verb handler
;	
;===========================================
destination_entity = $fe51

handle_sentence_queue:
;Is there a destination entity?
;If it's #00, Z will be set, BEQ will be taken
.C:0b9c  AD 51 FE    LDA destination_entity
.C:0b9f  F0 01       BEQ check_sentence_queue_index
;Destination entity set, exit
.C:0ba1  60          RTS
check_sentence_queue_index:
;Do we have a valid queue index? If not, exit
.C:0ba2  AE 17 FE    LDX sentence_queue_index
.C:0ba5  10 01       BPL check_if_complements_are_identical
.C:0ba7  60          RTS
check_if_complements_are_identical:
;If there's no preposition set, continue, as there's only one complement
.C:0ba8  BD 37 FE    LDA queued_sentence_prepositions,X
.C:0bab  F0 50       BEQ set_active_sentence_parts
;Is there a direct object set? If not, check complements
.C:0bad  BD 2B FE    LDA queued_sentence_direct_objects_lo,X
.C:0bb0  F0 11       BEQ check_complements_in_inventory
;Is the low byte identical to the indirect object low byte?
;If not, check complements
.C:0bb2  DD 3D FE    CMP queued_sentence_indirect_objects_lo,X
.C:0bb5  D0 0C       BNE check_complements_in_inventory
;It's identical - compare the hi bytes now
.C:0bb7  BD 31 FE    LDA queued_sentence_direct_objects_hi,X
.C:0bba  DD 43 FE    CMP queued_sentence_indirect_objects_hi,X
;If they are not identical, check complements
.C:0bbd  D0 04       BNE check_complements_in_inventory
;The direct and indirect objects are identical, move index to the next sentence and exit
.C:0bbf  CE 17 FE    DEC sentence_queue_index
.C:0bc2  60          RTS
;--------------------------------------------------
;Check if the complements are in the inventory
;--------------------------------------------------
check_complements_in_inventory:
;Check if direct object is in inventory
.C:0bc3  A9 01       LDA #$01
.C:0bc5  20 AE 0E    JSR is_obj_in_current_kid_inventory
;Returns #01 if it's in the inventory, #00 if not
;If object in inventory, set the active sentence parts
.C:0bc8  C9 00       CMP #$00
.C:0bca  D0 31       BNE set_active_sentence_parts
;Check if indirect object is in inventory
.C:0bcc  A9 02       LDA #$02
.C:0bce  20 AE 0E    JSR is_obj_in_current_kid_inventory
;Returns #01 if it's in the inventory, #00 if not
;If object in inventory, set the active sentence parts
.C:0bd1  C9 00       CMP #$00
.C:0bd3  D0 28       BNE set_active_sentence_parts
;--------------------------------------------------
check_direct_obj_pickup_script:
;Does the direct object have a pick up script?
.C:0bd5  A9 01       LDA #$01
.C:0bd7  20 73 0E    JSR has_object_a_pickup_script
;Returns #01 if it does, #00 if it doesn't
.C:0bda  C9 01       CMP #$01
.C:0bdc  D0 09       BNE check_indirect_obj_pickup_script
;It does - run "pick up" on the object and exit
;As we don't modify the sentence index, it will be re-executed later
.C:0bde  A9 01       LDA #$01
.C:0be0  20 E1 0E    JSR run_pickup_on_sentence_complement
.C:0be3  60          RTS
;--------------------------------------------------
;.C:0be4  4C FD 0B    JMP set_active_sentence_parts	;Unreachable code
check_indirect_obj_pickup_script:
;Does the indirect object have a pick up script?
.C:0be7  A9 02       LDA #$02
.C:0be9  20 73 0E    JSR has_object_a_pickup_script
;Returns #01 if it does, #00 if it doesn't
.C:0bec  C9 01       CMP #$01
.C:0bee  D0 09       BNE no_custom_pickup_scripts
;It does - run "pick up" on the object and exit
;As we don't modify the sentence index, it will be re-executed later
.C:0bf0  A9 02       LDA #$02
.C:0bf2  20 E1 0E    JSR run_pickup_on_sentence_complement
.C:0bf5  60          RTS
;.C:0bf6  4C FD 0B    JMP set_active_sentence_parts	;Unreachable code
;--------------------------------------------------
no_custom_pickup_scripts:
;Nothing left to do, move the sentence index and exit
.C:0bf9  CE 17 FE    DEC sentence_queue_index
.C:0bfc  60          RTS
;--------------------------------------------------
set_active_sentence_parts:
;Copy all the sentence parts for the current sentence into the "active_" variables
.C:0bfd  AC 17 FE    LDY sentence_queue_index
.C:0c00  B9 25 FE    LDA queued_sentence_verbs,Y
.C:0c03  8D 19 FE    STA active_verb
.C:0c06  B9 2B FE    LDA queued_sentence_direct_objects_lo,Y
.C:0c09  8D 1A FE    STA active_object_lo
.C:0c0c  B9 31 FE    LDA queued_sentence_direct_objects_hi,Y
.C:0c0f  8D 1B FE    STA active_object_hi
.C:0c12  B9 37 FE    LDA queued_sentence_prepositions,Y
.C:0c15  8D 1C FE    STA active_preposition
.C:0c18  B9 3D FE    LDA queued_sentence_indirect_objects_lo,Y
.C:0c1b  8D 1D FE    STA active_indirect_object
.C:0c1e  B9 43 FE    LDA queued_sentence_indirect_objects_hi,Y
.C:0c21  8D 1E FE    STA active_indirect_object_hi
;--------------------------------------------------
;Move the sentence index and the free capacity
.C:0c24  CE 17 FE    DEC sentence_queue_index
.C:0c27  CE 18 FE    DEC sentence_queue_free_capacity
;Is the capacity exhausted?
.C:0c2a  10 0B       BPL available_queue_capacity
;Capacity exhausted - reset queue and exit
.C:0c2c  A9 FF       LDA #$FF
.C:0c2e  8D 17 FE    STA sentence_queue_index
.C:0c31  A9 06       LDA #$06
.C:0c33  8D 18 FE    STA sentence_queue_free_capacity
.C:0c36  60          RTS
;--------------------------------------------------
available_queue_capacity:
;Check if the active direct object is in the inventory
.C:0c37  AE 1A FE    LDX active_object_lo
.C:0c3a  AD 1B FE    LDA active_object_hi
.C:0c3d  20 FE 09    JSR get_obj_if_not_a_character
;Returns #00 if object in inventory, nonzero otherwise
;If it's not in the inventory, check if we can walk to it
.C:0c40  D0 4E       BNE check_walk_to_direct_object
;The direct object is in the inventory
;Do we have a preposition? If not, try to handle the sentence
.C:0c42  AD 1C FE    LDA active_preposition
.C:0c45  F0 43       BEQ do_verb_handler
;We have a preposition
;Check if the active indirect object is in the inventory
.C:0c47  AE 1D FE    LDX active_indirect_object
.C:0c4a  AD 1E FE    LDA active_indirect_object_hi
.C:0c4d  20 FE 09    JSR get_obj_if_not_a_character
;Returns #00 if object in inventory, nonzero otherwise
;If it's not in the inventory, check if we can walk to it
.C:0c50  D0 06       BNE walk_to_indirect_object
;We have direct object, preposition and indirect object, try to handle the sentence
.C:0c52  4C C5 0D    JMP execute_verb_handler_for_object
;.C:0c55  4C CF 0C    JMP exit	;Unreachable code
;--------------------------------------------------
walk_to_indirect_object:
;Set the active indirect object as the destination object
.C:0c58  AE 1D FE    LDX active_indirect_object
.C:0c5b  AD 1E FE    LDA active_indirect_object_hi
.C:0c5e  8E 4F FE    STX destination_obj_lo
.C:0c61  8D 50 FE    STA destination_obj_hi
;Set the destination for approaching the indirect object
.C:0c64  20 32 0F    JSR set_destination_for_entity
;Copy the sentence index (still in .Y) to the destination entity 
.C:0c67  8C 51 FE    STY destination_entity
;--------------------------------------------------
;Set debugging vars
.C:0c6a  AD E6 FD    LDA x_destination
.C:0c6d  8D 6D FF    STA var_destination_x
.C:0c70  AD E7 FD    LDA y_destination
.C:0c73  8D 6E FF    STA var_destination_y
.C:0c76  AD 67 FF    LDA current_kid
.C:0c79  8D 30 FC    STA active_costume
.C:0c7c  AA          TAX
;--------------------------------------------------
;Check if kid is frozen
;If so, exit
.C:0c7d  BD E3 FE    LDA actor_vars,X
.C:0c80  29 40       AND ACTOR_IS_FROZEN
.C:0c82  D0 03       BNE exit_2
;Otherwise, walk actor to destination
.C:0c84  20 1F 1C    JSR walk_actor_to_destination
exit_2:
.C:0c87  4C CF 0C    JMP exit
;--------------------------------------------------
;Execute the verb handler for this object
do_verb_handler:
.C:0c8a  4C C5 0D    JMP execute_verb_handler_for_object
;.C:0c8d  4C CF 0C    JMP exit	;Unreachable
;--------------------------------------------------
check_walk_to_direct_object:
;Are we in keypad control mode? If so, execute the verb handler directly as there's no walking
.C:0c90  AD A8 FE    LDA control_mode
.C:0c93  C9 01       CMP KEYPAD_CONTROL_MODE
;If not, try to walk to the direct object
.C:0c95  D0 09       BNE walk_to_direct_object
;--------------------------------------------------
; Keypad control mode (#01)
;--------------------------------------------------
.C:0c97  20 C5 0D    JSR execute_verb_handler_for_object
;In keypad mode we don't queue sentences, so clear the destination entity
.C:0c9a  A9 00       LDA #$00
.C:0c9c  8D 51 FE    STA destination_entity
.C:0c9f  60          RTS
;--------------------------------------------------
; All other control modes
;--------------------------------------------------
walk_to_direct_object:
;Set the active direct object as the destination object
.C:0ca0  AE 1A FE    LDX active_object_lo
.C:0ca3  AD 1B FE    LDA active_object_hi
.C:0ca6  8E 4F FE    STX destination_obj_lo
.C:0ca9  8D 50 FE    STA destination_obj_hi
;Set the destination for approaching the direct object
.C:0cac  20 32 0F    JSR set_destination_for_entity
;Copy the sentence index (still in .Y) to the destination entity 
.C:0caf  8C 51 FE    STY destination_entity
;--------------------------------------------------
;Set debugging variables
.C:0cb2  AD E6 FD    LDA x_destination
.C:0cb5  8D 6D FF    STA var_destination_x
.C:0cb8  AD E7 FD    LDA y_destination
.C:0cbb  8D 6E FF    STA var_destination_y
;--------------------------------------------------
;Check if current kid is frozen
;If so, exit
.C:0cbe  AD 67 FF    LDA current_kid
.C:0cc1  8D 30 FC    STA active_costume
.C:0cc4  AA          TAX
.C:0cc5  BD E3 FE    LDA actor_vars,X
.C:0cc8  29 40       AND ACTOR_IS_FROZEN
.C:0cca  D0 03       BNE exit
;Otherwise, walk actor to destination
.C:0ccc  20 1F 1C    JSR walk_actor_to_destination
exit:
.C:0ccf  60          RTS
;===========================================
; Walks towards a destination entity and triggers a queued action upon contact
;===========================================
destination_obj_lo = $fe4f
destination_obj_hi = $fe50
destination_entity = $fe51

trigger_action_on_entity_contact:
;Is there a destination entity? If not, exit
.C:0cd0  AD 51 FE    LDA destination_entity
.C:0cd3  D0 03       BNE entry
.C:0cd5  4C 48 0D    JMP exit
;-------------------------------------------------------
entry:
;Get the actor for the current kid
.C:0cd8  AE 67 FF    LDX current_kid
.C:0cdb  BD 57 FE    LDA actor_for_costume,X
.C:0cde  AA          TAX
;Is the actor stopped? If not, exit
.C:0cdf  BD 68 FD    LDA motion_state_for_actor,X
.C:0ce2  C9 02       CMP #$02
.C:0ce4  D0 62       BNE exit
;Have we made contact with the entity? (#FE)
.C:0ce6  AD 51 FE    LDA destination_entity
.C:0ce9  C9 FE       CMP #$FE
.C:0ceb  D0 08       BNE $0CF5
;We made contact
;Clear the entity
.C:0ced  A9 00       LDA #$00
.C:0cef  8D 51 FE    STA destination_entity
;Execute the queued action for this object
.C:0cf2  4C C5 0D    JMP execute_verb_handler_for_object
;-------------------------------------------------------
approach_entity:
;We haven't made contact yet, keep moving towards entity
.C:0cf5  AE 4F FE    LDX destination_obj_lo
.C:0cf8  AD 50 FE    LDA destination_obj_hi
.C:0cfb  AC 51 FE    LDY destination_entity
.C:0cfe  20 32 0F    JSR set_destination_for_entity
;Get the actor for the current kid
.C:0d01  AE 67 FF    LDX current_kid
.C:0d04  BD 57 FE    LDA actor_for_costume,X
.C:0d07  AA          TAX
check_delta_x:
;Compute the difference between the actor's position and destination in the X axis
.C:0d08  AD E6 FD    LDA x_destination
.C:0d0b  38          SEC
.C:0d0c  FD 41 FD    SBC position_x_for_actor,X
.C:0d0f  B0 05       BCS check_x_threshold
;If negative, make positive
.C:0d11  49 FF       EOR #$FF
.C:0d13  18          CLC
.C:0d14  69 01       ADC #$01
check_x_threshold:
;Did we hit the exact threshold? (#04)? If so, check the other axis
.C:0d16  C9 04       CMP #$04
.C:0d18  F0 02       BEQ check_delta_y
;If we're too far away, clear the entity flag for the time being and exit
.C:0d1a  B0 27       BCS clear_flag
;If we're closer than the threshold, check the other axis
check_delta_y:
;Compute the difference between the actor's position and destination in the Y axis
.C:0d1c  AD E7 FD    LDA y_destination
.C:0d1f  38          SEC
.C:0d20  FD 3D FD    SBC position_y_for_actor,X
.C:0d23  B0 05       BCS check_y_threshold
;If negative, make positive
.C:0d25  49 FF       EOR #$FF
.C:0d27  18          CLC
.C:0d28  69 01       ADC #$01
check_y_threshold:
;Did we hit the exact threshold? (#08)? If so, setup the animation set facing the entity
.C:0d2a  C9 08       CMP #$08
.C:0d2c  F0 02       BEQ walk_to_destination
;If we're too far away, clear the entity flag for the time being and exit
.C:0d2e  B0 0B       BCS clear_flag_2
;If we're closer than the threshold, setup the animation set facing the entity
walk_to_destination:
;Setup the animation set facing the entity
.C:0d30  20 49 0D    JSR setup_animation_facing_destination
;We have made contact with the entity, mark that situation to trigger any queued action (#FE)
.C:0d33  A9 FE       LDA #$FE
.C:0d35  8D 51 FE    STA destination_entity
.C:0d38  4C 48 0D    JMP exit
clear_flag_2:
.C:0d3b  A9 00       LDA #$00
.C:0d3d  8D 51 FE    STA destination_entity
.C:0d40  4C 48 0D    JMP exit
clear_flag:
.C:0d43  A9 00       LDA #$00
.C:0d45  8D 51 FE    STA destination_entity
exit:
.C:0d48  60          RTS
;===========================================
; Set up the "walking to destination" animation.
;
; If the destination is another actor, make the standing actor
; face towards the walking actor.
;===========================================
destination_obj_hi = $fe50
destination_obj_lo = $fe4f
walking_actor_animation_set = $0fc8

setup_animation_facing_destination:
;Get the animation set for the destination object (facing the correct side)
.C:0d49  20 82 0D    JSR get_animation_set_for_destination_object
.C:0d4c  8D C8 0F    STA walking_actor_animation_set
.C:0d4f  8D E9 FD    STA desired_animation_set
;Set animation argument to #00 (don't loop)
.C:0d52  A9 00       LDA #$00
.C:0d54  8D E8 FD    STA animation_argument
;Set the costume in action
.C:0d57  AD 67 FF    LDA current_kid
.C:0d5a  8D 30 FC    STA active_costume
;Setup the animation set
.C:0d5d  20 20 27    JSR apply_animation_set
;Is the destination object an actor? If not, exit
.C:0d60  AD 50 FE    LDA destination_obj_hi
.C:0d63  C9 02       CMP #$02
.C:0d65  D0 1A       BNE exit
;Destination is an actor
;Set the destination actor to the costume in action
.C:0d67  AD 4F FE    LDA destination_obj_lo
.C:0d6a  8D 30 FC    STA active_costume
;Is it the plant? If so, exit
.C:0d6d  C9 13       CMP #$13
.C:0d6f  F0 10       BEQ exit
;Mirror whatever direction the other actor is doing
;If the actor walking is facing left, then make this standing actor face right (and viceversa)
;Flip the animation mode by flipping bit 1
.C:0d71  AD C8 0F    LDA walking_actor_animation_set
.C:0d74  49 01       EOR #$01
.C:0d76  8D E9 FD    STA desired_animation_set
;Set animation argument to #00 (don't loop)
.C:0d79  A9 00       LDA #$00
.C:0d7b  8D E8 FD    STA animation_argument
;Setup the animation set for this other actor
.C:0d7e  20 20 27    JSR apply_animation_set
exit:
.C:0d81  60          RTS
;===========================================
; Get the animation direction for a destination object
;
; Arguments:	destination_obj
; Returns:		.A		the animation_set value
;
; Returns the animation set that matches the direction
; the current kid needs to face before walking towards the destination.
;
; In other words, if the destination is an actor, and the actor is to the right,
; the kid will start with the "looking right" animation.
;
; If the destination is an object, the destination will be forced to "looking down/south",
; unless the object has an explicit animation set.
;===========================================
destination_obj_hi = $fe50
destination_obj_lo = $fe4f

get_animation_set_for_destination_object:
.C:0d82  AD 50 FE    LDA destination_obj_hi
.C:0d85  C9 02       CMP #$02
.C:0d87  D0 28       BNE is_not_a_character
;-------------------------------------------
object_is_a_character:
;Get character's X position
.C:0d89  AE 4F FE    LDX destination_obj_lo
.C:0d8c  BD 57 FE    LDA actor_for_costume,X
.C:0d8f  AA          TAX
.C:0d90  BD 41 FD    LDA position_x_for_actor,X
;Save it as X destination
.C:0d93  8D E6 FD    STA x_destination
;Get current kid's X position
.C:0d96  AE 67 FF    LDX current_kid
.C:0d99  BD 57 FE    LDA actor_for_costume,X
.C:0d9c  AA          TAX
.C:0d9d  BD 41 FD    LDA position_x_for_actor,X
;Compare X position with X destination
.C:0da0  CD E6 FD    CMP x_destination
.C:0da3  90 07       BCC return_animation_to_the_right
.C:0da5  F0 05       BEQ return_animation_to_the_right
;-------------------------------------------
;X position > X destination
;Return animation for "Standing left" (#04)
.C:0da7  A9 04       LDA #$04
.C:0da9  4C C4 0D    JMP exit
;-------------------------------------------
return_animation_to_the_right:
;X position <= X destination
;Return animation for "Standing right" (#05)
.C:0dac  A9 05       LDA #$05
.C:0dae  4C C4 0D    JMP exit
;-------------------------------------------
object_is_not_a_character:
;Get the destination object index
.C:0db1  AC 51 FE    LDY destination_entity
.C:0db4  C0 FF       CPY #$FF
.C:0db6  F0 0A       BEQ return_06
;Is there an explicit destination active for this object?
.C:0db8  B9 05 72    LDA object_destination_active,Y
;If so, return that value
.C:0dbb  D0 02       BNE exit_2
;Otherwise, return animation for "Standing looking down" (#06)
.C:0dbd  A9 06       LDA #$06
exit_2:
.C:0dbf  4C C4 0D    JMP exit
;-------------------------------------------
return_animation_down:
;Return animation for "Standing looking down" (#06)
.C:0dc2  A9 06       LDA #$06
exit:
.C:0dc4  60          RTS
;===========================================
; Execute the correct verb handler for an object
;
; If there's a custom handler defined for the combination of verb/object, execute it. 
; Otherwise, execute the default verb handlers accordingly.
;===========================================
object_offset_in_room_rsrc = $17

execute_verb_handler_for_object:
;Mark sentence bar for refreshing
.C:0dc5  A9 01       LDA #$01
.C:0dc7  8D 49 FE    STA refresh_sentence_bar_flag
;Get the active object's resource
.C:0dca  AE 1A FE    LDX active_object_lo
.C:0dcd  AD 1B FE    LDA active_object_hi
.C:0dd0  20 05 0A    JSR get_obj_resource
.C:0dd3  8C 29 71    STY resource_index_for_script_slot
.C:0dd6  8D 19 71    STA script_type_for_script_slot
;Get the object's script handler for the verb, if any
.C:0dd9  AD 19 FE    LDA active_verb
.C:0ddc  20 4A 0E    JSR get_obj_script_ptr_for_verb
;Did we find a handler?
.C:0ddf  D0 35       BNE check_read_verb
;We didn't - run the default handlers
.C:0de1  AD 19 FE    LDA active_verb
.C:0de4  C9 03       CMP GIVE_VERB
.C:0de6  D0 19       BNE check_walk_verb
;---------------------------------------
; "Give" verb processing
;---------------------------------------
;Is the recipient object index >= 8? (That is, not a kid)
.C:0de8  AD 1D FE    LDA active_indirect_object
.C:0deb  C9 08       CMP #$08
;If so, exit
.C:0ded  B0 11       BCS exit
;---------------------------------------
;Get the active object
.C:0def  AE 1A FE    LDX active_object_lo
;Get its attributes, replace the owner with the new one
.C:0df2  BD 01 73    LDA object_attributes,X
.C:0df5  29 F0       AND #$F0
.C:0df7  0D 1D FE    ORA active_indirect_object
.C:0dfa  9D 01 73    STA object_attributes,X
;Refresh inventory
.C:0dfd  20 2B 5F    JSR refresh_items_displayed
exit:
.C:0e00  60          RTS
;---------------------------------------
check_walk_verb:
;If verb is "walk to", exit
.C:0e01  C9 0D       CMP WALK_TO_VERB
.C:0e03  F0 10       BEQ exit_2
run_verb_defaults_script:
;Copy verb to debugging variable
.C:0e05  AD 19 FE    LDA active_verb
.C:0e08  8D 70 FF    STA var_active_verb
;Set that no script is being executed
.C:0e0b  A9 FF       LDA #$FF
.C:0e0d  8D B8 70    STA current_script_slot
;Execute global script #3 (verb defaults)
.C:0e10  A9 03       LDA #$03
.C:0e12  20 8A 5E    JSR start_global_script
exit_2:
.C:0e15  60          RTS
;---------------------------------------
check_read_verb:
;Save verb index in stack, as we might need to use .A to check lights_status later
.C:0e16  48          PHA
;Check if the verb is "read"
.C:0e17  AD 19 FE    LDA active_verb
.C:0e1a  C9 0C       CMP READ_VERB
.C:0e1c  D0 09       BNE run_handler
;---------------------------------------
; "Read" verb handling - make sure there's a source of light
;---------------------------------------
.C:0e1e  AD AB FE    LDA lights_status
.C:0e21  D0 04       BNE run_handler
;---------------------------------------
;Lights status is #00 (Total darkness)
.C:0e23  68          PLA
;We can't run the custom handler - run the verb defaults script
.C:0e24  4C 05 0E    JMP run_verb_defaults_script
;---------------------------------------
run_handler:
;Pull verb index from stack
.C:0e27  68          PLA
;Add verb index to object_offset_in_room_rsrc, set result to script_offsets[0]
.C:0e28  18          CLC
.C:0e29  65 17       ADC <object_offset_in_room_rsrc
.C:0e2b  8D C9 70    STA script_offsets_lo
.C:0e2e  A9 00       LDA #$00
.C:0e30  65 18       ADC >object_offset_in_room_rsrc
.C:0e32  8D B9 70    STA script_offsets_hi
;---------------------------------------
;Set current script slot to #00
.C:0e35  A9 00       LDA #$00
.C:0e37  8D B8 70    STA current_script_slot
;Copy debugging variable
.C:0e3a  AD 1D FE    LDA active_indirect_object
.C:0e3d  8D 6C FF    STA var_active_indirect_object
;Set up script execution and launch it
.C:0e40  20 20 5E    JSR set_script_resource_base_address
.C:0e43  20 E3 5D    JSR set_current_script_read_address
.C:0e46  20 97 5D    JSR execute_next_operation
.C:0e49  60          RTS
;===========================================
; Get an object's script offset for a given verb
;
; Arguments:	.A		verb index
; Returns:		.A		
;				#00 	if no script exists for the verb and the verb is not "Walk to"
;				#0D		if no script exists for the verb and the verb is "Walk to"
;				offset	if there's a script for the verb.
;						The offset refers to the verb script in the object resource.
;
; Verb handlers start in an object's resource from offset #0E.
; Each verb handler takes 2 bytes.
; The first byte represents the verb index.
; The second byte represents an offset within the object resource.
; The offset refers to the start of the script for the verb handler.
;
; For instance, a verb handler having bytes of 0A 43 would represent
; the verb handler for "Pull" (#0A) and an offset of 0x43 bytes from the object's resource start.
;
; Verb handlers are stored consecutively. 
; A value of #00 for the verb index is used to represent the end of the handlers list.
;
; A verb handler with a verb index of #0F is used as the default handler for all verbs.
; If found, it's considered a match for any verb.
;
; If there is no handler that matches the verb, #00 is returned.
; An exception is the "walk to" verb. If no handler matches it, #0D is returned.
;===========================================
verb_index = $0e6f
object_rsrc_ptr = $15

get_obj_script_ptr_for_verb:
.C:0e4a  8D 6F 0E    STA verb_index
;Use .Y as offset from the object's resource start
.C:0e4d  A0 0C       LDY #$0C
check_next_handler:
;Move .Y offset 
.C:0e4f  C8          INY
.C:0e50  C8          INY
;Read data from the object resource
.C:0e51  B1 15       LDA (object_rsrc_ptr),Y
;Have we reached the end of the verb script offsets? (#00)
.C:0e53  D0 0A       BNE check_default
;------------------------------------
;We reached the end
;Return #0D if the verb is #0D, otherwise return #00
.C:0e55  AD 6F 0E    LDA verb_index
.C:0e58  C9 0D       CMP #$0D
.C:0e5a  F0 02       BEQ exit
.C:0e5c  A9 00       LDA #$00
exit:
.C:0e5e  60          RTS
;------------------------------------
check_default:
;Is this a default script? (#0F - which is the first index that doesn't correspond to a verb)
.C:0e5f  C9 0F       CMP #$0F
;If not, check against verb_index
.C:0e61  D0 03       BNE check_verb_match
;It's the default, so return the next byte as the script offset
.C:0e63  4C 6B 0E    JMP return_next_byte
;------------------------------------
check_verb_match:
;It's not a default verb handler
;Does the verb handler match the desired verb?
.C:0e66  CD 6F 0E    CMP verb_index
;If not, continue with the next handler
;Otherwise, return the next byte as the desired offset
.C:0e69  D0 E4       BNE check_next_handler
return_next_byte:
;Return the next byte as the desired script offset
.C:0e6b  C8          INY
.C:0e6c  B1 15       LDA (object_rsrc_ptr),Y
.C:0e6e  60          RTS
;===========================================
; Returns whether an object has a custom "pick up" script or not
;
; Arguments:	.A	#01 if it's direct object, anything else if indirect object
; Returns:	.A 	#00	if it doesn't
;				#01	if it does
;===========================================
temp_x = $0e70
temp_y = $0e71
has_object_a_pickup_script:
;Save .X and .Y in stack
.C:0e73  8E 70 0E    STX temp_x
.C:0e76  8C 71 0E    STY temp_y
;Load sentence queue index into .Y
.C:0e79  AC 17 FE    LDY sentence_queue_index
;Check argument in .A - direct or indirect object?
.C:0e7c  C9 01       CMP #$01
.C:0e7e  D0 09       BNE part_is_indirect_object
;#01 - direct object
;Load the object index
.C:0e80  BE 2B FE    LDX queued_sentence_direct_objects_lo,Y		
.C:0e83  B9 31 FE    LDA queued_sentence_direct_objects_hi,Y				
.C:0e86  4C 8F 0E    JMP is_object_givable
part_is_indirect_object:
;#02 - indirect object - load the object index
.C:0e89  BE 3D FE    LDX queued_sentence_indirect_objects_lo,Y		
.C:0e8c  B9 43 FE    LDA queued_sentence_indirect_objects_hi,Y				
check_if_recipient:
;Can the object be a recipient of another object?
;That is, is the hi part of the index #02?
.C:0e8f  C9 02       CMP #$02
.C:0e91  D0 03       BNE can_be_recipient
;It isn't, return #00
.C:0e93  A9 00       LDA #$00
.C:0e95  60          RTS
can_be_recipient:
;It might - see if we can get a script handling the "Pick Up" verb
.C:0e96  20 05 0A    JSR get_obj_resource
.C:0e99  A9 0E       LDA PICK_UP_VERB
.C:0e9b  20 4A 0E    JSR get_obj_script_ptr_for_verb
;Is there any script?
.C:0e9e  D0 05       BNE return_01
;There isn't, return #00
.C:0ea0  A9 00       LDA #$00
.C:0ea2  4C A7 0E    JMP exit
return_01:
;There is, return #01
.C:0ea5  A9 01       LDA #$01
exit:
;Restore .X and .Y from stack
.C:0ea7  AE 70 0E    LDX temp_x
.C:0eaa  AC 71 0E    LDY temp_y
.C:0ead  60          RTS
;===========================================
; Checks if the sentence complement (direct or indirect object)
; is in the _current_ kid's inventory
;
; Arguments:	.A	#01					direct object
;					anything else		indirect object
; Returns: 	.A	#01 if it is
;				#00 otherwise
;===========================================
temp = $0e70
is_obj_in_current_kid_inventory:
.C:0eae  8E 70 0E    STX temp_x
;Fetch index of current sentence part being analyzed
.C:0eb1  AE 17 FE    LDX sentence_queue_index
;Are we checking for a direct object?
.C:0eb4  C9 01       CMP #$01
.C:0eb6  D0 09       BNE fetch_indirect_object
;It's the direct object
.C:0eb8  BC 2B FE    LDY queued_sentence_direct_objects_lo,X
.C:0ebb  BD 31 FE    LDA queued_sentence_direct_objects_hi,X
.C:0ebe  4C C7 0E    JMP check_item_state
;It's not, so it must be the indirect object
fetch_indirect_object:
.C:0ec1  BC 3D FE    LDY queued_sentence_indirect_objects_lo,X
.C:0ec4  BD 43 FE    LDA queued_sentence_indirect_objects_hi,X
check_object_state: 
;The object's hi byte represents if it's in _somebody's_ inventory or not (#00 == in inventory)
.C:0ec7  F0 03       BEQ check_in_current_kid_inventory
;Not in anyone's inventory, return #00
.C:0ec9  A9 00       LDA #$00
.C:0ecb  60          RTS
check_in_current_kid_inventory:
;Check if the item is in the _current_ kid's inventory
.C:0ecc  B9 01 73    LDA object_attributes,Y
;Low nibble of the object attributes represents which kid is the owner
.C:0ecf  29 0F       AND #$0F
.C:0ed1  CD 67 FF    CMP current_kid
.C:0ed4  D0 05       BNE not_in_current_kid_inventory
;It is in current kid's inventory - return #01
.C:0ed6  A9 01       LDA #$01
.C:0ed8  4C DD 0E    JMP exit
not_in_current_kid_inventory:
;Not in current kid's inventory - return #00
.C:0edb  A9 00       LDA #$00
exit:
.C:0edd  AE 70 0E    LDX temp_x
.C:0ee0  60          RTS
;===========================================
; Queue "pick up" on sentence complement
;
; Queues a new sentence doing "pick up" on the current sentence 
; complement (direct or indirect object).
;
; Arguments:	.A		#01	direct object
;						#02	indirect object
;===========================================
object_ptr = $15
temp = $0e70
run_pickup_on_sentence_complement:
.C:0ee1  8E 70 0E    STX temp
;Fetch index of current sentence part being analyzed
.C:0ee4  AE 17 FE    LDX sentence_queue_index
;Is it part #02 (Indirect object)?
.C:0ee7  C9 02       CMP #$02
.C:0ee9  D0 0D       BNE fetch_direct_object
;It's the indirect object - store data into $15/16
.C:0eeb  BD 3D FE    LDA queued_sentence_indirect_objects_lo,X
.C:0eee  85 15       STA <object_ptr
.C:0ef0  BD 43 FE    LDA queued_sentence_indirect_objects_hi,X
.C:0ef3  85 16       STA >object_ptr
.C:0ef5  4C 02 0F    JMP next_sentence_index
fetch_direct_object:
;It's not, so it must be the direct object  - store data into $15/16
.C:0ef8  BD 2B FE    LDA queued_sentence_direct_objects_lo,X
.C:0efb  85 15       STA <object_ptr
.C:0efd  BD 31 FE    LDA queued_sentence_direct_objects_hi,X
.C:0f00  85 16       STA >object_ptr
next_sentence_index:
;Increment sentence index
.C:0f02  EE 17 FE    INC sentence_queue_index
;Are we still using a valid sentence part index?
.C:0f05  AE 17 FE    LDX sentence_queue_index
.C:0f08  E0 06       CPX #$06
.C:0f0a  D0 0E       BNE queue_pickup
;---------------------------------------------
;Invalid sentence part index - hang execution
;---------------------------------------------
.C:0f0c  A9 2D       LDA #$2D
.C:0f0e  85 DC       STA $DC
;map_in_io
.C:0f10  A0 25       LDY #$25
.C:0f12  84 01       STY processor_port_register
hangup_loop:
.C:0f14  8D 20 D0    STA vic_border_color_register
.C:0f17  4C 14 0F    JMP hangup_loop
;---------------------------------------------
queue_pickup:
;Queue the "pick up" sentence for the object
.C:0f1a  A9 0E       LDA PICK_UP_VERB
.C:0f1c  9D 25 FE    STA queued_sentence_verbs,X
.C:0f1f  A9 00       LDA #$00
.C:0f21  9D 37 FE    STA queued_sentence_prepositions,X
.C:0f24  A5 15       LDA <object_ptr
.C:0f26  9D 2B FE    STA queued_sentence_direct_objects_lo,X
.C:0f29  A5 16       LDA >object_ptr
.C:0f2b  9D 31 FE    STA queued_sentence_direct_objects_hi,X
.C:0f2e  AE 70 0E    LDX temp
.C:0f31  60          RTS
;===========================================
; Base routine for setting the destination towards an entity
;
; Arguments:	.A	destination entity type (#02 == actor, otherwise an object)
;				.X	if entity type is actor, destination costume
;					if entity type is object, costume being moved
;				.Y	if entity type is actor, costume being moved
;					if entity type is object, destination object index
;
; This routine will delegate the logic depending on whether
; the destination entity is an object or an actor.
;===========================================
temp_y = $0fc9
set_destination_for_entity:
.C:0f32  8C C9 0F    STY temp_y
;Is the entity type an object or an actor?
.C:0f35  C9 02       CMP #$02
.C:0f37  D0 3C       BNE set_destination_for_object
;-------------------
; Actor
;-------------------
;Set position offsets (used when approaching an actor, check the routine below)
.C:0f39  A9 04       LDA #$04
.C:0f3b  8D 65 0F    STA inlined_positive_destination_offset
.C:0f3e  A9 FC       LDA #$FC
.C:0f40  8D 6A 0F    STA inlined_negative_destination_offset
.C:0f43  AC 67 FF    LDY current_kid
;Fall through
;===========================================
; Set destination for actor:
;
; When walking towards another actor, we don't want them to be at _exactly_ the same coordinates
; We want to be close and to one side.
; To achieve this, the coordinates of both actors are compared.
; This allows determining from which side (left or right) we are approaching.
; Once that's determined, an offset to the destination coordinates is applied, so the walking actor approaches
; and stands next to the destination actor.
;
;	Arguments:	.X	destination costume
;				.Y	costume being moved
;===========================================
set_destination_for_actor:
;Load actors' indexes
.C:0f46  B9 57 FE    LDA actor_for_costume,Y
.C:0f49  A8          TAY
.C:0f4a  BD 57 FE    LDA actor_for_costume,X
.C:0f4d  AA          TAX
;Load destination positions
.C:0f4e  BD 3D FD    LDA position_y_for_actor,X
.C:0f51  8D E7 FD    STA y_destination
.C:0f54  BD 41 FD    LDA position_x_for_actor,X
.C:0f57  8D E6 FD    STA x_destination
;Check motion direction by comparing X positions
.C:0f5a  B9 41 FD    LDA position_x_for_actor,Y
.C:0f5d  CD E6 FD    CMP x_destination
.C:0f60  90 07       BCC position_is_le
.C:0f62  F0 05       BEQ position_is_le
inlined_positive_destination_offset = $0f65
;Set the positive "approach" offset
.C:0f64  A9 04       LDA #$04
.C:0f66  4C 6B 0F    JMP add_offset_to_destination
position_is_le:
inlined_negative_destination_offset = $0f6a
;Set the negative "approach" offset
.C:0f69  A9 FC       LDA #$FC
add_offset_to_destination:
.C:0f6b  18          CLC
.C:0f6c  6D E6 FD    ADC x_destination
.C:0f6f  8D E6 FD    STA x_destination
;Adjust target coordinate based on boundary boxes
.C:0f72  4C A3 0F    JMP adjust_by_boundary
;===========================================
; Set destination for object
;
;	Arguments:	.X	actor to be moved
;				.Y	destination object
;===========================================
set_destination_for_object:
;Is there an explicit destination coordinate for the object?
.C:0f75  B9 05 72    LDA object_destination_active,Y
.C:0f78  D0 1B       BNE explicit_destination
;---------------------------------------------------
; No explicit destination coordinates for the object
;
; Compute them as the middle point of the object box
;---------------------------------------------------
no_explicit_destination:
;Compute object middle X position = width/2 + x_start
.C:0f7a  B9 95 71    LDA object_width,Y
.C:0f7d  4A          LSR A
.C:0f7e  18          CLC
.C:0f7f  79 5D 71    ADC object_x_start,Y
;Set as X destination
.C:0f82  8D E6 FD    STA x_destination
;Compute object middle Y position = height/2 + y_start
.C:0f85  B9 B1 71    LDA object_height,Y
.C:0f88  4A          LSR A
.C:0f89  18          CLC
.C:0f8a  79 79 71    ADC object_y_start,Y
;Normalize
.C:0f8d  0A          ASL A
.C:0f8e  0A          ASL A
;Set as Y destination
.C:0f8f  8D E7 FD    STA y_destination
.C:0f92  4C A3 0F    JMP adjust_by_boundary
;---------------------------------------------------
;There's an explicit destination set of coordinates, use them
;---------------------------------------------------
explicit_destination:
.C:0f95  B9 CD 71    LDA object_x_destination,Y
.C:0f98  8D E6 FD    STA x_destination
.C:0f9b  B9 E9 71    LDA object_y_destination,Y
.C:0f9e  0A          ASL A
.C:0f9f  0A          ASL A
.C:0fa0  8D E7 FD    STA y_destination
;Fall through to adjust_by_boundary
;===========================================
; Adjust the target coordinates based on boundary boxes
;===========================================
box_check_x = $fe72
box_check_y = $fe73

adjust_by_boundary:
;Copy the destination coordinates into box_check_x/y
.C:0fa3  AD E6 FD    LDA x_destination
.C:0fa6  8D 72 FE    STA box_check_x
.C:0fa9  AD E7 FD    LDA y_destination
.C:0fac  8D 73 FE    STA box_check_y
;Copy the current_room as the walkbox_room
.C:0faf  AD 49 71    LDA current_room
.C:0fb2  8D 74 FE    STA walkbox_room
;Adjust the destination coordinates as needed
.C:0fb5  20 9B 1A    JSR adjust_coords_by_walkbox
;Copy the adjusted coordinates back to the destination coordinates
.C:0fb8  AD 72 FE    LDA box_check_x
.C:0fbb  8D E6 FD    STA x_destination
.C:0fbe  AD 73 FE    LDA box_check_y
.C:0fc1  8D E7 FD    STA y_destination
;Restore saved .Y value
.C:0fc4  AC C9 0F    LDY temp_y
.C:0fc7  60          RTS
;===========================================
; For each of the 8 sprites, allowed vertical positions are in the range 0-255, and so can be represented with a single byte.
; Horizontal positions are in the range 0-319, which cannot be represented with just 1 byte (8 bits). 
; With 9 bits, values can be represented in the range 0-512, which is enough for the intended 0-319 range.
; So, for the horizontal position (which we call "X"), 9 bits are needed. Bits 0-7 fit in one byte and bit 8 in another.
;
; To make more efficient use of storage, the VIC-II chip combines all the "bit 8"s of all sprites into a single register.
; There are also 8 sprites in total, so there are 8 bit 8s.
; We labelled this register "sprites_x_hi_combined_reg", which can be a bit cryptic if this explanation is not present.
; 
; So, for each of the sprites, whenever the bit8 of a given sprite needs to be set or cleared, 
; the corresponding bit in the "bit8" register needs to be set or cleared.
; This is done by these steps:
;		-determine the bit8 value based on the sprite's intended coordinate
;		-shift the value into position
;		-OR'ing the bit into the bitmask value that will later be copied to the "bit8" register
;
; Sprites 0-6 might change their relative position over time.
; When this happens, their relative bit positions should be kept in sync.
;
; Variables relative_sprite_0 to relative_sprite_6 track those changes
; and update their values accordingly.
;===========================================
update_sprites_x_hi_and_chain_handlers:
.C:0fef  A9 00       LDA #$00
.C:0ff1  8D E9 0F    STA sprites_x_hi_combined
;-----
;Load bit8 of X coordinate
.C:0ff4  AD E1 0F    LDA sprite_0_x_hi
.C:0ff7  AE DA 0F    LDX relative_sprite_0
;Is it zero? If so, continue
.C:0ffa  F0 04       BEQ $1000
;It's 1, shift bit into position (based on the relative sprite index)
.C:0ffc  0A          ASL A
.C:0ffd  CA          DEX
.C:0ffe  D0 FC       BNE $0FFC
;OR the bit into position in the combined byte
.C:1000  0D E9 0F    ORA sprites_x_hi_combined
.C:1003  8D E9 0F    STA sprites_x_hi_combined
;-----
;Repeat for sprites 1-6
.C:1006  AD E2 0F    LDA sprite_1_x_hi
.C:1009  AE DB 0F    LDX relative_sprite_1
.C:100c  F0 04       BEQ $1012
.C:100e  0A          ASL A
.C:100f  CA          DEX
.C:1010  D0 FC       BNE $100E
.C:1012  0D E9 0F    ORA sprites_x_hi_combined
.C:1015  8D E9 0F    STA sprites_x_hi_combined
;-----
.C:1018  AD E3 0F    LDA sprite_2_x_hi
.C:101b  AE DC 0F    LDX relative_sprite_2
.C:101e  F0 04       BEQ $1024
.C:1020  0A          ASL A
.C:1021  CA          DEX
.C:1022  D0 FC       BNE $1020
.C:1024  0D E9 0F    ORA sprites_x_hi_combined
.C:1027  8D E9 0F    STA sprites_x_hi_combined
;-----
.C:102a  AD E4 0F    LDA sprite_3_x_hi
.C:102d  AE DD 0F    LDX relative_sprite_3
.C:1030  F0 04       BEQ $1036
.C:1032  0A          ASL A
.C:1033  CA          DEX
.C:1034  D0 FC       BNE $1032
.C:1036  0D E9 0F    ORA sprites_x_hi_combined
.C:1039  8D E9 0F    STA sprites_x_hi_combined
;-----
.C:103c  AD E5 0F    LDA sprite_4_x_hi
.C:103f  AE DE 0F    LDX relative_sprite_4
.C:1042  F0 04       BEQ $1048
.C:1044  0A          ASL A
.C:1045  CA          DEX
.C:1046  D0 FC       BNE $1044
.C:1048  0D E9 0F    ORA sprites_x_hi_combined
.C:104b  8D E9 0F    STA sprites_x_hi_combined
;-----
.C:104e  AD E6 0F    LDA sprite_5_x_hi
.C:1051  AE DF 0F    LDX relative_sprite_5
.C:1054  F0 04       BEQ $105A
.C:1056  0A          ASL A
.C:1057  CA          DEX
.C:1058  D0 FC       BNE $1056
.C:105a  0D E9 0F    ORA sprites_x_hi_combined
.C:105d  8D E9 0F    STA sprites_x_hi_combined
;-----
.C:1060  AD E7 0F    LDA sprite_6_x_hi
.C:1063  AE E0 0F    LDX relative_sprite_6
.C:1066  F0 04       BEQ $106C
.C:1068  0A          ASL A
.C:1069  CA          DEX
.C:106a  D0 FC       BNE $1068
.C:106c  0D E9 0F    ORA sprites_x_hi_combined
.C:106f  8D E9 0F    STA sprites_x_hi_combined
;-----------------------------------------
;Set cursor sprite position
.C:1072  A2 07       LDX #$07
;If bit8 is 0, copy it to the bit 8 register
.C:1074  AD E8 0F    LDA cursor_sprite_x_hi
.C:1077  F0 04       BEQ update_cursor_bit8
;It's not #00 (it's #01), so shift it left 7 times to put the bit in the position for sprite 7
bit8_left_shift_loop:
.C:1079  0A          ASL A
.C:107a  CA          DEX
.C:107b  D0 FC       BNE bit8_left_shift_loop
update_sprite_xbit8_bitmask:
;Set/clear the bitmask of "bit 8 of X coordinates" accordingly
.C:107d  0D E9 0F    ORA sprites_x_hi_combined		
.C:1080  8D 10 D0    STA sprites_x_hi_combined_reg		
.C:1083  AC D1 0F    LDY cursor_sprite_x_lo
.C:1086  8C 0E D0    STY sprite7_x_lo_register	
;-----------------------------------------
;Acknowledge raster interrupt
.C:1089  A0 81       LDY #$81
.C:108b  8C 19 D0    STY vic_irq_flag_register
;Set next raster line for interrupt
.C:108e  A0 29       LDY #$29
.C:1090  8C 12 D0    STY raster_line_register
;Read CIA 1 interrupt status register to acknowledge interupts
.C:1093  AC 0D DC    LDY cia1_irq_status_register		
;Set next IRQ handler
.C:1096  A0 A1       LDY <irq_handler2
.C:1098  8C FE FF    STY <irq_handler
.C:109b  A0 10       LDY >irq_handler2
.C:109d  8C FF FF    STY >irq_handler
.C:10a0  60          RTS
;===========================================
; IRQ handler #2
;
; This is the first handler, from top of screen to bottom,
; that gets called when the target raster line (#29) is hit.
; 
; This routine will:
;		-set sprites 0-6 horizontal positions
;		-set sprites 0-3 shapes using sprite_shape_1 as array of shape indexes
;		-color all sprites gray if lights are off
;		-set cursor sprite color
;		-set sprites 0-6 vertical positions to #32 (the first visible raster line)
;		-set up the next raster IRQ handler
;===========================================
;These 3 temporary variables are used to store registers in all of the IRQ handlers below
temp_y = $0fec
temp_a = $0fed
temp_x = $0fee

irq_handler2:
;Save .A, .X and .Y
.C:10a1  8D ED 0F    STA temp_a
.C:10a4  8E EE 0F    STX temp_x
.C:10a7  8C EC 0F    STY temp_y
;Save processor port register value
.C:10aa  A4 01       LDY processor_port_register
.C:10ac  84 26       STY processor_port_reg_copy
;map_in_io
.C:10ae  A0 25       LDY #$25
.C:10b0  84 01       STY processor_port_register
;------------------------------------------------
;Load the relative sprite index
.C:10b2  AD DA 0F    LDA relative_sprite_0
;Horizontal position registers for each sprite are 2 bytes apart
;So multiply by 2 to get the desired register offset
.C:10b5  0A          ASL A
.C:10b6  A8          TAY
;Load the horizontal position (bits 0-7) and set it in the desired register
.C:10b7  AD CA 0F    LDA sprite_0_x_lo
.C:10ba  99 00 D0    STA sprite0_x_lo_register,Y
;And repeat for each of the remaining sprites 1-6
.C:10bd  AD DB 0F    LDA relative_sprite_1
.C:10c0  0A          ASL A
.C:10c1  A8          TAY
.C:10c2  AD CB 0F    LDA sprite_1_x_lo
.C:10c5  99 00 D0    STA sprite0_x_lo_register,Y
.C:10c8  AD DC 0F    LDA relative_sprite_2
.C:10cb  0A          ASL A
.C:10cc  A8          TAY
.C:10cd  AD CC 0F    LDA sprite_2_x_lo
.C:10d0  99 00 D0    STA sprite0_x_lo_register,Y
.C:10d3  AD DD 0F    LDA relative_sprite_3
.C:10d6  0A          ASL A
.C:10d7  A8          TAY
.C:10d8  AD CD 0F    LDA sprite_3_x_lo
.C:10db  99 00 D0    STA sprite0_x_lo_register,Y
.C:10de  AD DE 0F    LDA relative_sprite_4
.C:10e1  0A          ASL A
.C:10e2  A8          TAY
.C:10e3  AD CE 0F    LDA sprite_4_x_lo
.C:10e6  99 00 D0    STA sprite0_x_lo_register,Y
.C:10e9  AD DF 0F    LDA relative_sprite_5
.C:10ec  0A          ASL A
.C:10ed  A8          TAY
.C:10ee  AD CF 0F    LDA sprite_5_x_lo
.C:10f1  99 00 D0    STA sprite0_x_lo_register,Y
.C:10f4  AD E0 0F    LDA relative_sprite_6
.C:10f7  0A          ASL A
.C:10f8  A8          TAY
.C:10f9  AD D0 0F    LDA sprite_6_x_lo
.C:10fc  99 00 D0    STA sprite0_x_lo_register,Y
;------------------------------------------------
;Sprite 7 is fixed (the cursor), so just copy the value directly
.C:10ff  AC D1 0F    LDY cursor_sprite_x_lo
.C:1102  8C 0E D0    STY sprite7_x_lo_register
;Set horizontal expansion for sprites
.C:1105  AC EA 0F    LDY sprite_horizontal_expansion
.C:1108  8C 1D D0    STY vic_sprite_hor_expansion_reg
;------------------------------------------------
;Update sprite shapes for sprites 0-3
.C:110b  AE 61 16    LDX sprite_shape_1
.C:110e  AC DA 0F    LDY relative_sprite_0
.C:1111  8A          TXA
.C:1112  91 8C       STA (sprite_shape_data_ptr),Y
.C:1114  E8          INX
.C:1115  AC DB 0F    LDY relative_sprite_1
.C:1118  8A          TXA
.C:1119  91 8C       STA (sprite_shape_data_ptr),Y
.C:111b  E8          INX
.C:111c  AC DC 0F    LDY relative_sprite_2
.C:111f  8A          TXA
.C:1120  91 8C       STA (sprite_shape_data_ptr),Y
.C:1122  E8          INX
.C:1123  AC DD 0F    LDY relative_sprite_3
.C:1126  8A          TXA
.C:1127  91 8C       STA (sprite_shape_data_ptr),Y
;Update sprite shape for cursor (covering the two possible video memory layouts)
.C:1129  AC 69 16    LDY sprite_shape_cursor
.C:112c  8C FF CB    STY $CBFF
.C:112f  8C FF CF    STY $CFFF
;------------------------------------------------
;Lights_status is #00? If so, set sprites 0-6 to dark gray
.C:1132  AD AB FE    LDA lights_status
.C:1135  F0 49       BEQ set_all_sprites_to_dark_gray
;------------------------------------------------
;Lights normal - set colors accordingly
;Each of these colors corresponds to the "Sprite X color register",
; which is the color for the bit pair "10"
.C:1137  AD DA 0F    LDA relative_sprite_0
.C:113a  A8          TAY
.C:113b  AD D2 0F    LDA sprite_0_color
.C:113e  99 27 D0    STA vic_sprite0_color_reg,Y
.C:1141  AD DB 0F    LDA relative_sprite_1
.C:1144  A8          TAY
.C:1145  AD D3 0F    LDA sprite_1_color
.C:1148  99 27 D0    STA vic_sprite0_color_reg,Y
.C:114b  AD DC 0F    LDA relative_sprite_2
.C:114e  A8          TAY
.C:114f  AD D4 0F    LDA sprite_2_color
.C:1152  99 27 D0    STA vic_sprite0_color_reg,Y
.C:1155  AD DD 0F    LDA relative_sprite_3
.C:1158  A8          TAY
.C:1159  AD D5 0F    LDA sprite_3_color
.C:115c  99 27 D0    STA vic_sprite0_color_reg,Y
.C:115f  AD DE 0F    LDA relative_sprite_4
.C:1162  A8          TAY
.C:1163  AD D6 0F    LDA sprite_4_color
.C:1166  99 27 D0    STA vic_sprite0_color_reg,Y
.C:1169  AD DF 0F    LDA relative_sprite_5
.C:116c  A8          TAY
.C:116d  AD D7 0F    LDA sprite_5_color
.C:1170  99 27 D0    STA vic_sprite0_color_reg,Y
.C:1173  AD E0 0F    LDA relative_sprite_6
.C:1176  A8          TAY
.C:1177  AD D8 0F    LDA sprite_6_color
.C:117a  99 27 D0    STA vic_sprite0_color_reg,Y
.C:117d  4C 8A 11    JMP set_cursor_color
;------------------------------------------------
set_all_sprites_to_dark_gray:
.C:1180  A2 06       LDX #$06
set_dark_gray_loop:
.C:1182  A9 0B       LDA #$0B
.C:1184  9D 27 D0    STA vic_sprite0_color_reg,X
.C:1187  CA          DEX
.C:1188  10 F8       BPL set_dark_gray_loop
;------------------------------------------------
set_cursor_color:
;Sprite 7 is the cursor, it has colors independent from the lights
;Set sprite 7 colors
.C:118a  AC D9 0F    LDY cursor_sprite_color
.C:118d  8C 2E D0    STY vic_sprite7_color_reg
;------------------------------------------------
;Set cursor Y coordinate
.C:1190  AC EB 0F    LDY cursor_sprite_y
.C:1193  8C 0F D0    STY sprite7_y_register
;Set Y coordinate of sprites 0-6 to #32
.C:1196  A0 32       LDY #$32
.C:1198  8C 01 D0    STY sprite0_y_register
.C:119b  8C 03 D0    STY sprite1_y_register
.C:119e  8C 05 D0    STY sprite2_y_register
.C:11a1  8C 07 D0    STY sprite3_y_register
.C:11a4  8C 09 D0    STY sprite4_y_register
.C:11a7  8C 0B D0    STY sprite5_y_register
.C:11aa  8C 0D D0    STY sprite6_y_register
;------------------------------------------------
;Acknowledge raster interrupt
.C:11ad  A0 81       LDY #$81
.C:11af  8C 19 D0    STY vic_irq_flag_register
;Set next raster line for interrupt
.C:11b2  A0 3A       LDY #$3A
.C:11b4  8C 12 D0    STY raster_line_register
.C:11b7  AC 0D DC    LDY cia1_irq_status_register
;Set IRQ handler to irq_handler3
.C:11ba  A0 D2       LDY <irq_handler3
.C:11bc  8C FE FF    STY <irq_handler
.C:11bf  A0 11       LDY >irq_handler3
.C:11c1  8C FF FF    STY >irq_handler
;------------------------------------------------
;Restore processor port register value
.C:11c4  A4 26       LDY processor_port_reg_copy
.C:11c6  84 01       STY processor_port_register
;Restore .A, .X and .Y
.C:11c8  AD ED 0F    LDA temp_a
.C:11cb  AE EE 0F    LDX temp_x
.C:11ce  AC EC 0F    LDY temp_y
.C:11d1  40          RTI
;===========================================
; IRQ handler #3
;
; Called when the target raster line (#3A) is hit.
; 
; This routine will:
;		-switch from normal text mode to multicolor text mode
;		-move sprites 0-6 downwards by exactly their height (21 dots)
;		thus setting Y position to #47
;		-set up the next raster IRQ handler
;
; Note: careful synchronization is needed of the moments when the mode switch
; and the sprites position change take place.
;
; This has been baked into the code by executing NOPs as needed
; to wait an exact number of cycles.
;===========================================
irq_handler3:
;Save .A and .Y
.C:11d2  8C EC 0F    STY temp_y
.C:11d5  8D ED 0F    STA temp_a
;Save processor port register value
.C:11d8  A4 01       LDY processor_port_register
.C:11da  84 26       STY processor_port_reg_copy
;map_in_io
.C:11dc  A0 25       LDY #$25
.C:11de  84 01       STY processor_port_register
;------------------------------------------------
;Set screen to 25 rows, vertical scroll 4
.C:11e0  A0 1C       LDY #$1C
.C:11e2  8C 11 D0    STY vic_screen_control_register_1
;Wait for the moment to switch from normal text mode to multicolor text mode
.C:11e5  EA          NOP
.C:11e6  EA          NOP
.C:11e7  EA          NOP
;Load current memory layout into .Y
.C:11e8  A4 BE       LDY vic_memory_layout
;Load value in .A for multicolor text mode
.C:11ea  A9 18       LDA #$18	
;Set the current multicolor memory layout for the VIC-II
.C:11ec  8C 18 D0    STY vic_memory_control_register
;Set Multicolor on, 40 columns, horizontal fine scroll 0
.C:11ef  8D 16 D0    STA vic_screen_control2_reg
;------------------------------------------------
;Wait for the right moment to move the sprites coordinates downwards
.C:11f2  EA          NOP
.C:11f3  EA          NOP
.C:11f4  EA          NOP
.C:11f5  EA          NOP
.C:11f6  EA          NOP
.C:11f7  EA          NOP
.C:11f8  EA          NOP
.C:11f9  EA          NOP
.C:11fa  EA          NOP
.C:11fb  EA          NOP
;Set Y coordinate of sprites 0-6 to #47
.C:11fc  A0 47       LDY #$47
.C:11fe  8C 01 D0    STY sprite0_y_register
.C:1201  8C 03 D0    STY sprite1_y_register
.C:1204  8C 05 D0    STY sprite2_y_register
.C:1207  8C 07 D0    STY sprite3_y_register
.C:120a  8C 09 D0    STY sprite4_y_register
.C:120d  8C 0B D0    STY sprite5_y_register
.C:1210  8C 0D D0    STY sprite6_y_register
;------------------------------------------------
;Acknowledge raster interrupt
.C:1213  A0 81       LDY #$81
.C:1215  8C 19 D0    STY vic_irq_flag_register
;Set next raster line for interrupt
.C:1218  A0 45       LDY #$45
.C:121a  8C 12 D0    STY raster_line_register
.C:121d  AC 0D DC    LDY cia1_irq_status_register
;Set IRQ handler to irq_handler4
.C:1220  A0 35       LDY <irq_handler4
.C:1222  8C FE FF    STY <irq_handler
.C:1225  A0 12       LDY >irq_handler4
.C:1227  8C FF FF    STY >irq_handler
;Restore processor port register value and general registers
.C:122a  A4 26       LDY processor_port_reg_copy
.C:122c  84 01       STY processor_port_register
.C:122e  AC EC 0F    LDY temp_y
.C:1231  AD ED 0F    LDA temp_a
.C:1234  40          RTI
;=======================================================
; IRQ handler #4
;
; Called when the target raster line (#45) is hit.
; 
; This routine will:
;		-set sprites 0-3 shapes using sprite_shape_2 as array of shape indexes
;		-set up the next raster IRQ handler
;
;=======================================================
irq_handler4:
;Save .A, .X and .Y
.C:1235  8D ED 0F    STA temp_a
.C:1238  8E EE 0F    STX temp_x
.C:123b  8C EC 0F    STY temp_y
;------------------------------------------------
;Update sprite shapes for sprites 0-3
.C:123e  AE 62 16    LDX sprite_shape_2
.C:1241  AC DA 0F    LDY relative_sprite_0
.C:1244  8A          TXA
.C:1245  91 8C       STA (sprite_shape_data_ptr),Y
.C:1247  E8          INX
.C:1248  AC DB 0F    LDY relative_sprite_1
.C:124b  8A          TXA
.C:124c  91 8C       STA (sprite_shape_data_ptr),Y
.C:124e  E8          INX
.C:124f  AC DC 0F    LDY relative_sprite_2
.C:1252  8A          TXA
.C:1253  91 8C       STA (sprite_shape_data_ptr),Y
.C:1255  E8          INX
.C:1256  AC DD 0F    LDY relative_sprite_3
.C:1259  8A          TXA
.C:125a  91 8C       STA (sprite_shape_data_ptr),Y
;------------------------------------------------
.C:125c  A4 01       LDY processor_port_register
.C:125e  84 26       STY processor_port_reg_copy
;map_in_io
.C:1260  A0 25       LDY #$25
.C:1262  84 01       STY processor_port_register
;Set next raster line for interrupt
.C:1264  A0 4F       LDY #$4F
.C:1266  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler5
.C:1269  A0 89       LDY <irq_handler5
.C:126b  8C FE FF    STY <irq_handler
.C:126e  A0 12       LDY >irq_handler5
.C:1270  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:1273  A0 81       LDY #$81
.C:1275  8C 19 D0    STY vic_irq_flag_register
.C:1278  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:127b  A4 26       LDY processor_port_reg_copy
.C:127d  84 01       STY processor_port_register
.C:127f  AD ED 0F    LDA temp_a
.C:1282  AE EE 0F    LDX temp_x
.C:1285  AC EC 0F    LDY temp_y
.C:1288  40          RTI
;===========================================
; IRQ handler #5
;
; Called when the target raster line (#4F) is hit.
; 
; This routine will:
;		-move sprites 0-6 downwards by exactly their height (21 dots)
;		thus setting Y position to #5C
;		-set up the next raster IRQ handler
;
;===========================================
irq_handler5:
;Save .Y
.C:1289  8C EC 0F    STY temp_y
.C:128c  A4 01       LDY processor_port_register
.C:128e  84 26       STY processor_port_reg_copy
;map_in_io
.C:1290  A0 25       LDY #$25
.C:1292  84 01       STY processor_port_register
;------------------------------------------------
;Set Y coordinate of sprites 0-6 to #5C
.C:1294  A0 5C       LDY #$5C
.C:1296  8C 01 D0    STY sprite0_y_register
.C:1299  8C 03 D0    STY sprite1_y_register
.C:129c  8C 05 D0    STY sprite2_y_register
.C:129f  8C 07 D0    STY sprite3_y_register
.C:12a2  8C 09 D0    STY sprite4_y_register
.C:12a5  8C 0B D0    STY sprite5_y_register
.C:12a8  8C 0D D0    STY sprite6_y_register
;------------------------------------------------
;Set next raster line for interrupt
.C:12ab  A0 59       LDY #$59
.C:12ad  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler6
.C:12b0  A0 CA       LDY <irq_handler6
.C:12b2  8C FE FF    STY <irq_handler
.C:12b5  A0 12       LDY >irq_handler6
.C:12b7  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:12ba  A0 81       LDY #$81
.C:12bc  8C 19 D0    STY vic_irq_flag_register
.C:12bf  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:12c2  A4 26       LDY processor_port_reg_copy
.C:12c4  84 01       STY processor_port_register
.C:12c6  AC EC 0F    LDY temp_y
.C:12c9  40          RTI
;=======================================================
; IRQ handler #6
;
; Called when the target raster line (#59) is hit.
; 
; This routine will:
;		-set sprites 0-3 shapes using sprite_shape_3 as array of shape indexes
;		-set up the next raster IRQ handler
;
;=======================================================
irq_handler6:
;Save .A, .X and .Y
.C:12ca  8D ED 0F    STA temp_a
.C:12cd  8E EE 0F    STX temp_x
.C:12d0  8C EC 0F    STY temp_y
;------------------------------------------------
.C:12d3  AE 63 16    LDX sprite_shape_3
.C:12d6  AC DA 0F    LDY relative_sprite_0
.C:12d9  8A          TXA
.C:12da  91 8C       STA (sprite_shape_data_ptr),Y
.C:12dc  E8          INX
.C:12dd  AC DB 0F    LDY relative_sprite_1
.C:12e0  8A          TXA
.C:12e1  91 8C       STA (sprite_shape_data_ptr),Y
.C:12e3  E8          INX
.C:12e4  AC DC 0F    LDY relative_sprite_2
.C:12e7  8A          TXA
.C:12e8  91 8C       STA (sprite_shape_data_ptr),Y
.C:12ea  E8          INX
.C:12eb  AC DD 0F    LDY relative_sprite_3
.C:12ee  8A          TXA
.C:12ef  91 8C       STA (sprite_shape_data_ptr),Y
;------------------------------------------------
.C:12f1  A4 01       LDY processor_port_register
.C:12f3  84 26       STY processor_port_reg_copy
;map_in_io
.C:12f5  A0 25       LDY #$25
.C:12f7  84 01       STY processor_port_register
;Set next raster line for interrupt
.C:12f9  A0 63       LDY #$63
.C:12fb  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler7
.C:12fe  A0 1E       LDY <irq_handler7
.C:1300  8C FE FF    STY <irq_handler
.C:1303  A0 13       LDY >irq_handler7
.C:1305  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:1308  A0 81       LDY #$81
.C:130a  8C 19 D0    STY vic_irq_flag_register
.C:130d  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:1310  A4 26       LDY processor_port_reg_copy
.C:1312  84 01       STY processor_port_register
.C:1314  AD ED 0F    LDA temp_a
.C:1317  AE EE 0F    LDX temp_x
.C:131a  AC EC 0F    LDY temp_y
.C:131d  40          RTI
;===========================================
; IRQ handler #7
;
; Called when the target raster line (#63) is hit.
; 
; This routine will:
;		-move sprites 0-6 downwards by exactly their height (21 dots)
;		thus setting Y position to #71
;		-set up the next raster IRQ handler
;
;===========================================
irq_handler7:
.C:131e  8C EC 0F    STY temp_y
.C:1321  A4 01       LDY processor_port_register
.C:1323  84 26       STY processor_port_reg_copy
;map_in_io
.C:1325  A0 25       LDY #$25
.C:1327  84 01       STY processor_port_register
;------------------------------------------------
;Set Y coordinate of sprites 0-6 to #71
.C:1329  A0 71       LDY #$71
.C:132b  8C 01 D0    STY sprite0_y_register
.C:132e  8C 03 D0    STY sprite1_y_register
.C:1331  8C 05 D0    STY sprite2_y_register
.C:1334  8C 07 D0    STY sprite3_y_register
.C:1337  8C 09 D0    STY sprite4_y_register
.C:133a  8C 0B D0    STY sprite5_y_register
.C:133d  8C 0D D0    STY sprite6_y_register
;------------------------------------------------
;Set next raster line for interrupt
.C:1340  A0 6D       LDY #$6D
.C:1342  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler8
.C:1345  A0 5F       LDY <irq_handler8
.C:1347  8C FE FF    STY <irq_handler
.C:134a  A0 13       LDY >irq_handler8
.C:134c  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:134f  A0 81       LDY #$81
.C:1351  8C 19 D0    STY vic_irq_flag_register
.C:1354  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:1357  A4 26       LDY processor_port_reg_copy
.C:1359  84 01       STY processor_port_register
.C:135b  AC EC 0F    LDY temp_y
.C:135e  40          RTI
;=======================================================
; IRQ handler #8
;
; Called when the target raster line (#6D) is hit.
; 
; This routine will:
;		-set sprites 0-3 shapes using sprite_shape_4 as array of shape indexes
;		-set up the next raster IRQ handler
;
;=======================================================
irq_handler8:
;Save .A, .X and .Y
.C:135f  8D ED 0F    STA temp_a
.C:1362  8E EE 0F    STX temp_x
.C:1365  8C EC 0F    STY temp_y
;------------------------------------------------
.C:1368  AE 64 16    LDX sprite_shape_4
.C:136b  AC DA 0F    LDY relative_sprite_0
.C:136e  8A          TXA
.C:136f  91 8C       STA (sprite_shape_data_ptr),Y
.C:1371  E8          INX
.C:1372  AC DB 0F    LDY relative_sprite_1
.C:1375  8A          TXA
.C:1376  91 8C       STA (sprite_shape_data_ptr),Y
.C:1378  E8          INX
.C:1379  AC DC 0F    LDY relative_sprite_2
.C:137c  8A          TXA
.C:137d  91 8C       STA (sprite_shape_data_ptr),Y
.C:137f  E8          INX
.C:1380  AC DD 0F    LDY relative_sprite_3
.C:1383  8A          TXA
.C:1384  91 8C       STA (sprite_shape_data_ptr),Y
;------------------------------------------------
.C:1386  A4 01       LDY processor_port_register
.C:1388  84 26       STY processor_port_reg_copy
;map_in_io
.C:138a  A0 25       LDY #$25
.C:138c  84 01       STY processor_port_register
;Set next raster line for interrupt
.C:138e  A0 77       LDY #$77
.C:1390  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler9
.C:1393  A0 B3       LDY <irq_handler9
.C:1395  8C FE FF    STY <irq_handler
.C:1398  A0 13       LDY >irq_handler9
.C:139a  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:139d  A0 81       LDY #$81
.C:139f  8C 19 D0    STY vic_irq_flag_register
.C:13a2  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:13a5  A4 26       LDY processor_port_reg_copy
.C:13a7  84 01       STY processor_port_register
.C:13a9  AD ED 0F    LDA temp_a
.C:13ac  AE EE 0F    LDX temp_x
.C:13af  AC EC 0F    LDY temp_y
.C:13b2  40          RTI
;===========================================
; IRQ handler #9
;
; Called when the target raster line (#77) is hit.
; 
; This routine will:
;		-move sprites 0-6 downwards by exactly their height (21 dots)
;		thus setting Y position to #86
;		-set up the next raster IRQ handler
;
;===========================================
irq_handler9:
;Save .Y
.C:13b3  8C EC 0F    STY temp_y
.C:13b6  A4 01       LDY processor_port_register
.C:13b8  84 26       STY processor_port_reg_copy
;map_in_io
.C:13ba  A0 25       LDY #$25
.C:13bc  84 01       STY processor_port_register
;------------------------------------------------
;Set Y coordinate of sprites 0-6 to #86
.C:13be  A0 86       LDY #$86
.C:13c0  8C 01 D0    STY sprite0_y_register
.C:13c3  8C 03 D0    STY sprite1_y_register
.C:13c6  8C 05 D0    STY sprite2_y_register
.C:13c9  8C 07 D0    STY sprite3_y_register
.C:13cc  8C 09 D0    STY sprite4_y_register
.C:13cf  8C 0B D0    STY sprite5_y_register
.C:13d2  8C 0D D0    STY sprite6_y_register
;------------------------------------------------
;Set next raster line for interrupt
.C:13d5  A0 81       LDY #$81
.C:13d7  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler10
.C:13da  A0 F4       LDY <irq_handler10
.C:13dc  8C FE FF    STY <irq_handler
.C:13df  A0 13       LDY >irq_handler10
.C:13e1  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:13e4  A0 81       LDY #$81
.C:13e6  8C 19 D0    STY vic_irq_flag_register
.C:13e9  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:13ec  A4 26       LDY processor_port_reg_copy
.C:13ee  84 01       STY processor_port_register
.C:13f0  AC EC 0F    LDY temp_y
.C:13f3  40          RTI
;=======================================================
; IRQ handler #10
;
; Called when the target raster line (#81) is hit.
; 
; This routine will:
;		-set sprites 0-3 shapes using sprite_shape_5 as array of shape indexes
;		-set up the next raster IRQ handler
;
;=======================================================
irq_handler10:
;Save .A, .X and .Y
.C:13f4  8D ED 0F    STA temp_a
.C:13f7  8E EE 0F    STX temp_x
.C:13fa  8C EC 0F    STY temp_y
;------------------------------------------------
.C:13fd  AE 65 16    LDX sprite_shape_5
.C:1400  AC DA 0F    LDY relative_sprite_0
.C:1403  8A          TXA
.C:1404  91 8C       STA (sprite_shape_data_ptr),Y
.C:1406  E8          INX
.C:1407  AC DB 0F    LDY relative_sprite_1
.C:140a  8A          TXA
.C:140b  91 8C       STA (sprite_shape_data_ptr),Y
.C:140d  E8          INX
.C:140e  AC DC 0F    LDY relative_sprite_2
.C:1411  8A          TXA
.C:1412  91 8C       STA (sprite_shape_data_ptr),Y
.C:1414  E8          INX
.C:1415  AC DD 0F    LDY relative_sprite_3
.C:1418  8A          TXA
.C:1419  91 8C       STA (sprite_shape_data_ptr),Y
;------------------------------------------------
.C:141b  A4 01       LDY processor_port_register
.C:141d  84 26       STY processor_port_reg_copy
;map_in_io
.C:141f  A0 25       LDY #$25
.C:1421  84 01       STY processor_port_register
;Set next raster line for interrupt
.C:1423  A0 8B       LDY #$8B
.C:1425  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler11
.C:1428  A0 48       LDY <irq_handler11
.C:142a  8C FE FF    STY <irq_handler
.C:142d  A0 14       LDY >irq_handler11
.C:142f  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:1432  A0 81       LDY #$81
.C:1434  8C 19 D0    STY vic_irq_flag_register
.C:1437  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:143a  A4 26       LDY processor_port_reg_copy
.C:143c  84 01       STY processor_port_register
.C:143e  AD ED 0F    LDA temp_a
.C:1441  AE EE 0F    LDX temp_x
.C:1444  AC EC 0F    LDY temp_y
.C:1447  40          RTI
;===========================================
; IRQ handler #11
;
; Called when the target raster line (#8B) is hit.
; 
; This routine will:
;		-move sprites 0-6 downwards by exactly their height (21 dots)
;		thus setting Y position to #9B
;		-set up the next raster IRQ handler
;
;===========================================
irq_handler11:
;Save .Y
.C:1448  8C EC 0F    STY temp_y
.C:144b  A4 01       LDY processor_port_register
.C:144d  84 26       STY processor_port_reg_copy
;map_in_io
.C:144f  A0 25       LDY #$25
.C:1451  84 01       STY processor_port_register
;------------------------------------------------
;Set Y coordinate of sprites 0-6 to #9B
.C:1453  A0 9B       LDY #$9B
.C:1455  8C 01 D0    STY sprite0_y_register
.C:1458  8C 03 D0    STY sprite1_y_register
.C:145b  8C 05 D0    STY sprite2_y_register
.C:145e  8C 07 D0    STY sprite3_y_register
.C:1461  8C 09 D0    STY sprite4_y_register
.C:1464  8C 0B D0    STY sprite5_y_register
.C:1467  8C 0D D0    STY sprite6_y_register
;------------------------------------------------
;Set next raster line for interrupt
.C:146a  A0 95       LDY #$95
.C:146c  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler12
.C:146f  A0 89       LDY <irq_handler12
.C:1471  8C FE FF    STY <irq_handler
.C:1474  A0 14       LDY >irq_handler12
.C:1476  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:1479  A0 81       LDY #$81
.C:147b  8C 19 D0    STY vic_irq_flag_register
.C:147e  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:1481  A4 26       LDY processor_port_reg_copy
.C:1483  84 01       STY processor_port_register
.C:1485  AC EC 0F    LDY temp_y
.C:1488  40          RTI
;=======================================================
; IRQ handler #12
;
; Called when the target raster line (#95) is hit.
; 
; This routine will:
;		-set sprites 0-3 shapes using sprite_shape_6 as array of shape indexes
;		-set up the next raster IRQ handler
;
;=======================================================
irq_handler12:
;Save .A, .X and .Y
.C:1489  8D ED 0F    STA temp_a
.C:148c  8E EE 0F    STX temp_x
.C:148f  8C EC 0F    STY temp_y
;------------------------------------------------
.C:1492  AE 66 16    LDX sprite_shape_6
.C:1495  AC DA 0F    LDY relative_sprite_0
.C:1498  8A          TXA
.C:1499  91 8C       STA (sprite_shape_data_ptr),Y
.C:149b  E8          INX
.C:149c  AC DB 0F    LDY relative_sprite_1
.C:149f  8A          TXA
.C:14a0  91 8C       STA (sprite_shape_data_ptr),Y
.C:14a2  E8          INX
.C:14a3  AC DC 0F    LDY relative_sprite_2
.C:14a6  8A          TXA
.C:14a7  91 8C       STA (sprite_shape_data_ptr),Y
.C:14a9  E8          INX
.C:14aa  AC DD 0F    LDY relative_sprite_3
.C:14ad  8A          TXA
.C:14ae  91 8C       STA (sprite_shape_data_ptr),Y
;------------------------------------------------
.C:14b0  A4 01       LDY processor_port_register
.C:14b2  84 26       STY processor_port_reg_copy
;map_in_io
.C:14b4  A0 25       LDY #$25
.C:14b6  84 01       STY processor_port_register
;Set next raster line for interrupt
.C:14b8  A0 9F       LDY #$9F
.C:14ba  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler13
.C:14bd  A0 DD       LDY <irq_handler13
.C:14bf  8C FE FF    STY <irq_handler
.C:14c2  A0 14       LDY >irq_handler13
.C:14c4  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:14c7  A0 81       LDY #$81
.C:14c9  8C 19 D0    STY vic_irq_flag_register
.C:14cc  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:14cf  A4 26       LDY processor_port_reg_copy
.C:14d1  84 01       STY processor_port_register
.C:14d3  AD ED 0F    LDA temp_a
.C:14d6  AE EE 0F    LDX temp_x
.C:14d9  AC EC 0F    LDY temp_y
.C:14dc  40          RTI
;===========================================
; IRQ handler #13
;
; Called when the target raster line (#9F) is hit.
; 
; This routine will:
;		-move sprites 0-6 downwards by exactly their height (21 dots)
;		thus setting Y position to #B0
;		-set up the next raster IRQ handler
;
;===========================================
irq_handler13:
;Save .Y
.C:14dd  8C EC 0F    STY temp_y
.C:14e0  A4 01       LDY processor_port_register
.C:14e2  84 26       STY processor_port_reg_copy
;map_in_io
.C:14e4  A0 25       LDY #$25
.C:14e6  84 01       STY processor_port_register
;------------------------------------------------
;Set Y coordinate of sprites 0-6 to #B0
.C:14e8  A0 B0       LDY #$B0
.C:14ea  8C 01 D0    STY sprite0_y_register
.C:14ed  8C 03 D0    STY sprite1_y_register
.C:14f0  8C 05 D0    STY sprite2_y_register
.C:14f3  8C 07 D0    STY sprite3_y_register
.C:14f6  8C 09 D0    STY sprite4_y_register
.C:14f9  8C 0B D0    STY sprite5_y_register
.C:14fc  8C 0D D0    STY sprite6_y_register
;------------------------------------------------
;Set next raster line for interrupt
.C:14ff  A0 A9       LDY #$A9
.C:1501  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler14
.C:1504  A0 1E       LDY <irq_handler14
.C:1506  8C FE FF    STY <irq_handler
.C:1509  A0 15       LDY >irq_handler14
.C:150b  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:150e  A0 81       LDY #$81
.C:1510  8C 19 D0    STY vic_irq_flag_register
.C:1513  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:1516  A4 26       LDY processor_port_reg_copy
.C:1518  84 01       STY processor_port_register
.C:151a  AC EC 0F    LDY temp_y
.C:151d  40          RTI
;=======================================================
; IRQ handler #14
;
; Called when the target raster line (#A9) is hit.
; 
; This routine will:
;		-set sprites 0-3 shapes using sprite_shape_7 as array of shape indexes
;		-set up the next raster IRQ handler
;
;=======================================================
irq_handler14:
;Save .A, .X and .Y
.C:151e  8D ED 0F    STA temp_a
.C:1521  8E EE 0F    STX temp_x
.C:1524  8C EC 0F    STY temp_y
;------------------------------------------------
.C:1527  AE 67 16    LDX sprite_shape_7
.C:152a  AC DA 0F    LDY relative_sprite_0
.C:152d  8A          TXA
.C:152e  91 8C       STA (sprite_shape_data_ptr),Y
.C:1530  E8          INX
.C:1531  AC DB 0F    LDY relative_sprite_1
.C:1534  8A          TXA
.C:1535  91 8C       STA (sprite_shape_data_ptr),Y
.C:1537  E8          INX
.C:1538  AC DC 0F    LDY relative_sprite_2
.C:153b  8A          TXA
.C:153c  91 8C       STA (sprite_shape_data_ptr),Y
.C:153e  E8          INX
.C:153f  AC DD 0F    LDY relative_sprite_3
.C:1542  8A          TXA
.C:1543  91 8C       STA (sprite_shape_data_ptr),Y
;------------------------------------------------
.C:1545  A4 01       LDY processor_port_register
.C:1547  84 26       STY processor_port_reg_copy
;map_in_io
.C:1549  A0 25       LDY #$25
.C:154b  84 01       STY processor_port_register
;Set next raster line for interrupt
.C:154d  A0 B1       LDY #$B1
.C:154f  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler15
.C:1552  A0 72       LDY <irq_handler15
.C:1554  8C FE FF    STY <irq_handler
.C:1557  A0 15       LDY >irq_handler15
.C:1559  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:155c  A0 81       LDY #$81
.C:155e  8C 19 D0    STY vic_irq_flag_register
.C:1561  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:1564  A4 26       LDY processor_port_reg_copy
.C:1566  84 01       STY processor_port_register
.C:1568  AD ED 0F    LDA temp_a
.C:156b  AE EE 0F    LDX temp_x
.C:156e  AC EC 0F    LDY temp_y
.C:1571  40          RTI
;===========================================
; IRQ handler #15
;
; Called when the target raster line (#B1) is hit.
; 
; This routine will:
;		-move sprites 0-6 downwards by exactly their height (21 dots)
;		thus setting Y position to #C5
;		-set up the next raster IRQ handler
;
;===========================================
irq_handler15:
;Save .Y
.C:1572  8C EC 0F    STY temp_y
.C:1575  A4 01       LDY processor_port_register
.C:1577  84 26       STY processor_port_reg_copy
;map_in_io
.C:1579  A0 25       LDY #$25
.C:157b  84 01       STY processor_port_register
;------------------------------------------------
;Set Y coordinate of sprites 0-6 to #C5
.C:157d  A0 C5       LDY #$C5
.C:157f  8C 01 D0    STY sprite0_y_register
.C:1582  8C 03 D0    STY sprite1_y_register
.C:1585  8C 05 D0    STY sprite2_y_register
.C:1588  8C 07 D0    STY sprite3_y_register
.C:158b  8C 09 D0    STY sprite4_y_register
.C:158e  8C 0B D0    STY sprite5_y_register
.C:1591  8C 0D D0    STY sprite6_y_register
;------------------------------------------------
;Set next raster line for interrupt
.C:1594  A0 BD       LDY #$BD
.C:1596  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler16
.C:1599  A0 B3       LDY <irq_handler16
.C:159b  8C FE FF    STY <irq_handler
.C:159e  A0 15       LDY >irq_handler16
.C:15a0  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:15a3  A0 81       LDY #$81
.C:15a5  8C 19 D0    STY vic_irq_flag_register
.C:15a8  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:15ab  A4 26       LDY processor_port_reg_copy
.C:15ad  84 01       STY processor_port_register
.C:15af  AC EC 0F    LDY temp_y
.C:15b2  40          RTI
;=======================================================
; IRQ handler #16
;
; Called when the target raster line (#BD) is hit.
; 
; This routine will:
;		-set sprites 0-3 shapes using sprite_shape_8 as array of shape indexes
;		-set up the next raster IRQ handler
;
;=======================================================
irq_handler16:
;Save .A, .X and .Y
.C:15b3  8D ED 0F    STA temp_a
.C:15b6  8E EE 0F    STX temp_x
.C:15b9  8C EC 0F    STY temp_y
;------------------------------------------------
.C:15bc  AE 68 16    LDX sprite_shape_8
.C:15bf  AC DA 0F    LDY relative_sprite_0
.C:15c2  8A          TXA
.C:15c3  91 8C       STA (sprite_shape_data_ptr),Y
.C:15c5  E8          INX
.C:15c6  AC DB 0F    LDY relative_sprite_1
.C:15c9  8A          TXA
.C:15ca  91 8C       STA (sprite_shape_data_ptr),Y
.C:15cc  E8          INX
.C:15cd  AC DC 0F    LDY relative_sprite_2
.C:15d0  8A          TXA
.C:15d1  91 8C       STA (sprite_shape_data_ptr),Y
.C:15d3  E8          INX
.C:15d4  AC DD 0F    LDY relative_sprite_3
.C:15d7  8A          TXA
.C:15d8  91 8C       STA (sprite_shape_data_ptr),Y
;------------------------------------------------
.C:15da  A4 01       LDY processor_port_register
.C:15dc  84 26       STY processor_port_reg_copy
;map_in_io
.C:15de  A0 25       LDY #$25
.C:15e0  84 01       STY processor_port_register
;Set next raster line for interrupt
.C:15e2  A0 C3       LDY #$C3
.C:15e4  8C 12 D0    STY raster_line_register
;Set IRQ handler to irq_handler17
.C:15e7  A0 07       LDY <irq_handler17
.C:15e9  8C FE FF    STY <irq_handler
.C:15ec  A0 16       LDY >irq_handler17
.C:15ee  8C FF FF    STY >irq_handler
;Acknowledge raster interrupt
.C:15f1  A0 81       LDY #$81
.C:15f3  8C 19 D0    STY vic_irq_flag_register
.C:15f6  AC 0D DC    LDY cia1_irq_status_register
;Restore processor port register value and general registers
.C:15f9  A4 26       LDY processor_port_reg_copy
.C:15fb  84 01       STY processor_port_register
.C:15fd  AD ED 0F    LDA temp_a
.C:1600  AE EE 0F    LDX temp_x
.C:1603  AC EC 0F    LDY temp_y
.C:1606  40          RTI
;===========================================
; IRQ handler #17
;
; Called when the target raster line (#C3) is hit.
; 
; This routine will:
;		-move sprites 0-6 offscreen
;		-set up the next raster IRQ handler
;
; Invoked when leaving the room scene area
; From this point onwards, the "interaction region" needs to be drawn
; This will use normal text mode instead of multicolor.
;
; It will also use characters dot-data from F800, 
; which contains regular text characters and the inventory arrows
;===========================================
irq_handler17:
;Save .A and .Y
.C:1607  8C EC 0F    STY temp_y
.C:160a  8D ED 0F    STA temp_a
.C:160d  A4 01       LDY processor_port_register
.C:160f  84 26       STY processor_port_reg_copy
;map_in_io
.C:1611  A0 25       LDY #$25
.C:1613  84 01       STY processor_port_register
;------------------------------------------------
;Set 25 rows, vertical scroll 5
.C:1615  A9 1D       LDA #$1D
.C:1617  8D 11 D0    STA vic_screen_control_register_1
;Load value in .A for F800/CC00 VIC memory layout (dot-data/video matrix)
.C:161a  A9 3E       LDA #$3E
;Load value in .Y for normal text mode
.C:161c  A0 09       LDY #$09
.C:161e  EA          NOP
.C:161f  EA          NOP
.C:1620  EA          NOP
.C:1621  EA          NOP
;Set character base address: F800 (regular text characters)
;Set video matrix: CC00
.C:1622  8D 18 D0    STA vic_memory_control_register
;Set Multicolor off, 40 columns, horizontal fine scroll 1
.C:1625  8C 16 D0    STY vic_screen_control2_reg
;------------------------------------------------
;Set Y coordinate of sprites 0-6 to #FD (effectively moving them offscreen)
.C:1628  A0 FD       LDY #$FD
.C:162a  8C 01 D0    STY sprite0_y_register
.C:162d  8C 03 D0    STY sprite1_y_register
.C:1630  8C 05 D0    STY sprite2_y_register
.C:1633  8C 07 D0    STY sprite3_y_register
.C:1636  8C 09 D0    STY sprite4_y_register
.C:1639  8C 0B D0    STY sprite5_y_register
.C:163c  8C 0D D0    STY sprite6_y_register
;------------------------------------------------
;Acknowledge raster interrupt
.C:163f  A0 81       LDY #$81
.C:1641  8C 19 D0    STY vic_irq_flag_register
;Set next raster line for interrupt
.C:1644  A0 FB       LDY #$FB
.C:1646  8C 12 D0    STY raster_line_register
.C:1649  AC 0D DC    LDY cia1_irq_status_register
;Set IRQ handler back to irq_handler1
.C:164c  A0 7A       LDY <irq_handler1
.C:164e  8C FE FF    STY <irq_handler
.C:1651  A0 16       LDY >irq_handler1
.C:1653  8C FF FF    STY >irq_handler
;Restore processor port register value and general registers
.C:1656  A4 26       LDY processor_port_reg_copy
.C:1658  84 01       STY processor_port_register
.C:165a  AC EC 0F    LDY temp_y
.C:165d  AD ED 0F    LDA temp_a
.C:1660  40          RTI
;=======================================================
cursor_color_wait_start:
.C:166f  06 
first_cursor_color_index:
.C:1670  05       
cursor_colors:
.C:1671  01 0F 0C 0B 0C 0F 
;===========================================
; IRQ handler
;===========================================
irq_handler1:
;Save .A, .X, .Y and processor_port_register in stack
.C:167a  48          PHA
.C:167b  8A          TXA
.C:167c  48          PHA
.C:167d  98          TYA
.C:167e  48          PHA
.C:167f  A5 01       LDA processor_port_register
.C:1681  48          PHA
;map_in_io
.C:1682  A0 25       LDY #$25
.C:1684  84 01       STY processor_port_register
;Check if irq lock is clear - if so, continue
.C:1686  A5 E3       LDA irq_lock
.C:1688  F0 07       BEQ entry_enabled
;IRQ lock is set - clear it and return
;Another part of the code was waiting for this lock to be cleared
.C:168a  A9 00       LDA #$00
.C:168c  85 E3       STA irq_lock
.C:168e  4C 4B 18    JMP exit
;--------------------------------------------------
entry_enabled:
;Set 25 rows, vertical scroll 3
.C:1691  A9 1B       LDA #$1B
.C:1693  8D 11 D0    STA vic_screen_control_register_1
;Set bkg color to black
.C:1696  A9 00       LDA #$00		
.C:1698  8D 21 D0    STA vic_bkg_color0_register
;Increment the handler entry count
.C:169b  E6 D9       INC irq_handler1_section_entry_count
;Mark that we haven't copied color RAM data yet
.C:169d  A9 00       LDA #$00
.C:169f  8D 77 16    STA color_ram_data_copied
;Check if video needs to be updated
.C:16a2  A5 8E       LDA video_update_signal
.C:16a4  D0 07       BNE signal_set
;--------------------------------------------------
;Signal is clear - don't do the full video update
;Update sprites X hi and set up chain of IRQ handlers
signal_clear:
.C:16a6  20 EF 0F    JSR update_sprites_x_hi_and_chain_handlers		
;Enable interrupts
.C:16a9  58          CLI
;Continue - from the section that clears the video_processed signal
.C:16aa  4C A1 17    JMP clear_video_processed_signal
;--------------------------------------------------
;Video update signal is set
signal_set:
;Do we have to switch the sprite shapes set?
.C:16ad  AD 6A 16    LDA sprite_shapes_set_to_use
.C:16b0  D0 03       BNE check_sprites_shapes_set
;If not, continue with preparing the next frame IRQ handler
.C:16b2  4C 59 17    JMP prepare_next_frame_handler
;--------------------------------------------------
check_sprites_shapes_set:
.C:16b5  C9 01       CMP #$01
.C:16b7  D0 2B       BNE set_sprite_shapes_set2
;--------------------------------------------------
set_sprite_shapes_set1:
;Set one particular set of shapes for the sprites
.C:16b9  A9 80       LDA #$80
.C:16bb  8D 61 16    STA sprite_shape_1
.C:16be  A9 84       LDA #$84
.C:16c0  8D 62 16    STA sprite_shape_2
.C:16c3  A9 88       LDA #$88
.C:16c5  8D 63 16    STA sprite_shape_3
.C:16c8  A9 8C       LDA #$8C
.C:16ca  8D 64 16    STA sprite_shape_4
.C:16cd  A9 90       LDA #$90
.C:16cf  8D 65 16    STA sprite_shape_5
.C:16d2  A9 94       LDA #$94
.C:16d4  8D 66 16    STA sprite_shape_6
.C:16d7  A9 98       LDA #$98
.C:16d9  8D 67 16    STA sprite_shape_7
.C:16dc  A9 9C       LDA #$9C
.C:16de  8D 68 16    STA sprite_shape_8
.C:16e1  4C 0C 17    JMP update_sprites_0_to_3_positions
;--------------------------------------------------
set_sprite_shapes_set2:
;Set another particular set of shapes for the sprites
.C:16e4  A9 A0       LDA #$A0
.C:16e6  8D 61 16    STA sprite_shape_1
.C:16e9  A9 A4       LDA #$A4
.C:16eb  8D 62 16    STA sprite_shape_2
.C:16ee  A9 A8       LDA #$A8
.C:16f0  8D 63 16    STA sprite_shape_3
.C:16f3  A9 AC       LDA #$AC
.C:16f5  8D 64 16    STA sprite_shape_4
.C:16f8  A9 B0       LDA #$B0
.C:16fa  8D 65 16    STA sprite_shape_5
.C:16fd  A9 B4       LDA #$B4
.C:16ff  8D 66 16    STA sprite_shape_6
.C:1702  A9 B8       LDA #$B8
.C:1704  8D 67 16    STA sprite_shape_7
.C:1707  A9 BC       LDA #$BC
.C:1709  8D 68 16    STA sprite_shape_8
;--------------------------------------------------
update_sprites_0_to_3_positions:
;Update X positions lo
.C:170c  AD 60 FD    LDA actor_sprite_x_lo
.C:170f  8D CA 0F    STA sprite_0_x_lo
.C:1712  AD 61 FD    LDA actor_sprite_x_lo + 1
.C:1715  8D CB 0F    STA sprite_1_x_lo
.C:1718  AD 62 FD    LDA actor_sprite_x_lo + 2
.C:171b  8D CC 0F    STA sprite_2_x_lo
.C:171e  AD 63 FD    LDA actor_sprite_x_lo + 3
.C:1721  8D CD 0F    STA sprite_3_x_lo
;Update relative sprite indexes
.C:1724  AD 7C FD    LDA relative_sprite_for_actor
.C:1727  8D DA 0F    STA relative_sprite_0
.C:172a  AD 7D FD    LDA relative_sprite_for_actor + 1
.C:172d  8D DB 0F    STA relative_sprite_1
.C:1730  AD 7E FD    LDA relative_sprite_for_actor + 2
.C:1733  8D DC 0F    STA relative_sprite_2
.C:1736  AD 7F FD    LDA relative_sprite_for_actor + 3
.C:1739  8D DD 0F    STA relative_sprite_3
;Update X positions hi
.C:173c  AD 58 FD    LDA actor_sprite_x_hi
.C:173f  8D E1 0F    STA sprite_0_x_hi
.C:1742  AD 59 FD    LDA actor_sprite_x_hi + 1
.C:1745  8D E2 0F    STA sprite_1_x_hi
.C:1748  AD 5A FD    LDA actor_sprite_x_hi + 2
.C:174b  8D E3 0F    STA sprite_2_x_hi
.C:174e  AD 5B FD    LDA actor_sprite_x_hi + 3
.C:1751  8D E4 0F    STA sprite_3_x_hi
;--------------------------------------------------
;We switched sprite shapes, so clear this flag
.C:1754  A9 00       LDA #$00
.C:1756  8D 6A 16    STA sprite_shapes_set_to_use
prepare_next_frame_handler:
;Update all sprites' X hi byte and set up the next IRQ handler as irq_handler2
.C:1759  20 EF 0F    JSR update_sprites_x_hi_and_chain_handlers
.C:175c  58          CLI
;--------------------------------------------------
;Switch (video_memory_mode)
;
; #00	do nothing
; #01	set D800/C800/CBF8 as dot-date/video matrix/sprite shape base addresses
;			and copy color data
; #02	set D800/CC00/CFF8 as dot-date/video matrix/sprite shape base addresses
;			and copy color data
; #03	just copy color data
;--------------------------------------------------
.C:175d  A5 22       LDA video_memory_mode
.C:175f  F0 37       BEQ video_update_finished
.C:1761  C9 03       CMP #$03
.C:1763  D0 06       BNE check_01
;--------------------------------------------------
; video_memory_mode == #03
;--------------------------------------------------
case_03:
;Just copy color data, don't change base addresses
.C:1765  20 60 18    JSR copy_color_ram
.C:1768  4C 90 17    JMP video_memory_layout_complete
;--------------------------------------------------
check_01:
.C:176b  C9 01       CMP #$01
.C:176d  D0 12       BNE case_02
;--------------------------------------------------
; video_memory_mode == #01
;--------------------------------------------------
case_01:
;Set character dot-data base address: D800
;Set video matrix base address: C800
;Sprite shape data starts at CBF8
.C:176f  A9 26       LDA #$26
.C:1771  85 BE       STA vic_memory_layout
.C:1773  A9 F8       LDA #$F8
.C:1775  85 8C       STA <sprite_shape_data_ptr
.C:1777  A9 CB       LDA #$CB
.C:1779  85 8D       STA >sprite_shape_data_ptr
.C:177b  20 60 18    JSR copy_color_ram
.C:177e  4C 90 17    JMP video_memory_layout_complete
;--------------------------------------------------
; video_memory_mode == #02
;--------------------------------------------------
case_02:
;Set character dot-data base address: D800
;Set video matrix base address: CC00
;Sprite shape data starts at CFF8
.C:1781  A9 36       LDA #$36
.C:1783  85 BE       STA vic_memory_layout
.C:1785  A9 F8       LDA #$F8
.C:1787  85 8C       STA <sprite_shape_data_ptr
.C:1789  A9 CF       LDA #$CF
.C:178b  85 8D       STA >sprite_shape_data_ptr
.C:178d  20 60 18    JSR copy_color_ram
;--------------------------------------------------
video_memory_layout_complete:
;Copy the room's bkg color - not sure why this is done
.C:1790  A5 8F       LDA room_bkg_color_copy_0
.C:1792  85 90       STA room_bkg_color_copy_1
;Reset video_memory_mode to #00
.C:1794  A9 00       LDA #$00
.C:1796  85 22       STA video_memory_mode
;--------------------------------------------------
video_update_finished:
;Clear video update synchronization signal
.C:1798  A9 00       LDA #$00
.C:179a  85 8E       STA video_update_signal
;Enable new sound instructions processing, now that the video update has finished.
; The fact that new sound playback happens here means that 
; there might be a small delay of about a dozen interrupts
; from when a sound is loaded and ready to be played vs.
; when sound_update is enabled.
.C:179c  A9 01       LDA #$01
.C:179e  8D 71 FE    STA new_sound_instructions_allowed
;--------------------------------------------------
clear_video_processed_signal:
;Clear the video_processed signal (as the main code might be blocked waiting for it)
.C:17a1  A9 00       LDA #$00
.C:17a3  8D 6B 16    STA irq_handler1_video_processed_signal
;There's a kind of semaphore controlling access to the next part of the code
;This includes: message bar updates, paused scripts, cursor color change,
; keyboard scan, cursor show/hide, sound resource reload.
;
; If the semaphore is clear, continue and set it (thus disallowing reexecution)
; If it's set, skip the section and exit
.C:17a6  AD 78 16    LDA general_semaphore
.C:17a9  F0 03       BEQ section_entry
.C:17ab  4C 4B 18    JMP exit
;--------------------------------------------------
section_entry:
;Set the semaphore (thus disallowing reexecution)
.C:17ae  EE 78 16    INC general_semaphore
;Is the game paused?
.C:17b1  AD 79 16    LDA game_paused
;If the game is not paused (#00), then:
;
;	-update top bar messages
; 	-count down paused scripts
;	-change cursor color
;
;If the game is paused, skip these actions
.C:17b4  D0 25       BNE do_keyboard
.C:17b6  20 62 28    JSR print_message_on_top_bar
.C:17b9  20 64 60    JSR handle_paused_scripts
;--------------------------------------------------
; Cursor color change
;--------------------------------------------------
;Decrement cursor color wait counter
.C:17bc  CE 6D 16    DEC cursor_color_wait_counter
;If wait counter is still positive, don't change the cursor color
;If counter reached negative, reset it - and change the cursor color
.C:17bf  10 1A       BPL do_keyboard
.C:17c1  AD 6F 16    LDA cursor_color_wait_start
.C:17c4  8D 6D 16    STA cursor_color_wait_counter
;Switch to next cursor color index
.C:17c7  CE 6E 16    DEC cursor_color_index
;If we reached a negative color index, reset it 
;Otherwise, set the color
.C:17ca  10 06       BPL set_cursor_color
;Reset cursor color index to the first one
.C:17cc  AD 70 16    LDA first_cursor_color_index
.C:17cf  8D 6E 16    STA cursor_color_index
set_cursor_color:
;Set cursor color
.C:17d2  AE 6E 16    LDX cursor_color_index
.C:17d5  BD 71 16    LDA cursor_colors,X
.C:17d8  8D D9 0F    STA cursor_sprite_color
;--------------------------------------------------
do_keyboard:
.C:17db  20 62 20    JSR kbd_scan
;--------------------------------------------------
;map_in_io
.C:17de  A0 25       LDY #$25
.C:17e0  84 01       STY processor_port_register
.C:17e2  A9 00       LDA #$00
.C:17e4  8D 77 FD    STA room_scene_clicked
.C:17e7  AD 77 16    LDA color_ram_data_copied
.C:17ea  D0 24       BNE $1810
.C:17ec  AD A8 FE    LDA control_mode
.C:17ef  C9 00       CMP #$00
.C:17f1  F0 12       BEQ cutscene_mode
;--------------------------------------------------
;Not in a cutscene, so update the cursor and the interaction area
.C:17f3  20 16 F3    JSR handle_cursor_and_interaction_area
.C:17f6  20 BC F3    JSR $F3BC
.C:17f9  8D E8 0F    STA cursor_sprite_x_hi
.C:17fc  8E D1 0F    STX cursor_sprite_x_lo
.C:17ff  8C EB 0F    STY cursor_sprite_y
.C:1802  4C 10 18    JMP check_hide_cursor
;--------------------------------------------------
cutscene_mode:
;Move cursor off-screen to hide it
.C:1805  A9 00       LDA #$00
.C:1807  8D E8 0F    STA cursor_sprite_x_hi
.C:180a  8D D1 0F    STA cursor_sprite_x_lo
.C:180d  8D EB 0F    STA cursor_sprite_y
;--------------------------------------------------
check_hide_cursor:
;Cursor needs to be hidden?
.C:1810  AD 6C 16    LDA hide_cursor
.C:1813  F0 0B       BEQ $1820
;Yes - move cursor off-screen to hide it
.C:1815  A9 00       LDA #$00
.C:1817  8D E8 0F    STA cursor_sprite_x_hi
.C:181a  8D D1 0F    STA cursor_sprite_x_lo
.C:181d  8D EB 0F    STA cursor_sprite_y
;--------------------------------------------------
:
;???
.C:1820  AD 8E FE    LDA click_trigger_sentence
.C:1823  C9 01       CMP #$01
.C:1825  F0 06       BEQ handle_sound
.C:1827  AD 77 FD    LDA room_scene_clicked	
.C:182a  8D 8E FE    STA click_trigger_sentence
;--------------------------------------------------
handle_sound:
;map_in_io
.C:182d  A0 25       LDY #$25
.C:182f  84 01       STY processor_port_register
;Do we need to reload the sound resource address? If not, continue
.C:1831  AD 70 FE    LDA reload_snd_rsrc_ptrs
.C:1834  D0 12       BNE clear_semaphore
;Reload the current music pointers
.C:1836  AE A3 FE    LDX music_index
.C:1839  BD C5 78    LDA sound_rsrc_ptrs_hi,X
.C:183c  8D A1 FE    STA <music_to_start_ptr
.C:183f  BD 0B 79    LDA sound_rsrc_ptrs_lo,X
.C:1842  8D A2 FE    STA >music_to_start_ptr
;Call the sound IRQ handler
.C:1845  20 1B 48    JSR sound_irq_handler
;--------------------------------------------------
;Clear the semaphore to allow re-execution
clear_semaphore:
.C:1848  CE 78 16    DEC general_semaphore
;--------------------------------------------------
exit:
;Restore registers from stack
.C:184b  68          PLA
.C:184c  85 01       STA processor_port_register
.C:184e  68          PLA
.C:184f  A8          TAY
.C:1850  68          PLA
.C:1851  AA          TAX
.C:1852  68          PLA
.C:1853  40          RTI
;===========================================
copy_color_ram_wrapper:
;map_in_io
.C:1854  A0 25       LDY #$25
.C:1856  84 01       STY processor_port_register
.C:1858  20 60 18    JSR copy_color_ram
;map_out_io
.C:185b  A0 24       LDY #$24
.C:185d  84 01       STY processor_port_register
.C:185f  60          RTS
; End IRQ handler
;===========================================
; Memory copy to color RAM for room scene area
; 
; This is the range 6D89-7030 to D828-DACF
;
; This is done with 17 'parallel' copies of 40 bytes each (#27).
;
; As to why this is done in this manner, perhaps it's faster than using a 16-bit counter.
;===========================================
copy_color_ram:
.C:1860  A0 27       LDY #$27
loop:
.C:1862  B9 89 6D    LDA $6D89,Y
.C:1865  99 28 D8    STA $D828,Y
.C:1868  B9 B1 6D    LDA $6DB1,Y
.C:186b  99 50 D8    STA $D850,Y
.C:186e  B9 D9 6D    LDA $6DD9,Y
.C:1871  99 78 D8    STA $D878,Y
.C:1874  B9 01 6E    LDA $6E01,Y
.C:1877  99 A0 D8    STA $D8A0,Y
.C:187a  B9 29 6E    LDA $6E29,Y
.C:187d  99 C8 D8    STA $D8C8,Y
.C:1880  B9 51 6E    LDA $6E51,Y
.C:1883  99 F0 D8    STA $D8F0,Y
.C:1886  B9 79 6E    LDA $6E79,Y
.C:1889  99 18 D9    STA $D918,Y
.C:188c  B9 A1 6E    LDA $6EA1,Y
.C:188f  99 40 D9    STA $D940,Y
.C:1892  B9 C9 6E    LDA $6EC9,Y
.C:1895  99 68 D9    STA $D968,Y
.C:1898  B9 F1 6E    LDA $6EF1,Y
.C:189b  99 90 D9    STA $D990,Y
.C:189e  B9 19 6F    LDA $6F19,Y
.C:18a1  99 B8 D9    STA $D9B8,Y
.C:18a4  B9 41 6F    LDA $6F41,Y
.C:18a7  99 E0 D9    STA $D9E0,Y
.C:18aa  B9 69 6F    LDA $6F69,Y
.C:18ad  99 08 DA    STA $DA08,Y
.C:18b0  B9 91 6F    LDA $6F91,Y
.C:18b3  99 30 DA    STA $DA30,Y
.C:18b6  B9 B9 6F    LDA $6FB9,Y
.C:18b9  99 58 DA    STA $DA58,Y
.C:18bc  B9 E1 6F    LDA $6FE1,Y
.C:18bf  99 80 DA    STA $DA80,Y
.C:18c2  B9 09 70    LDA $7009,Y
.C:18c5  99 A8 DA    STA $DAA8,Y
.C:18c8  88          DEY
.C:18c9  10 97       BPL loop
;Use the flag to set that we already copied color RAM
.C:18cb  A9 01       LDA #$01
.C:18cd  8D 77 16    STA color_ram_data_copied
.C:18d0  60          RTS
;===========================================
pause_game:
;Change cursor to snail
.C:18d1  A9 C2       LDA #$C2
.C:18d3  8D 69 16    STA sprite_shape_cursor
;Mark game as paused
.C:18d6  A9 01       LDA #$01
.C:18d8  8D 79 16    STA game_paused
;Set cursor color to white
.C:18db  8D D9 0F    STA cursor_sprite_color
.C:18de  60          RTS
;===========================================
unpause_game:
;Change cursor to normal (arrow-cross)
.C:18df  A9 C1       LDA #$C1
.C:18e1  8D 69 16    STA sprite_shape_cursor
;Mark game as unpaused
.C:18e4  A9 00       LDA #$00
.C:18e6  8D 79 16    STA game_paused
.C:18e9  60          RTS
;===========================================
;NMI handler - return immediately
;===========================================
.C:18ea  40          RTI
;===========================================
; Build a path of connected walkboxes to the destination walkbox for this actor
;
; Arguments:	current_box_for_actor
;				destination_box_for_actor
;===========================================
box_data_ptr = $17
adjacent_boxes_ptr = $7c
destination_box = $cad1
current_box = $cad3
current_search_depth = $cad8
return_value = $cad0

build_path_to_destination_walkbox:
.C:18eb  A6 D8       LDX actor
;Get the pointer to the start of the boundary boxes list
.C:18ed  20 B1 2D    JSR get_walkboxes_for_costume
;Subtract 2 to point to the adjacency list offset
.C:18f0  A5 18       LDA >box_data_ptr
.C:18f2  85 7D       STA >adjacent_boxes_ptr
.C:18f4  A5 17       LDA <box_data_ptr
.C:18f6  38          SEC
.C:18f7  E9 02       SBC #$02
.C:18f9  85 7C       STA <adjacent_boxes_ptr
.C:18fb  B0 02       BCS ptr_set
.C:18fd  C6 7D       DEC >adjacent_boxes_ptr
ptr_set:
;Read the offset from pointer and add it to the _current_ pointer
;The result will set adjacent_boxes_ptr at the beginning of the adjacency list
.C:18ff  A0 00       LDY #$00
.C:1901  18          CLC
.C:1902  71 7C       ADC (adjacent_boxes_ptr),Y
.C:1904  85 7C       STA <adjacent_boxes_ptr
.C:1906  90 02       BCC init_search
.C:1908  E6 7D       INC >adjacent_boxes_ptr
;-----------------------------------------------
init_search:
;Initialize search depth
.C:190a  A9 00       LDA #$00
.C:190c  8D D8 CA    STA current_search_depth
;Initialize return value
.C:190f  A9 FF       LDA #$FF
.C:1911  8D D0 CA    STA return_value
.C:1914  BD CD FD    LDA current_box_for_actor,X
.C:1917  8D D3 CA    STA current_box
.C:191a  BD D5 FD    LDA destination_box_for_actor,X
.C:191d  8D D1 CA    STA destination_box
;-----------------------------------------------
next_iteration:
;Advance depth by 1, if possible
.C:1920  20 5F 19    JSR advance_depth
;Was the advance successful?
.C:1923  C9 00       CMP #$00
;If not, return #02
.C:1925  D0 30       BNE break_return_02
;Is the destination box adjacent?
.C:1927  20 9E 19    JSR is_destination_box_adjacent
.C:192a  C9 00       CMP #$00
.C:192c  D0 0C       BNE destination_not_adjacent
;-----------------------------------------------
;The destination box is adjacent - copy boxes and return #00
.C:192e  20 08 1A    JSR copy_boxes
.C:1931  A9 00       LDA #$00
.C:1933  8D D0 CA    STA return_value
.C:1936  60          RTS
;.C:1937  4C 52 19    JMP $1952	;Unreachable code
;-----------------------------------------------
destination_not_adjacent:
.C:193a  20 B6 19    JSR are_adjacents_known
;Are all adjacent boxes known? (#FF = True, #00 = False)
.C:193d  C9 FF       CMP #$FF
;If not, Z will be clear and we'll continue at force_next_iteration
.C:193f  D0 0F       BNE continue_if_Z_clear
;-----------------------------------------------
;All adjacents are known - try to backtrack
.C:1941  20 7D 19    JSR backtrack
;Was the backtrack successful?
.C:1944  C9 FF       CMP #$FF
.C:1946  D0 06       BNE backtrack_successful
;-----------------------------------------------
;Backtrack not possible - set return_value to #01 and exit
;This signals that we exhausted the whole graph (backtracking not possible)
.C:1948  A9 01       LDA #$01
.C:194a  8D D0 CA    STA return_value
.C:194d  60          RTS
;-----------------------------------------------
backtrack_successful:
;Set .A to #00 so we can check adjacents again after backtracking
.C:194e  A9 00       LDA #$00
continue_if_Z_clear:
.C:1950  F0 E8       BEQ destination_not_adjacent
force_next_iteration:
;Set .A = #00 to force a next iteration
.C:1952  A9 00       LDA #$00
.C:1954  4C 5C 19    JMP check_next_iteration
;-----------------------------------------------
break_return_02:
;Set .A = #02 to break the loop
;This signals that we exhausted the search forward (maximum depth)
.C:1957  A9 02       LDA #$02
.C:1959  8D D0 CA    STA return_value
check_next_iteration:
;Do next iteration if .A == #00
.C:195c  F0 C2       BEQ next_iteration
.C:195e  60          RTS
;===========================================
current_box = $cad3
boxes_discovered_for_actor = $cad9

advance_depth:
;Is current_search_depth #10? If so, we can't search anymore
.C:195f  AD D8 CA    LDA current_search_depth
.C:1962  C9 10       CMP #$10
.C:1964  D0 03       BNE do_increment
;-----------------------------------------------
;If so, return #FF
.C:1966  A9 FF       LDA #$FF
.C:1968  60          RTS
;-----------------------------------------------
do_increment:
.C:1969  EE D8 CA    INC current_search_depth
.C:196c  AC D8 CA    LDY current_search_depth
;Set the current box as the box discovered at this depth
.C:196f  AD D3 CA    LDA current_box
.C:1972  99 D9 CA    STA boxes_discovered_for_actor,Y
;Set the last index for this list element to #FF, 
;which will get incremented to #00 in the first search analysis
.C:1975  A9 FF       LDA #$FF
.C:1977  99 29 CB    STA last_index_for_list_element,Y
;Return #00 to signal we advanced successfully
.C:197a  A9 00       LDA #$00
.C:197c  60          RTS
;===========================================
; Backtrack the box search
;
; Return:	.A		#FF				if backtrack not possible
;					anything else	if backtrack was successful
;===========================================
backtrack:
;Is current_search_depth #01? If so, we can't backtrack anymore
.C:197d  AD D8 CA    LDA current_search_depth
.C:1980  C9 01       CMP #$01
.C:1982  D0 03       BNE do_backtrack
;-----------------------------------------------
;If so, return #FF
.C:1984  A9 FF       LDA #$FF
.C:1986  60          RTS
;-----------------------------------------------
do_backtrack:
;Backtrack is possible, decrement the iteration counter
;Return the count (which is not #FF) to signal we backtracked successfully
.C:1987  CE D8 CA    DEC current_search_depth
.C:198a  60          RTS
;===========================================
; Set up an adjacency list, given a current search depth
;
; Arguments:	current_search_depth
; Returns:		start_index_for_list_element
;				target_offset
;	
; This takes into consideration adjacency lists that were
; already traversed, to resume the search exactly from the previous point.
; This allows doing backtracking correctly.
;===========================================
start_index_for_list_element = $cad2
target_element_index = $cad3
target_offset = $cad7

setup_adjacency_list:
;Get the last box index discovered
.C:198b  AC D8 CA    LDY current_search_depth
.C:198e  B9 D9 CA    LDA boxes_discovered_for_actor,Y
;Set it as the target index to find in the list
.C:1991  8D D3 CA    STA target_element_index
;Load the last index analyzed for this list element
;and set it as the start index (to resume the search from that point,
; in case we're backtracking)
.C:1994  B9 29 CB    LDA last_index_for_list_element,Y
.C:1997  8D D2 CA    STA start_index_for_list_element
;Compute the starting offset for this list element (into target_offset)
.C:199a  20 37 1A    JSR get_offset_for_list_element
.C:199d  60          RTS
;===========================================
; Returns whether the destination box is in the adjacency list of the current box
;
; Returns:	.A		#00 if the destination box is adjacent
;					#FF if not
;===========================================
adjacent_boxes_ptr = $7c
destination_box = $cad1
target_offset = $cad7

is_destination_box_adjacent:
.C:199e  20 8B 19    JSR setup_adjacency_list
.C:19a1  A6 D8       LDX actor
;Load the list offset into .Y
.C:19a3  AC D7 CA    LDY target_offset
check_box_index:
;Load an adjacent box index
.C:19a6  B1 7C       LDA (adjacent_boxes_ptr),Y
;Does it match the destination box?
.C:19a8  CD D1 CA    CMP destination_box
;If not, continue with the next adjacent index
.C:19ab  D0 03       BNE next_box_index
;It matches, return #00
.C:19ad  A9 00       LDA #$00
.C:19af  60          RTS
next_box_index:
.C:19b0  C8          INY
;Did we reach the end of the list element? (#FF)
.C:19b1  C9 FF       CMP #$FF
;If not, check the next box index
.C:19b3  D0 F1       BNE check_box_index
;Otherwise, return #FF
.C:19b5  60          RTS
;===========================================
; Returns whether the adjacent boxes have been all discovered before or not.
;
; 
; Returns:	.A		#00		if at least one box has not been discovered before
;					#FF		if all boxes have already been discovered
;===========================================
adjacent_boxes_ptr = $7c
target_offset = $cad7
list_offset = $fc3b
start_index_for_list_element = $cad2

are_adjacents_known:
.C:19b6  AE D8 CA    LDX current_search_depth
.C:19b9  20 8B 19    JSR setup_adjacency_list
;Add the starting index to the target_offset 
; to resume the search from the exact previous point in this list element
.C:19bc  AD D2 CA    LDA start_index_for_list_element
.C:19bf  18          CLC
.C:19c0  6D D7 CA    ADC target_offset
.C:19c3  A8          TAY
.C:19c4  8C 3B FC    STY list_offset
next_box:
;Increment the last index for this element (so we can later resume correctly, if needed)
.C:19c7  FE 29 CB    INC last_index_for_list_element,X
;Increment the offset
.C:19ca  EE 3B FC    INC list_offset
;Read one adjacent box index
.C:19cd  AC 3B FC    LDY list_offset
.C:19d0  B1 7C       LDA (adjacent_boxes_ptr),Y
;Check if it's the end of element value (#FF)
.C:19d2  C9 FF       CMP #$FF
;If not, process the box
.C:19d4  D0 06       BNE process_box
;-----------------------------------------------
;End of list element found
;Return #FF signaling that we have exhausted the boxes and all are known
.C:19d6  A9 FF       LDA #$FF
.C:19d8  60          RTS
;.C:19d9  4C E8 19    JMP $19E8 ;Unreachable code
;-----------------------------------------------
process_box:
;Set the adjacent box as current box
.C:19dc  8D D3 CA    STA current_box
;Has it been seen before? (#FF = False, #00 = True)
.C:19df  20 EB 19    JSR has_current_box_been_seen
.C:19e2  C9 FF       CMP #$FF
;----------------------------------------------
; Box already seen
;----------------------------------------------
;If True, .A == #00
;If we did CMP #$FF, #00 != #FF, so the Z flag will be set to 0
;With Z = 0, BNE branches will be taken
.C:19e4  D0 02       BNE continue_if_Z_clear
;----------------------------------------------
; Box not seen
;----------------------------------------------
;Set .A to #00, so the Z flag is set to 1
;With Z = 1, BNE branches will not be taken
;This will have the net effect of returning #00
.C:19e6  A9 00       LDA #$00
continue_if_Z_clear:
;If result was True, continue at next_box - otherwise, return #00
.C:19e8  D0 DD       BNE next_box
.C:19ea  60          RTS
;===========================================
; Returns whether the current box has already been seen or not
;
; Arguments:		current_box
;					current_search_depth
;
; Returns:	.A		#00	if it has been seen
;					#FF if not
;===========================================
current_box = $cad3
max_count = $fc3d

has_current_box_been_seen:
;We'll scan the boxes_discovered_for_actor list up to the current depth + 1
.C:19eb  AC D8 CA    LDY current_search_depth
.C:19ee  C8          INY
;Set the top counter in max_count
.C:19ef  8C 3D FC    STY max_count
;-------------------------------------------
;Use .Y as iteration counter, start from #01, go upwards
.C:19f2  A0 01       LDY #$01
check_box:
;Is current box == boxes_discovered_for_actor?
.C:19f4  B9 D9 CA    LDA boxes_discovered_for_actor,Y
.C:19f7  CD D3 CA    CMP current_box
.C:19fa  D0 03       BNE next_box
;If so, return #00
.C:19fc  A9 00       LDA #$00
.C:19fe  60          RTS
;-------------------------------------------
next_box:
;Have we reached the max count? If not, continue
.C:19ff  C8          INY
.C:1a00  CC 3D FC    CPY max_count
.C:1a03  D0 EF       BNE check_box
;Otherwise, return #FF
.C:1a05  A9 FF       LDA #$FF
.C:1a07  60          RTS
;===========================================
; Copy the path of adjacent boxes that leads to the final walkbox for this actor
;
; Arguments:	actor
;===========================================
destination_box = $cad1

copy_boxes:
;Set .Y = actor * 16 + 16 (#10)
;Equivalently, .Y = 16 * (actor + 1)
.C:1a08  A6 D8       LDX actor
.C:1a0a  8A          TXA
.C:1a0b  0A          ASL A
.C:1a0c  0A          ASL A
.C:1a0d  0A          ASL A
.C:1a0e  0A          ASL A
.C:1a0f  18          CLC
.C:1a10  69 10       ADC #$10
.C:1a12  A8          TAY
;Save the current search depth - 1 for this actor
.C:1a13  AD D8 CA    LDA current_search_depth
.C:1a16  9D 75 FE    STA box_search_depth_for_actor,X
.C:1a19  DE 75 FE    DEC box_search_depth_for_actor,X
;Save the destination box as the last element of the discovered boxes list
.C:1a1c  AD D1 CA    LDA destination_box
.C:1a1f  99 D9 CA    STA boxes_discovered_for_actor,Y
.C:1a22  C8          INY
;Did we finalize the search at a depth of 1? 
.C:1a23  AE D8 CA    LDX current_search_depth
.C:1a26  E0 01       CPX #$01
;If so, we already found the destination box - exit
.C:1a28  F0 0C       BEQ exit
copy_next:
;Depth is not 1 - so we are not at the destination box yet
;Copy the list of boxes in reverse order to build the path properly
.C:1a2a  BD D9 CA    LDA boxes_discovered_for_actor,X
.C:1a2d  99 D9 CA    STA boxes_discovered_for_actor,Y
.C:1a30  C8          INY
.C:1a31  CA          DEX
.C:1a32  E0 01       CPX #$01
.C:1a34  D0 F4       BNE copy_next
exit:
.C:1a36  60          RTS
;===========================================
; Find the offset for a given target index
;
; Arguments:	target_element_index
; Returns:		target_offset
;===========================================
adjacents_list_ptr = $7c
element_index = $fc3d
target_element_index = $cad3
target_offset = $cad7

get_offset_for_list_element:
;Use element_index to count the list elements
.C:1a37  A0 00       LDY #$00
.C:1a39  8C 3D FC    STY element_index
;Is there a non-zero target index? If so, start reading
.C:1a3c  AD D3 CA    LDA target_element_index
.C:1a3f  D0 04       BNE read_next_byte
;Otherwise, return #00 as offset
.C:1a41  8D D7 CA    STA target_offset
.C:1a44  60          RTS
read_next_byte:
;Read a byte, advance .Y offset
.C:1a45  B1 7C       LDA (adjacents_list_ptr),Y
.C:1a47  C8          INY
;Is it #FF? This marks the end of an element
.C:1a48  C9 FF       CMP #$FF
;If not, continue reading
.C:1a4a  D0 F9       BNE read_next_byte
;It's #FF - end of an element
;Increment the element counter
.C:1a4c  EE 3D FC    INC element_index
;Is it the target element index we want?
.C:1a4f  AD 3D FC    LDA element_index
.C:1a52  CD D3 CA    CMP target_element_index
;If not, continue reading
.C:1a55  D0 EE       BNE read_next_byte
;It is, return the target offset
.C:1a57  8C D7 CA    STY target_offset
.C:1a5a  60          RTS
;===========================================
; Adjust an actor's destination based on walk boxes
;===========================================
adjust_actor_destination:
;Get the current actor's destination coordinates
;Save them as the coordinates to check for adjustment
.C:1a68  A6 D8       LDX actor
.C:1a6a  BD D9 FD    LDA destination_x_for_actor,X
.C:1a6d  8D 72 FE    STA box_check_x
.C:1a70  BD DD FD    LDA destination_y_for_actor,X
.C:1a73  8D 73 FE    STA box_check_y
;Get the current actor's room, set it as the walkbox room
.C:1a76  AE 30 FC    LDX active_costume
.C:1a79  BD FC FE    LDA room_for_character,X
.C:1a7c  8D 74 FE    STA walkbox_room
;Adjust coordinates as needed
.C:1a7f  20 9B 1A    JSR adjust_coords_by_walkbox
;Did we need adjustment?
.C:1a82  C9 FF       CMP #$FF
.C:1a84  D0 01       BNE adjustment_needed
;If not, exit
.C:1a86  60          RTS
adjustment_needed:
;Adjustment needed - get the adjusted coordinates (in box_check_x/y and set them as the new destination)
.C:1a87  AE 30 FC    LDX active_costume
.C:1a8a  BD 57 FE    LDA actor_for_costume,X
.C:1a8d  AA          TAX
.C:1a8e  AD 72 FE    LDA box_check_x
.C:1a91  9D D9 FD    STA destination_x_for_actor,X
.C:1a94  AD 73 FE    LDA box_check_y
.C:1a97  9D DD FD    STA destination_y_for_actor,X
.C:1a9a  60          RTS
;===========================================
; Adjust coordinates according to walk boxes
; 
; Arguments:	None
; Returns:		box_check_x
;				box_check_y
;				.A		closest box index
;===========================================
min_x_closest = $1a62
min_y_closest = $1a63
box_check_x = $fe72
box_check_y = $fe73

adjust_coords_by_walkbox:
;Save registers .X and .Y in stack
.C:1a9b  8A          TXA
.C:1a9c  48          PHA
.C:1a9d  98          TYA
.C:1a9e  48          PHA
;Get the closest walkbox
.C:1a9f  20 C1 1A    JSR get_closest_box
;Did we find one? 
.C:1aa2  AD AC FD    LDA closest_box_index
.C:1aa5  C9 FF       CMP #$FF
;If not, exit
.C:1aa7  D0 01       BNE closest_found
;BUG - original return address not in stack, so it will crash on return
.C:1aa9  60          RTS
closest_found:
;Adjust coordinates if hitting a diagonal slope of a boundary
.C:1aaa  AD 62 1A    LDA min_x_closest
.C:1aad  8D 72 FE    STA box_check_x
.C:1ab0  AD 63 1A    LDA min_y_closest
.C:1ab3  8D 73 FE    STA box_check_y
.C:1ab6  20 91 1B    JSR adjust_diagonal_boundary
;Restore registers from stack
.C:1ab9  68          PLA
.C:1aba  A8          TAY
.C:1abb  68          PLA
.C:1abc  AA          TAX
.C:1abd  AD AC FD    LDA closest_box_index
.C:1ac0  60          RTS
;===========================================
; Find the closest walkbox to a set of coordinates (X, Y)
;
; Arguments:	walkbox_room		room to check in
;				box_check_x		X coordinate to check
;				box_check_y		Y coordinate to check
;
; Returns:		.A		#FF	if no boxes found
;				closest_box_index	index of walkbox that's closest
;				min_x_closest		closest X coordinate
;				min_y_closest		closest Y coordinate
;				min_distance		closest distance
;===========================================
room_data_ptr = $17
box_left = $1a64
box_right = $1a65
box_top = $1a66
box_bottom = $1a67
box_index = $1a5b
x_closest = $1a60
y_closest = $1a61
min_distance = $1a5e
min_x_closest = $1a62
min_y_closest = $1a63

get_closest_box:
;Get the boxes for the room
.C:1ac1  20 A3 2D    JSR get_walkboxes_for_room
;Are there any boxes?
.C:1ac4  C9 FF       CMP #$FF
.C:1ac6  D0 04       BNE boxes_present
;If not, return #FF
.C:1ac8  8D AC FD    STA closest_box_index
.C:1acb  60          RTS
boxes_present:
;Initialize the minimum distance to #FF
.C:1acc  A9 FF       LDA #$FF
.C:1ace  8D 5E 1A    STA min_distance
;Initialize the box index to #FF
.C:1ad1  A9 FF       LDA #$FF
.C:1ad3  8D 5B 1A    STA box_index
;------------------------------
.C:1ad6  A0 00       LDY #$00
check_box_present:
.C:1ad8  EE 5B 1A    INC box_index
;Check if we reached the end of the list of boxes (#FF)
.C:1adb  B1 17       LDA (room_data_ptr),Y
.C:1add  C9 FF       CMP #$FF
;If so, exit - otherwise, continue
.C:1adf  D0 01       BNE box_present
.C:1ae1  60          RTS
;------------------------------
box_present:
;Load walkbox edges
.C:1ae2  B1 17       LDA (room_data_ptr),Y
.C:1ae4  8D 64 1A    STA box_left
.C:1ae7  C8          INY
.C:1ae8  B1 17       LDA (room_data_ptr),Y
.C:1aea  8D 65 1A    STA box_right
.C:1aed  C8          INY
.C:1aee  B1 17       LDA (room_data_ptr),Y
.C:1af0  8D 66 1A    STA box_top
.C:1af3  C8          INY
.C:1af4  B1 17       LDA (room_data_ptr),Y
.C:1af6  8D 67 1A    STA box_bottom
.C:1af9  C8          INY
.C:1afa  C8          INY
;Compute distance to box
.C:1afb  20 1B 1B    JSR get_distance_to_box
;Is it closer than the minimum distance?
.C:1afe  CD 5E 1A    CMP min_distance
;If not, continue
.C:1b01  B0 15       BCS next_box
;------------------------------
;This box is closer 
;Save the distance, box index and closest coordinates
.C:1b03  8D 5E 1A    STA min_distance
.C:1b06  AD 5B 1A    LDA box_index
.C:1b09  8D AC FD    STA closest_box_index
.C:1b0c  AD 60 1A    LDA x_closest
.C:1b0f  8D 62 1A    STA min_x_closest
.C:1b12  AD 61 1A    LDA y_closest
.C:1b15  8D 63 1A    STA min_y_closest
next_box:
.C:1b18  4C D8 1A    JMP check_box_present
;===========================================
; Compute the shortest distance to a walkbox
;
; Arguments:		box_check_x
;					box_check_y
;					box_left
;					box_right
;					box_bottom
;					box_top
;	
; Returns:			.A		distance
;					x_closest
;					y_closest
;
; The walkbox is described by the coordinates of its four edges (left, right, top and bottom).
;
; The algorithm checks first if the horizontal coordinate (box_check_x)
; is outside or inside the box, by comparing against the left and right edges. 
;
; If it's outside, it selects the left or right edge accordingly as the closest coordinate.
; If it's inside, it selects the original coordinate (box_check_x) as the closest coordinate.
; The same logic is used for the vertical coordinates and edges.
;
; Once each of the two closest coordinates is determined, the distance between
; the closest coordinate and the original coordinate is computed.
; This is done with: |closest_coordinate - original_coordinate| (the absolute value).
;
; Finally, the two distances (X distance and Y distance) are compared.
; The scales of the horizontal and vertical axis are not
; identical, so distances are normalized before being compared.
;
; If x_distance > y_distance, then x_distance/2 + y_distance is returned.
; Otherwise, y_distance/2 + x_distance is returned.
;
; If a position is fully inside a box, the distance returned would be zero.
;===========================================
box_left = $1a64
box_right = $1a65
box_top = $1a66
box_bottom = $1a67
x_closest = $1a60
y_closest = $1a61
x_distance = $1a5c
y_distance = $1a5d

get_distance_to_box:
;---------------------------------------
;box_check_x <= box_right?
.C:1b1b  AD 72 FE    LDA box_check_x
.C:1b1e  CD 65 1A    CMP box_right
.C:1b21  90 08       BCC x_le_right
.C:1b23  F0 06       BEQ x_le_right
;---------------------------------------
; box_check_x > box_right -> so the X coordinate is outside the box and to the right of it
; Set box_right as closest X edge
.C:1b25  AD 65 1A    LDA box_right
.C:1b28  4C 33 1B    JMP set_x_closest
;---------------------------------------
x_le_right:
;box_check_x <= box_right - so the X coordinate is to the left of the right edge
;Now check if we're to the left of box_left (that is, are we inside or outside the box?)
;box_check_x >= box_left? -> if so, we're inside the box - then set box_x_check as closest X edge
.C:1b2b  CD 64 1A    CMP box_left
.C:1b2e  B0 03       BCS set_x_closest
;We're outside the box and to the left, set box_left as closest X edge
.C:1b30  AD 64 1A    LDA box_left
;---------------------------------------
set_x_closest:
.C:1b33  8D 60 1A    STA x_closest
;---------------------------------------
;Repeat the same logic with the Y coordinates and edges
;box_check_y <= box_bottom?
.C:1b36  AD 73 FE    LDA box_check_y
.C:1b39  CD 67 1A    CMP box_bottom
.C:1b3c  90 08       BCC y_le_top
.C:1b3e  F0 06       BEQ y_le_top
;---------------------------------------
; box_check_y > box_bottom -> so the Y coordinate is outside the box and below it
; Set box_bottom as closest Y edge
.C:1b40  AD 67 1A    LDA box_bottom
.C:1b43  4C 4E 1B    JMP set_y_closest
;---------------------------------------
y_le_top:
;box_check_y <= box_bottom - so the Y coordinate is above the bottom edge
;Now check if we're above box_top (that is, are we inside or outside the box?)
;box_check_y >= box_top? -> if so, we're inside the box - then set box_y_check as closest Y edge
.C:1b46  CD 66 1A    CMP box_top
.C:1b49  B0 03       BCS set_y_closest
;We're outside the box and above, set box_top as closest Y edge
.C:1b4b  AD 66 1A    LDA box_top
;---------------------------------------
set_y_closest:
.C:1b4e  8D 61 1A    STA y_closest
;---------------------------------------
;Compute distance between box_check_x and x_closest
.C:1b51  AD 72 FE    LDA box_check_x
.C:1b54  38          SEC
.C:1b55  ED 60 1A    SBC x_closest
;If negative, make it positive (compute the absolute value)
.C:1b58  B0 05       BCS set_x_distance
.C:1b5a  49 FF       EOR #$FF
.C:1b5c  18          CLC
.C:1b5d  69 01       ADC #$01
set_x_distance:
;Normalize distance
.C:1b5f  0A          ASL A
.C:1b60  8D 5C 1A    STA x_distance
;---------------------------------------
;Compute distance between box_check_y and y_closest
.C:1b63  AD 73 FE    LDA box_check_y
.C:1b66  38          SEC
.C:1b67  ED 61 1A    SBC y_closest
;If negative, make it positive (compute the absolute value)
.C:1b6a  B0 05       BCS set_y_distance
.C:1b6c  49 FF       EOR #$FF
.C:1b6e  18          CLC
.C:1b6f  69 01       ADC #$01
set_y_distance:
;Normalize distance
.C:1b71  4A          LSR A
.C:1b72  4A          LSR A
.C:1b73  8D 5D 1A    STA y_distance
;---------------------------------------
;Compare x_distance with y_distance
.C:1b76  CD 5C 1A    CMP x_distance
.C:1b79  90 0D       BCC y_distance_le_x_distance
.C:1b7b  F0 0B       BEQ y_distance_le_x_distance
distance_gt:
;x_distance > y_distance
;Return x_distance/2 + y_distance
.C:1b7d  AD 5C 1A    LDA x_distance
.C:1b80  4A          LSR A
.C:1b81  18          CLC
.C:1b82  6D 5D 1A    ADC y_distance
.C:1b85  4C 90 1B    JMP exit
y_distance_le_x_distance:
;x_distance <= y_distance
;Return y_distance/2 + x_distance
.C:1b88  AD 5D 1A    LDA y_distance
.C:1b8b  4A          LSR A
.C:1b8c  18          CLC
.C:1b8d  6D 5C 1A    ADC x_distance
exit:
.C:1b90  60          RTS
;===========================================
; Adjust coordinates if the walkbox has a diagonal edge
;
; This happens mostly on walled room edges.
; The walkbox has an attribute byte (offset #05) that encodes,
; among other things, whether one of the edges is diagonal or not,
; and if so, on which side (left or right).
;
; If the walkbox does have a diagonal edge, the necessary
; adjustments are made, using hardcoded diagonal offsets.
; The distance between the target coordinate and the top edge
; is computed, and the final coordinate is adjusted based on it.
;===========================================
room_data_ptr = $17
diagonal_edge_offset = $1c09

box_attribute = $fc3d
adjust_diagonal_boundary:
.C:1b91  A9 00       LDA #$00
.C:1b93  8D 39 CB    STA $CB39
;---------------------------------------
;Get the index of the closest box
.C:1b96  AD AC FD    LDA closest_box_index
;Get the current box offset in .Y
.C:1b99  20 D0 30    JSR get_walkbox_offset
;Add 4 to the offset, use .Y as box data offset
.C:1b9c  98          TYA
.C:1b9d  18          CLC
.C:1b9e  69 04       ADC #$04
.C:1ba0  A8          TAY
;Load the attribute byte (offset #04) of the walkbox data
.C:1ba1  B1 17       LDA (room_data_ptr),Y
;Is bit 7 clear? If so, exit
.C:1ba3  30 01       BMI bit7_set
.C:1ba5  60          RTS
;---------------------------------------
bit7_set:
;Mask bits 6-2 (although we will only test bits 2 and 3)
.C:1ba6  29 7C       AND #$7C
;Are bits 2 and 3 set?
.C:1ba8  C9 0C       CMP #$0C
.C:1baa  D0 05       BNE check_08
;---------------------------------------
;Bits 2 and 3 set - set box_attribute as #02
;This is a downward diagonal slope - as on the right edge of a walled room
;The wall visible on the right side is drawn "sloping down" to the right
case_0C:
.C:1bac  A9 02       LDA #$02
.C:1bae  4C BB 1B    JMP set_box_attribute
;---------------------------------------
check_08:
;Is bit 3 set?
.C:1bb1  C9 08       CMP #$08
.C:1bb3  D0 05       BNE exit
;---------------------------------------
case_08:
;Bit 3 set - set box_attribute as #01
;This is an upward diagonal slope - as on the left edge of a walled room
;The wall visible on the left side is drawn "sloping up" to the right
.C:1bb5  A9 01       LDA #$01
.C:1bb7  4C BB 1B    JMP set_box_attribute
;---------------------------------------
exit:
.C:1bba  60          RTS
;---------------------------------------
set_box_attribute:
.C:1bbb  8D 3D FC    STA box_attribute
;--------------------------------------------
;Load Y coordinate
.C:1bbe  AD 73 FE    LDA box_check_y
;Point to the top edge of the box (offset #02)
.C:1bc1  88          DEY
.C:1bc2  88          DEY
;Compute the vertical distance between the coordinate and the box top edge: .X = box_check_y - top_edge
;This vertical distance will be used to compute the horizontal component of the slope
.C:1bc3  38          SEC
.C:1bc4  F1 17       SBC (room_data_ptr),Y
.C:1bc6  AA          TAX
;Point to the right edge of the box (offset #01)
.C:1bc7  88          DEY
;Jump according to the slope direction
.C:1bc8  AD 3D FC    LDA box_attribute
.C:1bcb  C9 01       CMP #$01
.C:1bcd  D0 1E       BNE downward_slope
;--------------------------------------------
upward_slope:
;Use the vertical distance previously computed in .X to find the "diagonal edge offset"
;With it, compute the sloped right edge: right_edge - diagonal_edge_offset
.C:1bcf  B1 17       LDA (room_data_ptr),Y
.C:1bd1  38          SEC
.C:1bd2  FD 09 1C    SBC diagonal_edge_offset,X
;Is the adjusted result < box_check_x?
.C:1bd5  CD 72 FE    CMP box_check_x
.C:1bd8  B0 05       BCS compare_a0
;If so, don't adjust the coordinate
;Return #00 (but because of a possible bug, #01 will be returned)
.C:1bda  A9 00       LDA #$00
.C:1bdc  4C 03 1C    JMP exit_2
;--------------------------------------------
compare_a0:
;Is the adjusted result <= #A0? (could this be a maximum room width?)
;If so, adjust - set box_check_x to the adjusted value
;Otherwise, set box_check_x to #00
.C:1bdf  C9 A0       CMP #$A0
.C:1be1  90 04       BCC set_x
.C:1be3  F0 02       BEQ set_x
.C:1be5  A9 00       LDA #$00
set_x:
.C:1be7  8D 72 FE    STA box_check_x
.C:1bea  4C 03 1C    JMP exit_2
;--------------------------------------------
downward_slope:
;Point to box data offset #00 (left edge) in .Y
.C:1bed  88          DEY
;Adjust left_edge with diagonal_edge_offset (like an upward slope)
.C:1bee  B1 17       LDA (room_data_ptr),Y
.C:1bf0  18          CLC
.C:1bf1  7D 09 1C    ADC diagonal_edge_offset,X
;Is the adjusted result <= box_check_x?
;If so, adjust the result
.C:1bf4  CD 72 FE    CMP box_check_x
.C:1bf7  90 07       BCC set_x_2
.C:1bf9  F0 05       BEQ set_x_2
;Otherwise, don't adjust, return #00 (possible bug - will return #01 instead)
.C:1bfb  A9 00       LDA #$00
.C:1bfd  4C 03 1C    JMP exit_2
set_x_2:
;Otherwise, adjust - set box_check_x to the adjusted value and exit
.C:1c00  8D 72 FE    STA box_check_x
exit_2:
;Possible bug - most of the JMPs to this address occur after doing LDA #$00
; which gets overwritten with a #01. It's likely the original intention was to JMP to the next address.
.C:1c03  A9 01       LDA #$01
.C:1c05  8D 39 CB    STA $CB39
.C:1c08  60          RTS
;===========================================
.C:1c09 
diagonal_edge_offset: 
00 01 02 03 03 
04 05 06 06 07 
08 09 09 0A 0B 
0C 0C 0D 0E 0F 
10 10
;===========================================
; Walk actor to a destination
;
;===========================================
walk_actor_to_destination:
.C:1c1f  AE 30 FC    LDX active_costume
.C:1c22  BD 57 FE    LDA actor_for_costume,X
.C:1c25  10 0D       BPL actor_onscreen
actor_offscreen:
;Actor is offscreen, so just set the destination coordinates directly (no need for path finding now)
.C:1c27  AD E6 FD    LDA x_destination
.C:1c2a  9D 2E FF    STA costume_x_destination,X
.C:1c2d  AD E7 FD    LDA y_destination
.C:1c30  9D 15 FF    STA costume_y_destination,X
.C:1c33  60          RTS
actor_onscreen:
;Actor is onscreen
;Adjust the destination coordinates according to the walk boxes
.C:1c34  AA          TAX
.C:1c35  86 D8       STX actor
.C:1c37  20 9B 1A    JSR adjust_coords_by_walkbox
.C:1c3a  AD E6 FD    LDA x_destination
.C:1c3d  9D D9 FD    STA destination_x_for_actor,X
.C:1c40  AD E7 FD    LDA y_destination
.C:1c43  9D DD FD    STA destination_y_for_actor,X
;Build the walkbox path
.C:1c46  4C 4A 1C    JMP build_path_to_destination
;.C:1c49  60          RTS	;Unreachable code
;===========================================
; Build a path to a destination coordinate for an actor
;
; This routine will:
;	-adjust the destination coordinate using the walkboxes
;	-if no closest box to the destination coordinates could be found, exit
;	-save the closest box as the new destination box
;	-if the closest box is new, build a path to it
;	-if the closest box is not new, clear the box path list (boxes_discovered_for_actor)
;	-mark that the actor needs a path update
;	-???
;===========================================
build_path_to_destination:
;Adjust the destination as needed based on walkboxes
.C:1c4a  20 68 1A    JSR adjust_actor_destination
;Did we find the closest walkbox?
.C:1c4d  A6 D8       LDX actor
.C:1c4f  AD AC FD    LDA closest_box_index
.C:1c52  C9 FF       CMP #$FF
.C:1c54  D0 01       BNE box_found
;If not, exit
.C:1c56  60          RTS
box_found:
;Save the box found as the destination box for this actor
.C:1c57  9D D5 FD    STA destination_box_for_actor,X
;Is it the current one?
.C:1c5a  DD CD FD    CMP current_box_for_actor,X
.C:1c5d  F0 08       BEQ closest_box_is_current
;It's not, so build a path to it
.C:1c5f  20 EB 18    JSR build_path_to_destination_walkbox
.C:1c62  A6 D8       LDX actor
.C:1c64  4C 75 1C    JMP update_actor_path_vars
closest_box_is_current:
;We are already in the destination box so we don't need to build or save the path to it
;We will trim the boxes_discovered_for_actor list
;First, compute the boxes_discovered_for_actor base index for the actor
;That is: (actor_index + 1) * 16  = actor_index * 16 + 16
.C:1c67  8A          TXA
.C:1c68  0A          ASL A
.C:1c69  0A          ASL A
.C:1c6a  0A          ASL A
.C:1c6b  0A          ASL A
.C:1c6c  18          CLC
.C:1c6d  69 10       ADC #$10
;Use .Y as actor_box index in the boxes_discovered_for_actor list
.C:1c6f  A8          TAY
;Trim the list by setting the first element to #FF
.C:1c70  A9 FF       LDA #$FF
.C:1c72  99 D9 CA    STA boxes_discovered_for_actor,Y
update_actor_path_vars:
;Mark that this actor needs a path update
.C:1c75  A9 01       LDA #$01
.C:1c77  9D E1 FD    STA path_update_needed_for_actor,X
;Save the current box for the actor
.C:1c7a  BD CD FD    LDA current_box_for_actor,X
;Save this box as the last box for the actor
.C:1c7d  9D D1 FD    STA last_box_for_actor,X
.C:1c80  60          RTS
;===========================================
; Set a new path for the actor, if needed
;
; Arguments:	actor
;				path_update_needed_for_actor
;
; Returns:		desired_waypoint_x_for_actor
;				desired_waypoint_y_for_actor
;===========================================
set_desired_waypoint_for_actor:
;Does the actor need a path update?
.C:1c81  A6 D8       LDX actor
.C:1c83  BD E1 FD    LDA path_update_needed_for_actor,X
;If not, exit
.C:1c86  F0 1A       BEQ exit
;Clear the flag, as we're updating the path now
.C:1c88  A9 00       LDA #$00
.C:1c8a  9D E1 FD    STA path_update_needed_for_actor,X
;Build a path using the walkboxes
.C:1c8d  20 A3 1C    JSR get_waypoint_for_actor
;Did we find a new path?
.C:1c90  C9 FF       CMP #$FF
;If so, exit
.C:1c92  D0 0E       BNE exit
;No new path, set the original destination as the path
.C:1c94  A6 D8       LDX actor
.C:1c96  BD D9 FD    LDA destination_x_for_actor,X
.C:1c99  9D 29 FD    STA desired_waypoint_x_for_actor,X
.C:1c9c  BD DD FD    LDA destination_y_for_actor,X
.C:1c9f  9D 31 FD    STA desired_waypoint_y_for_actor,X
exit:
.C:1ca2  60          RTS
;===========================================
; Build a path to the destination, for a given actor
;
; This routine will:
; 	-get the walkboxes for the actor's room
;	-get the final depth reached while doing the box search
;	-get the actual box index for that search depth
;	-save the box index as the target box
;	-compute the pointer to the target box
;	-compute the pointer to the current box
;	-compare the target vs. current box relative positions
;	-if there's box overlap, exit
;	-check if there are trajectory adjustments needed - if not, we have our desired waypoint, exit
;	-otherwise, it will pick the correct box corner and set it as the desired waypoint
;
; Arguments:	actor
;				box_search_depth_for_actor
;				boxes_discovered_for_actor
;
; Returns:		.A		#FF	 no path adjustments made
;						#00	 path adjustments were made
;				desired_waypoint_x_for_actor
;				desired_waypoint_y_for_actor
;===========================================
current_box_ptr = $17
target_box_ptr = $19
target_box_index = $fc3b
actor_relative_position = $fc3b
offset_copy = $1e8f
unused_var = $cad4
box_relative_position = $cad6

get_waypoint_for_actor:
.C:1ca3  A6 D8       LDX actor
;CAD4 seems to have been used as a debugging variable - unused everywhere else
.C:1ca5  A9 FF       LDA #$FF
.C:1ca7  8D D4 CA    STA unused_var
;Get the boundary boxes for the actor's room
.C:1caa  20 B1 2D    JSR get_walkboxes_for_costume
;If boxes are not available, exit and return #FF
.C:1cad  C9 FF       CMP #$FF
.C:1caf  D0 01       BNE get_box_search_depth
.C:1cb1  60          RTS
;---------------------------------------------
get_box_search_depth:
;Get the final depth reached by the box search
.C:1cb2  BD 75 FE    LDA box_search_depth_for_actor,X
;If depth is #FF, the search failed, exit and return #FF
.C:1cb5  C9 FF       CMP #$FF
.C:1cb7  D0 03       BNE get_box_for_depth
.C:1cb9  A9 FF       LDA #$FF
.C:1cbb  60          RTS
;---------------------------------------------
get_box_for_depth:
.C:1cbc  DE 75 FE    DEC box_search_depth_for_actor,X
;Save the box depth
.C:1cbf  8D 3B FC    STA target_box_index
;Compute the base index for the actor for the boxes_discovered_for_actor array
;That is: (actor_index + 1) * 16  = actor_index * 16 + 16
.C:1cc2  8A          TXA
.C:1cc3  0A          ASL A
.C:1cc4  0A          ASL A
.C:1cc5  0A          ASL A
.C:1cc6  0A          ASL A
.C:1cc7  18          CLC
.C:1cc8  69 10       ADC #$10
;.C:1cca  A8          TAY	;Redundant code
;Add the box depth to get the final offset
.C:1ccb  18          CLC
.C:1ccc  6D 3B FC    ADC target_box_index
.C:1ccf  A8          TAY
;Save the offset into offset_copy
.C:1cd0  8C 8F 1E    STY offset_copy
;---------------------------------------------
;Get the actual box index from the array
.C:1cd3  B9 D9 CA    LDA boxes_discovered_for_actor,Y
;Save this box as the last box for the actor
.C:1cd6  9D D1 FD    STA last_box_for_actor,X
;Save it in target_box_index
.C:1cd9  8D 3B FC    STA target_box_index
;---------------------------------------------
.C:1cdc  AC 8F 1E    LDY offset_copy
;Is the search depth #00 or #FF? If so, skip this part
.C:1cdf  BD 75 FE    LDA box_search_depth_for_actor,X
.C:1ce2  F0 0C       BEQ setup_target_box_ptr
.C:1ce4  C9 FF       CMP #$FF
.C:1ce6  F0 08       BEQ setup_target_box_ptr
;---------------------------------------------
;The depth is neither #00 nor #FF - copy the penultimate box discovered into unused_var
;It seems to have been used as a debugging variable - unused everywhere else
.C:1ce8  88          DEY
.C:1ce9  B9 D9 CA    LDA boxes_discovered_for_actor,Y
.C:1cec  8D D4 CA    STA unused_var
.C:1cef  C8          INY
;---------------------------------------------
setup_target_box_ptr:
;??? - 1B/1C probably unused
.C:1cf0  A5 17       LDA <current_box_ptr
.C:1cf2  85 1B       STA $1B
.C:1cf4  A5 18       LDA >current_box_ptr
.C:1cf6  85 1C       STA $1C
.C:1cf8  A5 18       LDA >current_box_ptr
.C:1cfa  85 1A       STA >target_box_ptr
;Multiply target box index by 5 to compute the offset (each walkbox occupies 5 bytes)
.C:1cfc  AD 3B FC    LDA target_box_index
.C:1cff  0A          ASL A
.C:1d00  0A          ASL A
.C:1d01  18          CLC
.C:1d02  6D 3B FC    ADC target_box_index
;Add the target box offset to the base pointer to point to the target box
.C:1d05  65 17       ADC <current_box_ptr
.C:1d07  85 19       STA <target_box_ptr
.C:1d09  90 02       BCC setup_current_box_ptr
.C:1d0b  E6 1A       INC >target_box_ptr
;---------------------------------------------
setup_current_box_ptr:
;Multiply current box index by 5 to compute the offset
.C:1d0d  BD CD FD    LDA current_box_for_actor,X
.C:1d10  0A          ASL A
.C:1d11  0A          ASL A
.C:1d12  18          CLC
.C:1d13  7D CD FD    ADC current_box_for_actor,X
;Add offset to base pointer to point to the current box
.C:1d16  65 17       ADC <current_box_ptr
.C:1d18  85 17       STA <current_box_ptr
.C:1d1a  90 02       BCC check_overlap
.C:1d1c  E6 18       INC >current_box_ptr
;---------------------------------------------
check_overlap:
;Check the relative position of the current box vs. the target box
.C:1d1e  A0 00       LDY #$00
.C:1d20  20 9E 1D    JSR get_boxes_relative_positions
;Do the boxes overlap?
.C:1d23  C9 FF       CMP #$FF
.C:1d25  D0 0F       BNE no_overlap
;---------------------------------------------
boxes_overlap:
;The 2 boxes overlap with each other, so there's no adjustments to be made
.C:1d27  A6 D8       LDX actor
;Reset motion state to "about to stop"
.C:1d29  A9 01       LDA #$01
.C:1d2b  9D 68 FD    STA motion_state_for_actor,X
;Reset the box search depth
.C:1d2e  A9 FF       LDA #$FF
.C:1d30  9D 75 FE    STA box_search_depth_for_actor,X
.C:1d33  A9 FF       LDA #$FF
.C:1d35  60          RTS
;---------------------------------------------
no_overlap:
;The boxes don't overlap, save the relative position
.C:1d36  8D D6 CA    STA box_relative_position
;Get the actor's destination relative position against the target box
; Returns:		.A		#00		actor's coordinate < box "lower edge (top/left)" - so the actor will eventually have to turn a corner down or right
;						#01		actor's coordinate > box "higher edge (bottom/right)" - so the actor will eventually have to turn a corner up or left
;						#02 	Actor's coordinate inside the box range
.C:1d39  20 D9 1D    JSR get_actor_relative_position
.C:1d3c  A6 D8       LDX actor
.C:1d3e  8D 3B FC    STA actor_relative_position
;Check if there's any adjustment in the trajectory to be made
; Returns:		.A		#FF		adjustment needed
;						#00		no adjustments needed
.C:1d41  20 07 1E    JSR check_if_adjustment_needed
.C:1d44  D0 0F       BNE adjust_path
no_adjustment:
;There are no trajectory adjustments to be made, so simply copy the destination as the path
.C:1d46  BD D9 FD    LDA destination_x_for_actor,X
.C:1d49  9D 29 FD    STA desired_waypoint_x_for_actor,X
.C:1d4c  BD DD FD    LDA destination_y_for_actor,X
.C:1d4f  9D 31 FD    STA desired_waypoint_y_for_actor,X
.C:1d52  A9 00       LDA #$00
.C:1d54  60          RTS
;---------------------------------------------
adjust_path:
;Check if the target box relative position indicates a vertical or horizontal result by testing bit 1
;If bit 1 is set, the relative position is horizontal
;If bit 1 is clear, the relative position is vertical
;If bit 1 is set, the result of AND #02 will be #02, the Z flag will be clear and BNE will be taken (horizontal)
;If bit 1 is clear, the result of AND #02 will be #00, the Z flag will be set and BNE will not be taken (vertical)
.C:1d55  AD D6 CA    LDA box_relative_position
.C:1d58  29 02       AND #$02
.C:1d5a  D0 20       BNE horizontal_relative_position
;---------------------------------------------
vertical_relative_position:
;Is the actor's horizontal coordinate inside the box range?
.C:1d5c  AD 3B FC    LDA actor_relative_position
.C:1d5f  C9 02       CMP #$02
.C:1d61  D0 06       BNE actor_coord_outside_target_box_1
actor_coord_inside_target_box_1:
;If it's inside, pick the actor's coordinate to keep it unchanged
.C:1d63  BD 41 FD    LDA position_x_for_actor,X
.C:1d66  4C 6C 1D    JMP set_path_to_target_corner
;---------------------------------------------
actor_coord_outside_target_box_1:
;It's not inside, so we have to pick a corner of the target box, whatever is closer to the actor
;#00	actor X < box - pick the left edge of the box
;#01	actor X > box - pick the right edge of the box
;Load the relative position (#00 or #01) into .Y to use it to an offset
.C:1d69  A8          TAY
.C:1d6a  B1 19       LDA (target_box_ptr),Y
;---------------------------------------------
set_path_to_target_corner:
;Set the value we picked before as the adjusted X coordinate of the actor's path
.C:1d6c  9D 29 FD    STA desired_waypoint_x_for_actor,X
;Now simply pick the box top or bottom edge (depending on the target box relative position)
;Add 2 to the relative position to convert it to the edge offset
.C:1d6f  AC D6 CA    LDY box_relative_position
.C:1d72  C8          INY
.C:1d73  C8          INY
.C:1d74  B1 19       LDA (target_box_ptr),Y
;And set it as the adjusted Y coordinate of the actor's path
.C:1d76  9D 31 FD    STA desired_waypoint_y_for_actor,X
.C:1d79  4C 9B 1D    JMP return_00
;---------------------------------------------
horizontal_relative_position:
;Is the actor's vertical coordinate inside the box range?
.C:1d7c  AD 3B FC    LDA actor_relative_position
.C:1d7f  C9 02       CMP #$02
.C:1d81  D0 06       BNE actor_coord_outside_target_box_2
actor_coord_inside_target_box_2:
;If it's inside, pick the actor's coordinate to keep it unchanged
.C:1d83  BD 3D FD    LDA position_y_for_actor,X
.C:1d86  4C 8E 1D    JMP set_path_to_target_corner_2
;---------------------------------------------
actor_coord_outside_target_box_2:
;It's not inside, so we have to pick a corner of the target box, whatever is closer to the actor
;#00	actor Y < box - pick the top edge of the box
;#01	actor Y > box - pick the bottom edge of the box
;Load the relative position (#00 or #01) into .Y to use it to an offset
;Add 2 to .Y to point to the vertical edges of the box
.C:1d89  A8          TAY
.C:1d8a  C8          INY
.C:1d8b  C8          INY
.C:1d8c  B1 19       LDA (target_box_ptr),Y
;---------------------------------------------
set_path_to_target_corner_2:
;Set the value we picked before as the adjusted Y coordinate of the actor's path
.C:1d8e  9D 31 FD    STA desired_waypoint_y_for_actor,X
;Now simply pick the box left or right edge (depending on the target box relative position)
;Subtract 2 to the relative position to convert it to the edge offset
.C:1d91  AC D6 CA    LDY box_relative_position
.C:1d94  88          DEY
.C:1d95  88          DEY
.C:1d96  B1 19       LDA (target_box_ptr),Y
;And set it as the adjusted X coordinate of the actor's path
.C:1d98  9D 29 FD    STA desired_waypoint_x_for_actor,X
return_00:
.C:1d9b  A9 00       LDA #$00
.C:1d9d  60          RTS
;===========================================
; Determines the relative position of the current box versus the target box
;
; Arguments:	current_box_ptr
;				target_box_ptr
;
; Returns:		.A	#00		current box is relatively below the target box
;					#01		current box is relatively above the target box
;					#02		current box is relatively to the right of the target box
;					#03		current box is relatively to the left of the target box
;					#FF		the two boxes overlap
;
; Note on the returned value: 
; 		A horizontal relative position is represented by either #02 (right) or #03 (left),
; 		and a vertical relative position is represented by either #00 (below) or #01 (above).
; 		This allows using bit 1 to differentiate between a horizontal (bit 1 set) and a vertical (bit 1 clear) type of result.
;
; Important: Vertical coordinates increase in value when moving _downwards_.
; 			 So a lower position in the screen is _greater_ in value than a higher position.
;
; To check for a vertical overlap between boxes, we need to compare the top and bottom edges.
; Consider these two scenarios.
;
; Scenario 1: B top higher on screen than A bottom 
;			  B top < A bottom (in value)
; 			  There is vertical overlap
;
; 			|-------|
; 			|   A   |		|-------|	B top
; A bottom 	|-------|		|	B 	|
;							|-------|
;
; Scenario 2: B top lower on screen than A bottom 
;			  B top > A bottom (in value)
;			  There is no vertical overlap, and B is relatively below A (in their vertical components)
;
; A top		|-------|
; 			|   A   |		
; A bottom 	|-------|		
;							|-------| 	B top
;							|	B 	|
;							|-------| 	B bottom
;
; For horizontal comparisons, the same logic applies.
;===========================================
current_box_ptr = $17
target_box_ptr = $19

get_boxes_relative_positions:
;Use .Y as edge data offset
;Point to top edge (offset #02) of the current box
.C:1d9e  C8          INY
.C:1d9f  C8          INY
;Load top edge of current box
.C:1da0  B1 17       LDA (current_box_ptr),Y
;Point to bottom edge (offset #03) of the target box
.C:1da2  C8          INY
;Do current top - target bottom
.C:1da3  D1 19       CMP (target_box_ptr),Y
;Are they equal? If so, continue
.C:1da5  F0 02       BEQ check_next
;Is current top > target bottom? (a higher value means a lower position on screen)
;If so, return #00 - the current box is relatively (and completely) below the target box
.C:1da7  B0 2D       BCS return_00
;---------------------------------------------
check_next:
;Load bottom edge of current box (offset #03)
.C:1da9  B1 17       LDA (current_box_ptr),Y
;Point to top edge of target box (offset #02)
.C:1dab  88          DEY
;Do current bottom - target top
.C:1dac  D1 19       CMP (target_box_ptr),Y
;Is current bottom < target top?
;If so, return #01 - the current box is relatively (and completely) above the target box
.C:1dae  90 21       BCC return_01
;---------------------------------------------
;So far, the two boxes are at least partially overlapping in their vertical components
;Now check the horizontal components
;Point to left edge (offset #00)
.C:1db0  88          DEY
.C:1db1  88          DEY
;Load current's left edge
.C:1db2  B1 17       LDA (current_box_ptr),Y
;Point to right edge (offset #01)
.C:1db4  C8          INY
;Do current left - target right
.C:1db5  D1 19       CMP (target_box_ptr),Y
;Are they equal? If so, continue
.C:1db7  F0 02       BEQ check_next_2
;Is current left > target right?
;If so, return #02 - the current box is relatively (and completely) to the right of the target box
.C:1db9  B0 11       BCS return_02
;---------------------------------------------
check_next_2:
;Load current's right edge (offset #01)
.C:1dbb  B1 17       LDA (current_box_ptr),Y
;Point to left edge (offset #00)
.C:1dbd  88          DEY
;Do current right - target left
.C:1dbe  D1 19       CMP (target_box_ptr),Y
;Is current's right edge < target's left?
;If so, return #03 - the current box is relatively (and completely) to the left of the target box
.C:1dc0  90 05       BCC return_03
;---------------------------------------------
;Else, return #FF - the boxes are overlapping each other
return_ff:
.C:1dc2  A9 FF       LDA #$FF
.C:1dc4  4C D8 1D    JMP exit
;---------------------------------------------
;This means the current box is relatively (and completely) to the left of the target box
return_03:
.C:1dc7  A9 03       LDA #$03
.C:1dc9  4C D8 1D    JMP exit
;---------------------------------------------
;This means the current box is relatively (and completely) to the right of the target box
return_02:
.C:1dcc  A9 02       LDA #$02
.C:1dce  4C D8 1D    JMP exit
;---------------------------------------------
;This means the current box is relatively (and completely) above the target box
return_01:
.C:1dd1  A9 01       LDA #$01
.C:1dd3  4C D8 1D    JMP exit
;---------------------------------------------
;This means the current box is relatively (and completely) below the target box
return_00:
.C:1dd6  A9 00       LDA #$00
exit:
.C:1dd8  60          RTS
;===========================================
; Checks an actor's relative position against a target walkbox
;
; If the relative position is of the horizontal type, the checks will be done with the vertical position.
; If the relative position is instead vertical, the checks will be done with the horizontal position.
;
; This allows knowing if the actor would have to "turn a corner" if it tried to moved towards the destination in the target box,
; while keeping its position inside the boxes.
;
; For instance, consider the case where the adjacent target box is to the left of the current box.
; And both boxes have exactly the same vertical dimensions and are vertically aligned.
; If the actor is fully inside the current box and wanted to move left, it would not hit an obstacle,
; no matter its vertical position. It could move freely in a straight line to the destination position.
;
; 			|--------|=========|
; 			| target | current |
;		 	|--------|=========|
;					
; Now consider two adjacent boxes, but having different vertical dimensions.
;
; 			|--------|---------|	Row 0
; 			| target | current |	Row 1
;			|	     |    A    |	Row 2
;			|	     |---------|	Row 3
;		 	|--------|				Row 4
;
;	A = actor's current position
;
; If the actor is inside the current box and wanted to move left, to a destination inside the target box:
;		If the destination row is 0, 1, 2 or 3, there wouldn't be a problem, no obstacles would be hit.
;		If the destination row is 4, the trajectory would have to eventually go down (as the current box doesn't get to row 4).
;		While doing so, it can't escape the current box, as that's a constraint. Or any box, technically. 
;		So the correct trajectory would have to first find and hit the "corner" at the boxes adjacent's edge.
;
; This crude graphic tries to depict that scenario:
;
; 			|--------|---------|	Row 0
; 			| target | current |	Row 1
;			|	     |         |	Row 2
;			|	  ...C....A----|	Row 3
;		 	|---X..--|				Row 4
;
;	A = actor's current position
;	X = destination
;	C = "corner"
;	. = trajectory
;	Here, we see that the destination is on row 4. The trajectory has to first hit the corner marked with "C",
;	before freely going down to row 4.
; 
; More specifically, this routine tries to determine if the following scenario arises:
;
; 			|--------|          	
; 			| target |---------|	
; 			|--------| current |	
;				     |    A    |	
;				     |---------|	
;		 	          				
;	Here, the actor's vertical position is lower than the bottom edge of the target box.
; 	So it will definitely have to hit the "top left" corner of the current box before 
; 	being able to get to the target box.
;
; Arguments:	box_relative_position	Used to determine which axis to check
;				target_box_ptr
;
; Returns:		.A		#00		actor's coordinate < box "lower edge (top/left)" - so the actor will eventually have to turn a corner down or right
;						#01		actor's coordinate > box "higher edge (bottom/right)" - so the actor will eventually have to turn a corner up or left
;						#02 	Actor's coordinate inside the box range
;===========================================
actor_coordinate = $cad5
box_relative_position = $cad6
target_box_ptr = $19

get_actor_relative_position:
;Get the box relative position
.C:1dd9  AD D6 CA    LDA box_relative_position
;Check if the result indicates a vertical or horizontal result by testing bit 1
;If bit 1 is set (for values #02 and #03), the relative position is horizontal
;If bit 1 is clear (for values #00 and #01), the relative position is vertical
;When doing the AND, if bit 1 is set, the result will be #02 and the Z flag will be clear
;If bit 1 is clear, the result will be #00 and the Z flag will be set
.C:1ddc  29 02       AND #$02
;Copy the result (either #00 or #02) to .Y
;This will set the first data offset correctly for the axis range check
;A horizontal range check (left/right) needs to read from offsets #00 and #01
;A vertical range check (top/bottom) needs offsets #02 and #03 
.C:1dde  A8          TAY
;If bit 1 is set, Z flag will be clear, BNE will be taken
.C:1ddf  D0 06       BNE set_y
;---------------------------------------
set_x:
;Relative position is horizontal
;Load the actor's X coordinate
.C:1de1  BD 41 FD    LDA position_x_for_actor,X
.C:1de4  4C EA 1D    JMP set_actor_coordinate
set_y:
;Relative position is vertical
;Load the actor's Y coordinate
.C:1de7  BD 3D FD    LDA position_y_for_actor,X
set_actor_coordinate:
;Set the coordinate as the actor coordinate
.C:1dea  8D D5 CA    STA actor_coordinate
;---------------------------------------
; Check against the target box "lower" coordinate (left/top)
; Is actor_coordinate >= target lower?
; If so, continue checking
.C:1ded  AD D5 CA    LDA actor_coordinate
.C:1df0  D1 19       CMP (target_box_ptr),Y
.C:1df2  B0 03       BCS check_next
;---------------------------------------
return_00:
;If not, actor_coordinate < target left/top
;Return #00
.C:1df4  A9 00       LDA #$00
.C:1df6  60          RTS
;---------------------------------------
check_next:
;Now check against the other coordinate of the target, the "upper" one (right/bottom)
.C:1df7  C8          INY
;Is actor_coordinate <= target upper?
;If so, return #02 
.C:1df8  D1 19       CMP (target_box_ptr),Y
.C:1dfa  90 05       BCC return_02
.C:1dfc  F0 03       BEQ return_02
;---------------------------------------
;If not, actor_coordinate > target
;Return #01
return_01:
.C:1dfe  A9 01       LDA #$01
.C:1e00  60          RTS
;---------------------------------------
return_02:
.C:1e01  A9 02       LDA #$02
.C:1e03  60          RTS
;===========================================
; Check if the destination coordinates need adjustment
;
; Returns:		.A		#FF		adjustment needed
;						#00		no adjustments needed
; This routine will first check if the actor's destination coordinate is inside the target box range.
; If it isn't, it definitely needs adjustment.
; 
; Then, it will check if one of the actor's destination coordinates falls inside the "narrowest hall" (read explanation below).
; If it doesn't, it needs adjustment.
; 
; Finally, it will check the other destination coordinate to see if it goes past the current box edges.
; If it does, it needs adjustment.
;
;===========================================
current_box_ptr = $17
target_box_ptr = $19
box_relative_position = $cad6
actor_relative_position = $fc3b
first_edge = $1e04
second_edge = $1e05
other_destination_coord = $fc3f

check_if_adjustment_needed:
;Is the actor's destination coordinate inside the target box range? (#02)
.C:1e07  AD 3B FC    LDA actor_relative_position
.C:1e0a  C9 02       CMP #$02
.C:1e0c  F0 03       BEQ destination_inside_target_box
;If it isn't, we already know we need to adjust the trajectory
;Return #FF
.C:1e0e  A9 FF       LDA #$FF
.C:1e10  60          RTS
;---------------------------------------
;We need to check if the destination can be reached in a straight path from the current position,
;without hitting the current or target box "solid" edges.
;If we can achieve that, nothing needs to be adjusted and we can use a straight trajectory between 
;the current position and the destination. Otherwise, we'll need to adjust the trajectory somehow.
;
;The scenarios to consider have already been described, but this one in particular will also be covered:
;
;	Origin
;	0----------------------> +X axis
;   |        current   target				 
;   |	 	|--------|           
; 	|		|        |---------| <--- farthest from origin (of the 2 top edges)
;	|		|	A    |    X    |			
;	|		|	     |---------| <--- closest to origin (of the 2 bottom edges)
;	|	 	|--------|			
;	V
;	+Y axis
;
;	A = actor's current position
;	X = destination
;
; In this scenario, we see that the target box narrows down the space from A to X, both on the top and bottom edges.
; To account for this, we have to pick the narrowest combination of edges possible and check if the result allows an unobstructed trajectory.
; For instance, for the vertical axis, this means picking the bottom edge closest to the origin (origin being 0),
; and the top edge farthest from the origin. This selection builds the "narrowest hall".
;
;The relative position of the target box vs. the current box takes place on either the vertical axis (above or below)
; or the horizontal axis (to the left or to the right). Let's call this axis the "relative" axis.
;This routine will check the coordinate of the "opposite" axis first, and then the coordinate of the relative axis.
;---------------------------------------
destination_inside_target_box:
;Get the relative position of the current box vs. the target box
.C:1e11  AD D6 CA    LDA box_relative_position
;Compute the axis for the relative position by testing bit 1
;If bit 1 is set, the relative axis is horizontal
;If bit 1 is clear, the relative axis is vertical
.C:1e14  29 02       AND #$02
;Copy the result to .Y to compute the _opposite_ axis offset
;Offsets #00 and #01 are left/right edges (on the horizontal axis)
;Offsets #02 and #03 are top/bottom edges (on the vertical axis)
;A vertical range check (top/bottom) needs offsets #02 and #03 
.C:1e16  A8          TAY
;We'll call the first edge picked (either a left edge or a top edge) the "first edge"
;We'll call the second edge picked (either a right edge or a bottom edge) the "second edge"
;Among the current box and the target box, pick the first edge that's _higher_ in value (farthest from the origin)
.C:1e17  B1 17       LDA (current_box_ptr),Y
.C:1e19  D1 19       CMP (target_box_ptr),Y
;If they're equal, it doesn't matter which one we pick
;Use the target edge arbitrarily
.C:1e1b  F0 02       BEQ use_target_as_first_edge
;If current > target, pick current
.C:1e1d  B0 02       BCS set_first_edge
;If current <= target, pick target
use_target_as_first_edge:
.C:1e1f  B1 19       LDA (target_box_ptr),Y
set_first_edge:
;Set whatever we picked as the first edge
.C:1e21  8D 04 1E    STA first_edge
;---------------------------------------
;Repeat the same logic with the second edge
;Point to the second edge
.C:1e24  C8          INY
;Among the current box and the target box, pick the second edge that's _lower_ in value (closest to the origin)
.C:1e25  B1 17       LDA (current_box_ptr),Y
.C:1e27  D1 19       CMP (target_box_ptr),Y
;If current < target, pick current
.C:1e29  90 02       BCC set_second_edge
;If current >= target, pick target
.C:1e2b  B1 19       LDA (target_box_ptr),Y
set_second_edge:
;Set whatever we picked as the upper edge
.C:1e2d  8D 05 1E    STA second_edge
;---------------------------------------
;Use the box relative position again to determine if the vertical or horizontal coordinate needs to be used
.C:1e30  AD D6 CA    LDA box_relative_position
;If bit 1 is set, the result of AND #02 will be #02, the Z flag will be clear and BNE will be taken
;If bit 1 is clear, the result of AND #02 will be #00, the Z flag will be set and BNE will not be taken
.C:1e33  29 02       AND #$02
.C:1e35  D0 06       BNE use_actor_vertical
;---------------------------------------
use_actor_horizontal:
;Bit 1 is clear, use actor's horizontal destination coordinate
.C:1e37  BD D9 FD    LDA destination_x_for_actor,X
.C:1e3a  4C 40 1E    JMP compare_lower_edge
use_actor_vertical:
;Bit 1 is set, use actor's vertical destination coordinate
.C:1e3d  BD DD FD    LDA destination_y_for_actor,X
;---------------------------------------
compare_lower_edge:
;Compare with first_edge
.C:1e40  CD 04 1E    CMP first_edge
;Are they equal? If so, return #FF
.C:1e43  F0 02       BEQ return_ff
;Is actor_destination > first_edge? If so, continue
.C:1e45  B0 03       BCS compare_upper_edge
return_ff:
;actor_destination <= first_edge - the actor's destination is outside or right on the edge of the "narrowest" hall 
;And so, it needs adjustment - return #FF
.C:1e47  A9 FF       LDA #$FF
.C:1e49  60          RTS
;---------------------------------------
compare_upper_edge:
;Compare with second_edge
.C:1e4a  CD 05 1E    CMP second_edge
;Is actor_destination < second_edge? If so, continue
.C:1e4d  90 03       BCC select_other_axis
;actor_destination >= second_edge - the actor's destination is outside or right on the edge of the "narrowest" hall 
;And so, it needs adjustment - return #FF
.C:1e4f  A9 FF       LDA #$FF
.C:1e51  60          RTS
;---------------------------------------
;So far, the actor_destination is contained in the "narrowest hall" (range [first_edge ; second_edge])
;Now check the actor's other coordinate
;First, select the other axis
select_other_axis:
;Decrement .Y to point to the first coordinate's offset
;If we were doing horizontal checks, the offset will be #00
;If we were doing vertical checks, the offset will be #02
.C:1e52  88          DEY
;If .Y == #00, Z will be set, BNE will not be taken
.C:1e53  D0 0B       BNE horizontal
;---------------------------------------
vertical:
;Use the vertical destination as the other coordinate to check
.C:1e55  BD DD FD    LDA destination_y_for_actor,X
;Load the relative position (#00 or #01) and add 2 to compute the offset to the first vertical coordinate
.C:1e58  AC D6 CA    LDY box_relative_position
.C:1e5b  C8          INY
.C:1e5c  C8          INY
.C:1e5d  4C 68 1E    JMP set_other_coord
;---------------------------------------
horizontal:
;Use the horizontal destination as the other coordinate to check
.C:1e60  BD D9 FD    LDA destination_x_for_actor,X
;Load the relative position (#02 or #03) and subtract 2 to compute the offset to the first horizontal coordinate
.C:1e63  AC D6 CA    LDY box_relative_position
.C:1e66  88          DEY
.C:1e67  88          DEY
;---------------------------------------
set_other_coord:
;Set whatever we picked as the other coordinate to check
.C:1e68  8D 3F FC    STA other_destination_coord
;---------------------------------------
; Use the box relative position again - this time test bit 0
; Bit 0 will be set when the value is either #01 or #03
; #01 = current box is above target box
; #03 = current box is left of the target box
; In both cases, the current box is closer to the origin
.C:1e6b  AD D6 CA    LDA box_relative_position
;If bit 0 is set, AND #01 == #01, Z flag is clear, BNE taken (current box closest)
;If bit 0 is clear, AND #01 == #00, Z flag is set, BNE not taken (current box farthest)
.C:1e6e  29 01       AND #$01
.C:1e70  D0 0D       BNE current_box_position_is_closest
;---------------------------------------
;Current box position is farthest from origin
;---------------------------------------
current_box_position_is_farthest:
;Compare against current's first
.C:1e72  AD 3F FC    LDA other_destination_coord
.C:1e75  D1 17       CMP (current_box_ptr),Y
;If other < first, return #00
.C:1e77  90 03       BCC return_00_2
;If other >= first, this coordinate falls past the edge of the current box
;And so, it needs adjustment - return #FF
.C:1e79  A9 FF       LDA #$FF
.C:1e7b  60          RTS
;---------------------------------------
return_00_2:
.C:1e7c  4C 8B 1E    JMP return_00
;---------------------------------------
;Current box position is closest to origin
;---------------------------------------
current_box_position_is_closest:
;Compare against current's first
.C:1e7f  AD 3F FC    LDA other_destination_coord
.C:1e82  D1 17       CMP (current_box_ptr),Y
;If other >= first, return #00
.C:1e84  F0 02       BEQ return_00
.C:1e86  B0 03       BCS return_00
;If other < first, this coordinate falls past the edge of the current box
;And so, it needs adjustment - return #FF
.C:1e88  A9 FF       LDA #$FF
.C:1e8a  60          RTS
;---------------------------------------
return_00:
;No adjustments needed
.C:1e8b  A9 00       LDA #$00
.C:1e8d  60          RTS
;===========================================
; Blit and mask animation cell
;
; This routine will blit the pixels of a specific animation cell into the desired sprite buffer.
; It supports horizontal flipping, in case an animation cell needs to be flipped.
;
; The underlying logic for sprites is to blit them (copy them with transparency)
; into the final sprite buffer one by one, until a full sprite picture is formed.
; This allows an additive approach that eliminates redundancies.
;
; For instance, when a character is speaking, the only things that vary between frames are the mouth animation cells (open and closed).
; The rest of the head cell remains exactly the same.
; The simplistic approach would be to store:
;	1 - the full head with the mouth 
;	2 - the full head with the mouth closed
; ...but this wastes space.
;
; Instead, the smart approach used by the game is to store:
;	1 - the head cell without the mouth
;	2 - the mouth open cell
;	3 - the mouth closed cell
; Naturally, the mouth cells are much smaller in size than the head.
;
; The counterpart of saving space in this manner is that cells need to be pasted on top of each other accordingly to form the desired picture.
;
;	A regular C64 sprite has 24x21 pixels. This is a total of 504 pixels. At 8 pixels per byte (1 bit per pixel), it's a total of 63 bytes.
;	As the sprites used are in _multicolor_ mode, the number of bits per pixel increases from 1 to 2.
;	This allows specifying 4 colors per pixel instead of 2, but halves the effective horizontal resolution from 24 pixels to 12.
;	So a C64 _multicolor_ sprite has 12x21 pixels, or a total of 252 pixels. At 4 pixels per byte (2 bits per pixel), it's still 63 bytes.
;	Each row of 12 pixels then occupies exactly 3 bytes. 
;	Byte 0 defines pixels 0-3, byte 1 defines pixels 4-7 and byte 2 defines pixels 8-11.
;	Row pixel information is stored consecutively. And rows are stored consecutively as well.
;
;	The game's animation cells might use the full width of a sprite (all 12 pixels), or they might use just a portion of it.
;	Some cells use only one third and some use two thirds. For instance, arms, when viewed from the front, usually take only one third of the width.
; 	When this happens, it's a waste of space to store the 12 pixels. Instead, only the necessary portion is stored.
;	1 byte is used for 4 pixels (1/3 width), 2 bytes are used for 8 pixels (2/3 width), 3 bytes for all 12 pixels (full width).
;
; A cell's data format consists of a header followed by the cell's pixel bytes.
; 
;	Offset		Meaning
;	======		=======
;	#00			Bytes per row
;	#01			Vertical size
;	#02			Horizontal offset
;	#03			Vertical offset
;	#04			Unused
;	#05			Inter-cell vertical offset
;	<pixel bytes for row 0>		
;	...
;	<pixel bytes for row n>		
;
;	Bytes per row:	how many bytes per row are present. This can be in the range of #00 to #03, as explained before.
;					A value of #00 means that the cell pixel buffer is empty.
;
;	Vertical size:	how many rows does the cell take
;
;	Horizontal offset:	how many groups of 4 pixels to offset when rendering a row. This is needed when only 4 or only 8 pixels per row
;						are stored, instead of the full 12. When this scenario occurs, this tells the renderer how to horizontally offset
;						the row's pixels, to position the cell correctly.
;						The possible values for this offset are in the range of #00 to #02, as they are expressed in bytes (groups of 4 pixels).
;
;	Vertical offset:	how many rows to offset from the _bottom_ row of the full picture.
;						For instance, the head cell is drawn much higher than the legs.
;						The full picture vertical position remains constant when rendering different cells.
;						This value tells the renderer how to vertically offset each cell correctly.
;
;	Inter-cell vertical offset:	a vertical offset to apply to the _next_ cell drawn. Used rarely in a limited number of cells. 
;
;	After the header, the pixel bytes follow.
;
; 	If 3 bytes per row are used, then the format is:
;		Row 0 Byte 0, Row 0 Byte 1, Row 0 Byte 2,
;		Row 1 Byte 0, Row 1 Byte 1, Row 1 Byte 2,
;		...etc...
;
;	If 2 bytes per row are used, then the format is:
;		Row 0 Byte 0, Row 0 Byte 1
;		Row 1 Byte 0, Row 1 Byte 1
;		...etc...
;
;	And if 1 byte per row is used, then the format is:
;		Row 0 Byte 0
;		Row 1 Byte 0
;		...etc...
;
; 	When rendering a row of 3 bytes per row, the renderer has to simply copy the 3 bytes from source to destination.
; 
;	When 2 bytes per row are used, the renderer needs to know if it needs to:
;		-skip destination byte 0, copy source 0 into destination 1, copy source 1 into destination 2
;
;		Source bytes			Destination bytes
;		============			=================
;		S0 S1					D0 D1 D2
;					->
;		S0 S1					D0 S0 S1
;
;	or  -copy source 0 into destination 0, copy source 1 into destination 1, skip destination byte 2
;
;		Source bytes			Destination bytes
;		============			=================
;		S0 S1					D0 D1 D2
;					->
;		S0 S1					S0 S1 D2
;
;	This is exactly what the horizontal offset value is used for. 
;	The same situation occurs when using 1 byte per row.
;
; To save even more space, cells that are perfect mirror images of another are not actually stored in memory. 
; They are generated on the fly by doing horizontal "flipping".
; For instance, all of the head graphics for characters when "looking left" are flipped versions of the "looking right" versions.
; Only one of the two versions is stored (the "looking right" one) and the other is computed by flipping.
;
; This is done by using precomputed flipped values for all possible bytes. There are 256 possible values for each byte, representing 4 pixels.
; Each flipped counterpart for each of those 256 values is stored in an array.
; If the renderer knows it needs to flip a cell, it will use an alternative version of the copy logic.
; Instead of copying the bytes as-is, it will use the flipped versions.
;
; Once the row's 3 bytes are ready (by copying them directly or flipping them), the final step is to "mask" them onto the original sprite's data.
; This is analogous to the real-life hand-drawn celluloid animation compositing/overlay.
; The masking is performed by doing an AND of the pre-existing sprite byte using a bitmask to keep (some of the) original pixels.
; Then the result is OR'ed with the cell's row byte and written back.
;
; As an extra thing to consider, there are 4 variants of the copying, flipping and masking pieces of code.
; Each family of variants handles each of "X bytes per row" scenarios (1, 2 and 3), with an extra family that handles the 0 bytes per row scenario.
; 
; In fact, each family is a superset of another one. 
; The logic for 2 bytes per row includes the logic for 1 byte per row.
; The one for 3 bytes fully includes the logic for 2 bytes.
; And the one for 1 byte fully includes the logic for 0 bytes.
; 
; To speed up processing, the code is "repeated" (or inlined) instead of using a loop.
; So the function for 2 bytes uses part of the same code as the 3 bytes variant, only that the entry point skips the first byte.
; And so on.
;
;===========================================
sprite_output_ptr = $80
sprite_input_data = $7e
sprite_read_offset = $fc00
sprite_read_offset_copy = $17

bytes_per_row = $fc01
current_row_index = $fc28
last_row_index = $fc29
horizontal_byte_offset = $fc2a
rows_to_skip = $fc3b
vertical_size = $fc02
horizontal_offset = $34
vertical_offset = $35
current_sprite_y_pos = $3f
blit_bytes = $49
row_skip_needed = $1e90

blit_and_mask_limb:
.C:1e91  A9 00       LDA #$00
.C:1e93  8D 90 1E    STA row_skip_needed
;Use .Y as read offset index on limb data
.C:1e96  A0 00       LDY #$00
.C:1e98  8C 00 FC    STY sprite_read_offset
;--------------------------------------------
; Read cell metadata from header
;--------------------------------------------
;Read bytes_per_row, which will be used to determine how many bytes are processed (3, 2, 1 or 0)
.C:1e9b  B1 7E       LDA (sprite_input_data),Y
.C:1e9d  8D 01 FC    STA bytes_per_row
;Store bytes_per_row into .X  
;.X will be used as an index into function pointer lists for blitting (mask_address_set, normal_address_set and flip_address_set)
;A value of #00 will not process any byte - it will go straight to the next row
;A value in the range #01-#03 will blit (mask and copy normal/flipped) exactly those many bytes
.C:1ea0  AA          TAX
;Read vertical size and horizontal offset
.C:1ea1  C8          INY
.C:1ea2  B1 7E       LDA (sprite_input_data),Y
.C:1ea4  8D 02 FC    STA vertical_size
.C:1ea7  C8          INY
.C:1ea8  B1 7E       LDA (sprite_input_data),Y
.C:1eaa  85 34       STA horizontal_offset
;Assert that bytes_per_row + horizontal_offset doesn't exceed #03 - if so, hang up
.C:1eac  18          CLC
.C:1ead  6D 01 FC    ADC bytes_per_row
.C:1eb0  C9 03       CMP #$03
.C:1eb2  90 10       BCC select_blit_function
.C:1eb4  F0 0E       BEQ select_blit_function
;--------------------------------------------
; Assertion failed - hangup
;--------------------------------------------
.C:1eb6  A9 04       LDA #$04
.C:1eb8  85 DC       STA $DC
;map_in_io
.C:1eba  A0 25       LDY #$25
.C:1ebc  84 01       STY processor_port_register
hang_loop:
.C:1ebe  8D 20 D0    STA vic_border_color_register
.C:1ec1  4C BE 1E    JMP hang_loop
;--------------------------------------------
; Blit function selection
;--------------------------------------------
;Check which blit function we need to use (if straight or flipped)
select_blit_function:
;Save .Y as we'll overwrite it
.C:1ec4  84 17       STY sprite_read_offset_copy
;Get the current flip setting for this limb
.C:1ec6  A4 D8       LDY actor
.C:1ec8  AD 25 FC    LDA current_limb_flip
;If it's #00, don't flip, use a normal blit - otherwise, flip
.C:1ecb  F0 14       BEQ set_normal_blit
;--------------------------------------------
set_flipped_blit:
;Set up blit function based on .X (which holds the value of bytes_per_row)
.C:1ecd  BD 4F 20    LDA flip_address_set_lo,X
.C:1ed0  8D 3C 20    STA <blit_function
.C:1ed3  BD 53 20    LDA flip_address_set_hi,X
.C:1ed6  8D 3D 20    STA >blit_function
;Compute horizontal_byte_offset into .A = 2 - horizontal_offset
.C:1ed9  A9 02       LDA #$02
.C:1edb  38          SEC
.C:1edc  E5 34       SBC horizontal_offset
.C:1ede  4C F6 1E    JMP set_column_offset
;--------------------------------------------
set_normal_blit:
;Set up blit function based on .X (which holds the value of bytes_per_row)
.C:1ee1  BD 47 20    LDA normal_address_set_lo,X
.C:1ee4  8D 3C 20    STA <blit_function
.C:1ee7  BD 4B 20    LDA normal_address_set_hi,X
.C:1eea  8D 3D 20    STA >blit_function
;Compute horizontal_byte_offset into .A = bytes_per_row + horizontal_offset - 1
.C:1eed  AD 01 FC    LDA bytes_per_row
.C:1ef0  38          SEC
.C:1ef1  E9 01       SBC #$01
.C:1ef3  18          CLC
.C:1ef4  65 34       ADC horizontal_offset
;--------------------------------------------
; Mask function selection
;--------------------------------------------
set_column_offset:
;Restore .Y read offset
.C:1ef6  A4 17       LDY sprite_read_offset_copy
;Store previous horizontal offset result in .A into horizontal_byte_offset
.C:1ef8  8D 2A FC    STA horizontal_byte_offset
set_mask_function:
;Set up mask function based on .X (which holds the value of bytes_per_row)
.C:1efb  BD 3F 20    LDA mask_address_set_lo,X
.C:1efe  8D E9 1F    STA <mask_function
.C:1f01  BD 43 20    LDA mask_address_set_hi,X
.C:1f04  8D EA 1F    STA >mask_function
;--------------------------------------------
; Row indexes selection
;--------------------------------------------
;Load vertical_offset
.C:1f07  C8          INY
.C:1f08  B1 7E       LDA (sprite_input_data),Y
.C:1f0a  85 35       STA vertical_offset
;Compute start and last row indexes
;Set current_row_index = current_sprite_y_pos - vertical_offset
.C:1f0c  38          SEC
.C:1f0d  A5 3F       LDA current_sprite_y_pos
.C:1f0f  E5 35       SBC vertical_offset
.C:1f11  8D 28 FC    STA current_row_index
;Set last_row_index = current_row_index + vertical_size
.C:1f14  18          CLC
.C:1f15  6D 02 FC    ADC vertical_size
.C:1f18  8D 29 FC    STA last_row_index
;--------------------------------------------
.C:1f1b  C9 91       CMP #$91
.C:1f1d  90 14       BCC last_row_le_91
.C:1f1f  F0 12       BEQ last_row_le_91
;--------------------------------------------
.C:1f21  AD 28 FC    LDA current_row_index
.C:1f24  C9 91       CMP #$91
.C:1f26  90 03       BCC start_row_le_91
.C:1f28  F0 01       BEQ start_row_le_91
.C:1f2a  60          RTS
;--------------------------------------------
start_row_le_91:
.C:1f2b  A9 91       LDA #$91
.C:1f2d  8D 29 FC    STA last_row_index
.C:1f30  4C 55 1F    JMP set_output_data_ptr
;--------------------------------------------
last_row_le_91:
.C:1f33  AD 28 FC    LDA current_row_index
.C:1f36  C9 91       CMP #$91
.C:1f38  90 1B       BCC set_output_data_ptr
.C:1f3a  F0 19       BEQ set_output_data_ptr
.C:1f3c  8D 3B FC    STA rows_to_skip
.C:1f3f  CE 3B FC    DEC rows_to_skip
.C:1f42  A9 01       LDA #$01
.C:1f44  8D 28 FC    STA current_row_index
;Mark that we need to skip rows
.C:1f47  A9 01       LDA #$01
.C:1f49  8D 90 1E    STA row_skip_needed
.C:1f4c  AD 29 FC    LDA last_row_index
.C:1f4f  CD 28 FC    CMP current_row_index
.C:1f52  B0 01       BCS set_output_data_ptr
.C:1f54  60          RTS
;--------------------------------------------
; Set output and mask layer pointers to the correct row
;--------------------------------------------
set_output_data_ptr:
;Point the output pointer to the appropriate row position
;Compute sprite_output_ptr = sprite_row_offsets[current_row_index] + actor_sprite_base
.C:1f55  AE 28 FC    LDX current_row_index
.C:1f58  BD A8 D5    LDA sprite_row_offsets_lo,X
.C:1f5b  18          CLC
.C:1f5c  6D 2E FC    ADC <actor_sprite_base
.C:1f5f  85 80       STA <sprite_output_ptr
.C:1f61  BD 08 D5    LDA sprite_row_offsets_hi,X
.C:1f64  6D 2F FC    ADC >actor_sprite_base
.C:1f67  85 81       STA >sprite_output_ptr
;--------------------------------------------
;Compute room scene tile row - divide current_row_index by 8, store it in .X
.C:1f69  8A          TXA
.C:1f6a  4A          LSR A
.C:1f6b  4A          LSR A
.C:1f6c  4A          LSR A
.C:1f6d  AA          TAX
;Compute room scene row offsets for tile row
.C:1f6e  BD 40 D6    LDA room_scene_row_offsets_lo,X
.C:1f71  18          CLC
.C:1f72  6D 21 FD    ADC $FD21		;Seems to be always #00 - perhaps used for debugging
.C:1f75  85 86       STA <room_scene_mask_layer_row_ptr
.C:1f77  BD 59 D6    LDA room_scene_row_offsets_hi,X
.C:1f7a  6D 22 FD    ADC $FD22		;Seems to be always #00 - perhaps used for debugging
.C:1f7d  85 87       STA >room_scene_mask_layer_row_ptr
;--------------------------------------------
; Load final metadata and point to pixel data
;--------------------------------------------
;Load the fifth byte (unused) and the sprite's inter-cell vertical displacement
.C:1f7f  C8          INY
.C:1f80  B1 7E       LDA (sprite_input_data),Y
.C:1f82  8D 03 FC    STA fifth_byte
.C:1f85  C8          INY
.C:1f86  B1 7E       LDA (sprite_input_data),Y
.C:1f88  8D 04 FC    STA intercell_vertical_displacement
;--------------------------------------------
;Update sprite_input_data pointer by adding .Y (the read offset) + 1
; to point directly to the next input byte
.C:1f8b  98          TYA
.C:1f8c  38          SEC
.C:1f8d  65 7E       ADC <sprite_input_data
.C:1f8f  85 7E       STA <sprite_input_data
.C:1f91  90 02       BCC check_row_skip_needed
.C:1f93  E6 7F       INC >sprite_input_data
check_row_skip_needed:
;Do we need to skip rows? If not, continue with the next one
.C:1f95  AD 90 1E    LDA row_skip_needed
.C:1f98  F0 12       BEQ next_row
;--------------------------------------------
; Row skip as needed
;--------------------------------------------
;Row skip needed
;Use .Y as an index of rows_to_skip
.C:1f9a  AC 3B FC    LDY rows_to_skip
next_row_to_skip:
;Use .X as a counter of bytes per row to skip
.C:1f9d  AE 01 FC    LDX bytes_per_row
skip_row_pixels:
;Increase the input pointer by 1
.C:1fa0  E6 7E       INC <sprite_input_data
;Adjust carry as needed
.C:1fa2  D0 02       BNE next_byte
.C:1fa4  E6 7F       INC >sprite_input_data
next_byte:
;Move to next byte
.C:1fa6  CA          DEX
.C:1fa7  D0 F7       BNE skip_row_pixels
;Move to next row
.C:1fa9  C8          INY
.C:1faa  D0 F1       BNE next_row_to_skip
;--------------------------------------------
next_row:
.C:1fac  4C 2A 20    JMP move_to_next_row
;--------------------------------------------
; Straight copy functions
;--------------------------------------------
straight_byte_3:
;Copy the input data byte unchanged to the blit bytes
.C:1faf  B1 7E       LDA (sprite_input_data),Y
.C:1fb1  95 49       STA blit_bytes,X
.C:1fb3  E8          INX
.C:1fb4  C8          INY
;Repeat the same logic for each following byte
straight_byte_2:
.C:1fb5  B1 7E       LDA (sprite_input_data),Y
.C:1fb7  95 49       STA blit_bytes,X
.C:1fb9  E8          INX
.C:1fba  C8          INY
straight_byte_1:
.C:1fbb  B1 7E       LDA (sprite_input_data),Y
.C:1fbd  95 49       STA blit_bytes,X
.C:1fbf  E8          INX
.C:1fc0  C8          INY
.C:1fc1  8C 00 FC    STY sprite_read_offset
call_mask_function_2:
.C:1fc4  4C E5 1F    JMP call_mask_function
;--------------------------------------------
; Flipped copy functions
;--------------------------------------------
flip_byte_3:
;Flip the input data by loading the flipped pattern
.C:1fc7  B1 7E       LDA (sprite_input_data),Y
.C:1fc9  AA          TAX
.C:1fca  BD 00 D3    LDA flipped_patterns,X
;Write the flipped byte to the blit bytes
.C:1fcd  85 4B       STA blit_bytes + 2
.C:1fcf  C8          INY
;Repeat the same logic for each following byte
flip_byte_2:
.C:1fd0  B1 7E       LDA (sprite_input_data),Y
.C:1fd2  AA          TAX
.C:1fd3  BD 00 D3    LDA flipped_patterns,X
.C:1fd6  85 4A       STA blit_bytes + 1
.C:1fd8  C8          INY
flip_byte_1:
.C:1fd9  B1 7E       LDA (sprite_input_data),Y
.C:1fdb  AA          TAX
.C:1fdc  BD 00 D3    LDA flipped_patterns,X
.C:1fdf  85 49       STA blit_bytes
.C:1fe1  C8          INY
.C:1fe2  8C 00 FC    STY sprite_read_offset
call_mask_function:
;Load the horizontal byte offset into .Y
.C:1fe5  AC 2A FC    LDY horizontal_byte_offset
mask_function = $1fe9
.C:1fe8  4C 00 00    JMP mask_function
;.C:1feb  4C 11 20    JMP update_sprite_data_ptr ;Unreachable code
;--------------------------------------------
; Masking functions
;--------------------------------------------
;Mask whatever data is already stored in the sprite data buffer
;This allows pasting limb cells on top of each other to build a full sprite
mask_byte_3:
;Load the mask pattern for the current pixel pattern
.C:1fee  A6 4B       LDX blit_bytes + 2
.C:1ff0  BD 00 D2    LDA sprite_mask_patterns,X
;"Lift" mask pixels from the current sprite buffer - and use .Y as the horizontal byte offset as needed
.C:1ff3  31 80       AND (sprite_output_ptr),Y
;Combine current pixel pattern with the masked result
.C:1ff5  05 4B       ORA blit_bytes + 2
.C:1ff7  91 80       STA (sprite_output_ptr),Y
.C:1ff9  88          DEY
;Repeat the same logic for each following byte
mask_byte_2:
.C:1ffa  A6 4A       LDX blit_bytes + 1
.C:1ffc  BD 00 D2    LDA sprite_mask_patterns,X
.C:1fff  31 80       AND (sprite_output_ptr),Y
.C:2001  05 4A       ORA blit_bytes + 1
.C:2003  91 80       STA (sprite_output_ptr),Y
.C:2005  88          DEY
mask_byte_1:
.C:2006  A6 49       LDX blit_bytes
.C:2008  BD 00 D2    LDA sprite_mask_patterns,X
.C:200b  31 80       AND (sprite_output_ptr),Y
.C:200d  05 49       ORA blit_bytes
.C:200f  91 80       STA (sprite_output_ptr),Y
;--------------------------------------------
; Move output pointer to next row
;--------------------------------------------
update_sprite_data_ptr:
;Have we reached the last row? If so, exit
.C:2011  AE 28 FC    LDX current_row_index
.C:2014  EC 29 FC    CPX last_row_index
.C:2017  F0 25       BEQ exit
;Move output pointer to the next row
;sprite_output_ptr = actor_sprite_base + sprite_row_offsets[row]
.C:2019  BD A8 D5    LDA sprite_row_offsets_lo,X
.C:201c  18          CLC
.C:201d  6D 2E FC    ADC <actor_sprite_base
.C:2020  85 80       STA <sprite_output_ptr
.C:2022  BD 08 D5    LDA sprite_row_offsets_hi,X
.C:2025  6D 2F FC    ADC >actor_sprite_base
.C:2028  85 81       STA >sprite_output_ptr
;--------------------------------------------
; Move row counter to next row, loop as needed
;--------------------------------------------
move_to_next_row:
;Have we reached the last row? If so, exit
.C:202a  AE 28 FC    LDX current_row_index
.C:202d  EC 29 FC    CPX last_row_index
.C:2030  F0 0C       BEQ exit
;Move to next row
.C:2032  E8          INX
.C:2033  8E 28 FC    STX current_row_index
;Reset .X, restore read offset into .Y, loop back to the blit function
.C:2036  A2 00       LDX #$00
.C:2038  AC 00 FC    LDY sprite_read_offset
blit_function = $203c
.C:203b  4C 00 00    JMP blit_function
exit:
.C:203e  60          RTS
;===========================================
;Table of function pointers used for each "bytes per row" scenario
;
;2011	update_sprite_data_ptr		0 bytes per row
;2006	mask_byte_1					1 byte per row
;1FFA	mask_byte_2					2 bytes per row
;1FEE	mask_byte_3					3 bytes per row
mask_address_set_lo = $203f
mask_address_set_hi = $2043
.C:203f  11 06 FA EE 
.C:2043  20 20 1F 1F 
;1FC4	call_mask_function_2		0 bytes per row
;1FBB	straight_byte_1				1 byte per row
;1FB5	straight_byte_2				2 bytes per row
;1FAF	straight_byte_3				3 bytes per row
normal_address_set_lo = $2047
normal_address_set_hi = $204b
.C:2047  C4 BB B5 AF
.C:204b  1F 1F 1F 1F
;1FE5	call_mask_function			0 bytes per row
;1FD9	flip_byte_1					1 byte per row
;1FD0	flip_byte_2					2 bytes per row
;1FC7	flip_byte_3					3 bytes per row
flip_address_set_lo = $204f
flip_address_set_hi = $2053
.C:204f  E5 D9 D0 C7
.C:2053  1F 1F 1F 1F 
;===========================================
; Keyboard handling
;
; Polls the keyboard for keys pressed.
;
; The detailed logic includes:
; 	-a polling wait to avoid reading too frequently
;	-giving priority to joystick inputs (which resets the polling wait)
;	-0-bit counting to check if there's any input signal (read the details on how keys are scanned)
;	-usage of a key matrix structure to map the keycode scanned to an input 
;	-usage of a secondary "shifted" matrix, to support Shift keys being pressed
;	
; On return:
;	kbd_key_ready		boolean - will hold #01 if there's an input detected, #00 otherwise
;	kbd_keycode	will hold the input code scanned (if any)
;===========================================
poll_delay_hi = $fe4e
poll_delay_lo = $fe4d
keyb_column_bits = $2057
keyb_row_bits = $2059
col_bits_clear_count = $2058
row_bits_clear_count = $205A
matrix_offset = $205E
col_adjustment_bitmask = $205F
row_adjustment_bitmask = $2060
last_keycode_scanned = $205D
zero_lsb_column = $205C
kbd_key_ready = $2061


kbd_scan:
.C:2062  A0 FF       LDY #$FF
.C:2064  8C 57 20    STY keyb_column_bits
.C:2067  8C 59 20    STY keyb_row_bits
;If FEA6 is zero, skip the delay initialization, go straight to polling
.C:206a  AD A6 FE    LDA saved_script_index
.C:206d  F0 0A       BEQ poll_input
;Set initial delay values
.C:206f  A9 20       LDA #$20
.C:2071  8D 4D FE    STA poll_delay_lo
.C:2074  A9 1C       LDA #$1C
.C:2076  8D 4E FE    STA poll_delay_hi
;-------------
poll_input:
; Poll joystick inputs - on return, the Zero flag will be clear if there's any input activated; set, if not.
.C:2079  20 A6 21    JSR joy_latch
.C:207c  F0 0B       BEQ delay_count_check	;No inputs detected, continue
;Joystick input detected - reset the polling delay and exit
.C:207e  A9 20       LDA #$20
.C:2080  8D 4D FE    STA poll_delay_lo
.C:2083  A9 1C       LDA #$1C
.C:2085  8D 4E FE    STA poll_delay_hi
.C:2088  60          RTS
delay_count_check:
;Check if delay count is zero
.C:2089  AD 4D FE    LDA poll_delay_lo
.C:208c  0D 4E FE    ORA poll_delay_hi
;If so, proceed to read input
.C:208f  F0 18       BEQ read_input
.C:2091  AD 4D FE    LDA poll_delay_lo
.C:2094  D0 03       BNE delay_decrease_lo
.C:2096  CE 4E FE    DEC poll_delay_hi
delay_decrease_lo:
.C:2099  CE 4D FE    DEC poll_delay_lo
;Have we reached a delay count of zero now? If so, go the exit section
.C:209c  AD 4D FE    LDA poll_delay_lo
.C:209f  0D 4E FE    ORA poll_delay_hi
.C:20a2  D0 05       BNE read_input
.C:20a4  A9 20       LDA #$20
.C:20a6  4C 5E 21    JMP direct_exit_check
;-------------
;Follow steps to read keyboard 
; 1 - Port A - set all bits to R/W, Port B - set all bits as read-only
; 2 - Build the "columns to read" bitmask
;		Ignore a column by setting a 1, read a column by setting a 0
; 3 - Write the bitmask to Port A
; 4 - Read result from port B
; 5 - Any column activated will have its bit set to 0
read_input:
;Set CIA 1 port A all bits to R/W
.C:20a9  A0 FF       LDY #$FF
.C:20ab  8C 02 DC    STY cia1_port_a_data_direction_reg
;Set CIA 1 port B all bits to read-only
.C:20ae  A9 00       LDA #$00
.C:20b0  8D 03 DC    STA cia1_port_b_data_direction_reg
;Select all keyboard columns to be read (#00)
.C:20b3  8D 00 DC    STA cia1_port_a_data_register
;Check if any column was activated by comparing .Y (#FF) to value in data port B
.C:20b6  CC 01 DC    CPY cia1_port_b_data_register
;If there's any difference, at least one bit is zero - then at least one column has been activated
.C:20b9  D0 03       BNE input_detected
;No difference
.C:20bb  4C 52 21    JMP no_relevant_input_detected
;-------------
input_detected:
;Copy the column bits to a local variable
;Set CIA 1 port A all bits to R/W
.C:20be  A9 FF       LDA #$FF
.C:20c0  8D 02 DC    STA cia1_port_a_data_direction_reg
;Set CIA 1 port B all bits to read-only
.C:20c3  A9 00       LDA #$00
.C:20c5  8D 03 DC    STA cia1_port_b_data_direction_reg
.C:20c8  8D 00 DC    STA cia1_port_a_data_register
;Store copy of keyboard column bits
.C:20cb  AD 01 DC    LDA cia1_port_b_data_register
.C:20ce  8D 57 20    STA keyb_column_bits
;Now copy the row bits to a local variable (same read procedure but inverting the roles of Port A and B)
;Set CIA 1 port B all bits to R/W
.C:20d1  A9 FF       LDA #$FF
.C:20d3  8D 03 DC    STA cia1_port_b_data_direction_reg
;Set CIA 1 port A all bits to read-only
.C:20d6  A9 00       LDA #$00
.C:20d8  8D 02 DC    STA cia1_port_a_data_direction_reg
.C:20db  8D 01 DC    STA cia1_port_b_data_register
.C:20de  AD 00 DC    LDA cia1_port_a_data_register
.C:20e1  8D 59 20    STA keyb_row_bits
;-------------
count_bits:
;Count how many column bits are zero - if none, .A == #FF (and Negative flag will be set)
.C:20e4  AD 57 20    LDA keyb_column_bits
.C:20e7  20 94 21    JSR count_zero_bits
.C:20ea  30 66       BMI no_relevant_input_detected		;No bits are clear
.C:20ec  8D 58 20    STA col_bits_clear_count
;Store the LSB index for the first zero
.C:20ef  AD 5B 20    LDA zero_lsb_index
.C:20f2  8D 5C 20    STA zero_lsb_column
;-------------
;Count how many row bits are zero - if none, .A == #FF (and Negative flag will be set)
.C:20f5  AD 59 20    LDA keyb_row_bits
.C:20f8  20 94 21    JSR count_zero_bits
.C:20fb  30 55       BMI no_relevant_input_detected		;No bits are clear
.C:20fd  8D 5A 20    STA row_bits_clear_count
;Check once again that we have at least 1 row or column bit in zero (by OR'ing the 2 counts together and checking the Z flag)
.C:2100  0D 58 20    ORA col_bits_clear_count
;If we don't, see if we need to "adjust the matrix" (whatever that means)
.C:2103  D0 63       BNE matrix_offset_adjustment
;-------------
;Use row and column indexes to build a matrix index
; Column index * 8 + row index + base index
.C:2105  AD 5C 20    LDA zero_lsb_column
.C:2108  0A          ASL A
.C:2109  0A          ASL A
.C:210a  0A          ASL A
.C:210b  18          CLC
.C:210c  6D 5B 20    ADC zero_lsb_index		;This is the zero_lsb for the row
.C:210f  6D 5E 20    ADC matrix_offset
;Store the result in .Y
.C:2112  A8          TAY
;-------------
;Load key code from matrix
.C:2113  B9 BE 21    LDA key_matrix,Y
;Any key that has a #5F is ignored (some of the symbols and special keys) - see key_matrix below
.C:2116  C9 5F       CMP #$5F
.C:2118  F0 38       BEQ no_relevant_input_detected
;Compare against the last read keycode
.C:211a  CD 5D 20    CMP last_keycode_scanned
.C:211d  8D 5D 20    STA last_keycode_scanned
;If they are equal, then it's the same key, skip to exit
.C:2120  F0 3A       BEQ exit_directly
;-------------
;Switch on keycode
.C:2122  B9 BE 21    LDA key_matrix,Y
.C:2125  C9 7B       CMP KEY_LSHIFT
.C:2127  D0 11       BNE not_left_shift
;It's Left Shift - set modifiers to keycodes and related vars
.C:2129  A9 40       LDA #$40		;Set matrix base offset
.C:212b  8D 5E 20    STA matrix_offset
.C:212e  A9 80       LDA #$80
.C:2130  8D 5F 20    STA col_adjustment_bitmask
.C:2133  A9 02       LDA #$02
.C:2135  8D 60 20    STA row_adjustment_bitmask
.C:2138  D0 22       BNE exit_directly	;Exit unconditionally (this BNE will always be taken)
not_left_shift:
.C:213a  C9 7D       CMP KEY_RSHIFT
.C:213c  D0 11       BNE not_right_shift
;It's Right shift - set modifiers to keycodes and related vars
.C:213e  A9 40       LDA #$40		;Set matrix base offset
.C:2140  8D 5E 20    STA matrix_offset
.C:2143  A9 10       LDA #$10
.C:2145  8D 5F 20    STA col_adjustment_bitmask
.C:2148  A9 40       LDA #$40
.C:214a  8D 60 20    STA row_adjustment_bitmask
.C:214d  D0 0D       BNE exit_directly	;Exit unconditionally (this BNE will always be taken)
not_right_shift:
.C:214f  4C 5E 21    JMP direct_exit_check	;Go to exit section
;-------------
;Some keys are detected but ignored, that's why we call this label "no _relevant_ input detected"
no_relevant_input_detected:
.C:2152  A9 00       LDA #$00
.C:2154  8D 5E 20    STA matrix_offset
.C:2157  A9 FF       LDA #$FF
.C:2159  8D 5D 20    STA last_keycode_scanned
exit_directly:
;This is a way of exiting, as loading a zero will set the Zero flag
;and the next BEQ instruction will execute always, thus leading to the end of the subroutine
.C:215c  A9 00       LDA #$00
direct_exit_check:
;If we come from the instruction above (LDA #00), the branch will always be taken, as Z is set
.C:215e  F0 07       BEQ exit
;If we're here, then we have detected a keycode, store it
.C:2160  85 30       STA kbd_keycode
;Mark that there's a keycode ready
.C:2162  A9 01       LDA #$01
.C:2164  8D 61 20    STA kbd_key_ready
exit:
.C:2167  60          RTS
;===========================================
matrix_offset_adjustment:
;Is matrix offset set? As the only values are #00 or #40, a bit 6 check is enough to differentiate
.C:2168  2C 5E 20    BIT matrix_offset
.C:216b  50 09       BVC exit_directly_2	;Offset not set, exit
;Offset is set - Store "adjustment" bitmasks into .X and .Y
.C:216d  AE 5F 20    LDX col_adjustment_bitmask
.C:2170  AC 60 20    LDY row_adjustment_bitmask
.C:2173  4C 79 21    JMP adjust_column_bits
exit_directly_2:
.C:2176  4C 5C 21    JMP exit_directly
adjust_column_bits:
.C:2179  AD 58 20    LDA col_bits_clear_count
.C:217c  F0 07       BEQ adjust_row_bits
.C:217e  8A          TXA
.C:217f  0D 57 20    ORA keyb_column_bits
.C:2182  8D 57 20    STA keyb_column_bits
adjust_row_bits:
.C:2185  AD 5A 20    LDA row_bits_clear_count
.C:2188  F0 07       BEQ count_bits_2
.C:218a  98          TYA
.C:218b  0D 59 20    ORA keyb_row_bits
.C:218e  8D 59 20    STA keyb_row_bits
count_bits_2:
.C:2191  4C E4 20    JMP count_bits
;===========================================
;Count zero bits
;
; Counts how many bits are set to 0.
;
; Arguments: .A - bits to count
;
; On output, .A will hold (total number of 0 bits - 1) (#FF if none)
;			zero_lsb_index will hold the index of the least significant 0 bit found, if found
;				if not found, its value won't change from entry
;===========================================
zero_lsb_index = $205B

count_zero_bits:
;Use .Y as the bit index counter
.C:2194  A0 07       LDY #$07
.C:2196  A2 00       LDX #$00
check_for_zero_bit:
;Shift most significant bit into carry
.C:2198  0A          ASL A
;Bit is set?
.C:2199  B0 04       BCS next_bit_index
;Bit is 0 - increment 0-bit counter (.X)
.C:219b  E8          INX
;Store the index of this 0-bit in zero_lsb_index
.C:219c  8C 5B 20    STY zero_lsb_index
next_bit_index:
.C:219f  88          DEY
;Still more bits to test?
.C:21a0  10 F6       BPL check_for_zero_bit
;Subtract 1 from 0-bit counter, move counter to A and return
.C:21a2  CA          DEX
.C:21a3  8A          TXA
.C:21a4  60          RTS
.C:21a5  00          BRK
;===========================================
; Polls the CIA1 ports to read the joystick input state.
; Only reads the state of the joystick connected to port #2.
;
; On return, .A will hold the state of the input (as a bitmask, bits 0-4).
; The Zero flag will be clear if there's any input activated; set, if not.
;===========================================
;-------------
; Steps to read joystick
; 1 - Port A - set all bits to R/W, Port B - set all bits as read-only
; 2 - Build the "inputs to read" bitmask
;		Ignore an input by setting a 1, read an input line by setting a 0
; 3 - Write the bitmask to Port A
; 4 - Read result from port B
; 5 - Any input activated will have its bit set to 0
;-------------
joy_latch:
;Set CIA 1 Port A all bits to R/W
.C:21a6  A0 FF       LDY #$FF
.C:21a8  8C 02 DC    STY cia1_port_a_data_direction_reg
;Set bitmask to "read all inputs"
.C:21ab  8C 00 DC    STY cia1_port_a_data_register
;Set CIA 1 Port B all bits to read-only
.C:21ae  A9 00       LDA #$00
.C:21b0  8D 03 DC    STA cia1_port_b_data_direction_reg
;Read result from port B
.C:21b3  AD 01 DC    LDA cia1_port_b_data_register
.C:21b6  85 33       STA joy_state
;Mask bits for joystick inputs (bits 0-4)
.C:21b8  29 1F       AND #$1F
;Check if any joystick input was activated by comparing all joy input lines (bits 0-4, #1F) against the read value
;If there's any difference, at least one bit in the range 0-4 is zero - then at least one input has been activated
;To sum up: if there's a joystick input activated, the comparison will be 'not equal', and the Z flag will be clear
.C:21ba  C9 1F       CMP #$1F
.C:21bc  60          RTS
;===========================================
.C:21bd  00          BRK

key_matrix = $21be
KEY_LSHIFT = #$7B
KEY_RSHIFT = #$7D
.C:21be  
;Matrix of key inputs mapped from the keycodes scanned
; A value of #5F is ignored
; Special cases - the Function keys, which yield values in the 01-08 range
C8 33 35 37 39 2B 5F 31 ; DEL	3 		5 	7 	9 	+ 	Pound	1
0D 77 72 79 69 70 2A 5F ; <ret>	W		R	Y	I	P	*		Left
CA 61 64 67 6A 6C 3B 5F ; Right	A		D	G	J	L	;		Ctrl
04 34 36 38 30 2D CF 32 ; F7	4		6	8	0	-	Home	2
01 7A 63 62 6D 2E 7D 20 ; F1	Z		C	B	M	.	RShift	Space
02 73 66 68 6B 3A 3D D0 ; F3	S		F	H	K	:	=		Commodore
03 65 74 75 6F 40 5F 71 ; F5	E		T	U	O	@	Up		Q
CD 7B 78 76 6E 2C 2F 5F ; Down	LShift 	X 	V	N	,	/		Stop

;Shifted key matrix - these are the key inputs mapped when a shift key is pressed
C9 23 25 27 29 2B 5F 21 
0D 57 52 59 49 50 2A 5F 
CB 41 44 47 4A 4C 29 5F
08 24 26 28 30 2D CE 22 
05 5A 43 42 4D 3E 7D 20 
06 53 46 48 4B 28 3D 5F 
07 45 54 55 4F 40 5F 51 
CC 7B 58 56 4E 3C 3F 5F 
;
20 44
.C:2240  22
.C:2241  F0 FB
.C:2243  60
;===========================================
; Process a key
;===========================================
kbd_key_read:
.C:2244  AD 61 20    LDA kbd_key_ready
;Is there a key to process?
.C:2247  D0 01       BNE keycode_is_ready
;No, exit
.C:2249  60          RTS
keycode_is_ready:
;Yes, mark there's no longer a key ready (to avoid repeat processing)
.C:224a  A9 00       LDA #$00
.C:224c  8D 61 20    STA kbd_key_ready
;Load the key in .A and leave
.C:224f  A5 30       LDA kbd_keycode
.C:2251  60          RTS
;===========================================
; Setup an actor so it's ready to be drawn on screen
;
; This routine will:
;		-setup the costume resource as needed
;		-compute the actor's "tile X" coordinate (the X pixel coordinate divided by 8)
;		-setup the mask bit patterns (for masking)
;		-setup the base address for the actor's sprite data
;		-setup the graphic section offset for decoding
;		-setup the cell addresses list
;		-setup the limb cell list address
;		-clear all the existing sprite's data
;		-if the actor is visible, it will draw all its limbs
;		-if the actor is behind a foreground layer, it will mask it accordingly
;		-set the actor's sprite X position
;		-set the actor's background color
;===========================================
global_mask_patterns_ptr = $8a
graphic_section_offset = $82
limb_cell_list = $84
sprite_data_ptr = $80
actor_tile_x_coordinate = $fd20
constant_02 = $cb52

draw_actor:
;Setup the active costume, as needed, for animation data decoding
.C:2252  20 70 24    JSR setup_costume_for_actor
.C:2255  A6 D8       LDX actor
.C:2257  BC 32 FC    LDY actor_sprite_index,X
;Compute actor's sprite tile X coordinate - divide the X coordinate by 8 (16-bit wide division)
.C:225a  BD 39 FD    LDA character_sprite_x_hi,X
.C:225d  4A          LSR A
.C:225e  BD 1C FD    LDA character_sprite_x_lo,X
.C:2261  6A          ROR A
.C:2262  4A          LSR A
.C:2263  4A          LSR A
;And subtract 3
.C:2264  38          SEC
.C:2265  E9 03       SBC #$03
.C:2267  8D 20 FD    STA actor_tile_x_coordinate
;Set global_mask_patterns_ptr to point to the mask_bit_patterns table
.C:226a  A9 00       LDA <mask_bit_patterns
.C:226c  85 8A       STA <global_mask_patterns_ptr
.C:226e  A9 D4       LDA >mask_bit_patterns
.C:2270  85 8B       STA >global_mask_patterns_ptr
.C:2272  BD 32 FC    LDA actor_sprite_index,X
;.C:2275  AA          TAX	;Redundant code
.C:2276  A8          TAY
;Determine base address for the actor's sprite based on the sprite index and the sprite_buffer in use
.C:2277  20 56 24    JSR set_actor_sprite_base_address
;Setup the address of the graphic section start
.C:227a  A6 D8       LDX actor
.C:227c  BD 42 CB    LDA graphic_data_ptr_for_actor_lo,X
.C:227f  85 82       STA <graphic_section_offset
.C:2281  BD 46 CB    LDA graphic_data_ptr_for_actor_hi,X
.C:2284  85 83       STA >graphic_section_offset
;Copy the offset for the high-bytes elements of the cell_address_list, for this actor
.C:2286  BD 4A CB    LDA cell_addresses_hi_offset_for_actor,X
.C:2289  8D 53 CB    STA cell_addresses_hi_offset
.C:228c  A9 02       LDA #$02
.C:228e  8D 52 CB    STA constant_02
;Copy the limb cell list address for the current actor
.C:2291  BD 3A CB    LDA limb_cell_list_for_actor_lo,X
.C:2294  85 84       STA <limb_cell_list
.C:2296  BD 3E CB    LDA limb_cell_list_for_actor_hi,X
.C:2299  85 85       STA >limb_cell_list
;Compute actor index 8th multiple
.C:229b  8A          TXA
.C:229c  18          CLC
.C:229d  0A          ASL A
.C:229e  0A          ASL A
.C:229f  0A          ASL A
.C:22a0  8D 36 FC    STA actor_index_8th_multiple
;Get the index for the actor's sprite
.C:22a3  A6 D8       LDX actor
.C:22a5  BC 32 FC    LDY actor_sprite_index,X
;Clear all the sprite's data
.C:22a8  20 EC 22    JSR clear_sprite_visible_rows
;Init the vertical offset
.C:22ab  A9 00       LDA #$00
.C:22ad  8D 15 FD    STA $FD15	;Unused variable
.C:22b0  85 35       STA vertical_offset
;Check if actor is invisible
.C:22b2  AE 30 FC    LDX active_costume
.C:22b5  BD E3 FE    LDA actor_vars,X
.C:22b8  29 80       AND ACTOR_IS_INVISIBLE
.C:22ba  D0 12       BNE set_color_and_x_coordinate
actor_is_visible:
;Actor is visible - draw all actor's limbs
.C:22bc  A6 D8       LDX actor
.C:22be  20 56 23    JSR draw_actor_limbs
;Check if actor is behind a foreground layer
.C:22c1  A6 D8       LDX actor
.C:22c3  BD 18 FD    LDA layer_depth_for_actor,X
.C:22c6  F0 03       BEQ copy_actors_data
actor_behind_foreground:
;Mask the actor with the foreground layer accordingly
.C:22c8  20 DB 30    JSR mask_actor_with_foreground_layer
copy_actors_data:
.C:22cb  20 A8 23    JSR copy_vertical_third_of_sprite_data
set_color_and_x_coordinate:
;Set the actor's sprite X position (hi/lo)
.C:22ce  A6 D8       LDX actor
.C:22d0  BD 39 FD    LDA character_sprite_x_hi,X
.C:22d3  BC 32 FC    LDY actor_sprite_index,X
.C:22d6  99 58 FD    STA actor_sprite_x_hi,Y
.C:22d9  BD 1C FD    LDA character_sprite_x_lo,X
.C:22dc  BC 32 FC    LDY actor_sprite_index,X
.C:22df  99 60 FD    STA actor_sprite_x_lo,Y
;Copy the background color for this sprite
.C:22e2  AE 30 FC    LDX active_costume
.C:22e5  BD C0 F0    LDA character_sprite_bkg_colors,X
.C:22e8  99 D2 0F    STA sprite_0_color,Y
.C:22eb  60          RTS
;===========================================
; Clear all of a sprite's visible rows
;
; Arguments:	.Y	sprite index
;===========================================
sprite_data_ptr = $80
bottom_row = $fd53
current_row = $cb51
buffer_00_vertical_offset_for_sprite = $fd8d
buffer_01_vertical_offset_for_sprite = $fd85

clear_sprite_visible_rows:
;Switch on the current sprite buffer in use (#00 or #01)
.C:22ec  AD 14 FD    LDA sprite_buffer
.C:22ef  F0 0D       BEQ sprite_buffer_is_00
;-----------------------------------------
sprite_buffer_is_01:
;Get the sprite's Y position, set it as the bottom row
.C:22f1  B9 81 FD    LDA buffer_01_y_position_for_sprite,Y
.C:22f4  8D 53 FD    STA bottom_row
;Subtract the sprite vertical offset to compute the top row
.C:22f7  38          SEC
.C:22f8  F9 85 FD    SBC buffer_01_vertical_offset_for_sprite,Y
.C:22fb  4C 08 23    JMP set_top_row_as_current_row
;-----------------------------------------
sprite_buffer_is_00:
;Get the sprite's Y position, set it as the bottom row
.C:22fe  B9 89 FD    LDA buffer_00_y_position_for_sprite,Y
.C:2301  8D 53 FD    STA bottom_row
;Subtract the sprite vertical offset to compute the top row
.C:2304  38          SEC
.C:2305  F9 8D FD    SBC buffer_00_vertical_offset_for_sprite,Y
;-----------------------------------------
set_top_row_as_current_row:
.C:2308  8D 51 CB    STA current_row
;-----------------------------------------
;Ensure the bottom row is within limits of the visible scene
.C:230b  AD 53 FD    LDA bottom_row
.C:230e  C9 91       CMP #$91
.C:2310  90 14       BCC check_limit_current_row
.C:2312  F0 12       BEQ check_limit_current_row
;-----------------------------------------
;Bottom row falls below lower edge of visible scene
;Check if the start row also does
;If so, the sprite is completely outside of the visible scene, exit
.C:2314  AD 51 CB    LDA current_row
.C:2317  C9 91       CMP #$91
.C:2319  90 03       BCC limit_bottom_row
.C:231b  F0 01       BEQ limit_bottom_row
.C:231d  60          RTS
;-----------------------------------------
limit_bottom_row:
;Current row is still in the visible part, cap the bottom row to the last visible row (#91)
.C:231e  A9 91       LDA #$91
.C:2320  8D 53 FD    STA bottom_row
.C:2323  4C 34 23    JMP init_loop
;-----------------------------------------
check_limit_current_row:
;Ensure the current row also falls on the visible scene (is this really necessary?)
.C:2326  AD 51 CB    LDA current_row
.C:2329  C9 91       CMP #$91
.C:232b  90 07       BCC init_loop
.C:232d  F0 05       BEQ init_loop
;If it doesn't, cap it to #00
.C:232f  A9 00       LDA #$00
.C:2331  8D 51 CB    STA current_row
;-----------------------------------------
; Clear all of the sprite rows between current_row and bottom_row
init_loop:
.C:2334  AD 51 CB    LDA current_row
clear_sprite_row:
;Use .Y as row index
.C:2337  A8          TAY
;Setup the sprite pointer for this row
.C:2338  20 0C 24    JSR set_sprite_ptr_for_row
;Use .Y as "byte column" index, start from #02, go downwards
.C:233b  A0 02       LDY #$02
;Clear the byte - repeat 2 times to clear the 3 bytes of this row
.C:233d  A9 00       LDA #$00
.C:233f  91 80       STA (sprite_data_ptr),Y
.C:2341  88          DEY
.C:2342  91 80       STA (sprite_data_ptr),Y
.C:2344  88          DEY
.C:2345  91 80       STA (sprite_data_ptr),Y
;.C:2347  AC 30 FC    LDY active_costume	;Redundant code
;Move to the next row
.C:234a  EE 51 CB    INC current_row
;Did we reach the bottom visible row? If not, continue
.C:234d  AD 51 CB    LDA current_row
.C:2350  CD 53 FD    CMP bottom_row
.C:2353  30 E2       BMI clear_sprite_row
.C:2355  60          RTS
;===========================================
; Draw all the actor's limb cells
;
; Thjis routine will setup each limb drawing by:
;		-caching the limb flip state
;		-applying an inter-cell vertical displacement, if needed
;		-drawing the cell via blit_and_mask_limb
;
; Arguments:	character_sprite_y
;===========================================
current_limb_flip = $fc25

draw_actor_limbs:
;Load the actor's vertical position, copy it to current_sprite_y_pos
.C:2356  A6 D8       LDX actor
.C:2358  BD 37 FC    LDA character_sprite_y,X
.C:235b  85 3F       STA current_sprite_y_pos
;Initialize multiple drawing variables
.C:235d  A9 00       LDA #$00
;.C:235f  85 3E       STA $3E				;Apparently unused
;.C:2361  8D 4D FD    STA $FD4D				;Unused
.C:2364  8D 03 FC    STA fifth_byte
.C:2367  8D 04 FC    STA intercell_vertical_displacement
.C:236a  8D 55 CB    STA sprite_vertical_offset
.C:236d  8D 41 FC    STA current_actor_limb
;-------------------------------------------
draw_limb:
;Compute actor limb index
.C:2370  A5 D8       LDA actor
.C:2372  0A          ASL A
.C:2373  0A          ASL A
.C:2374  0A          ASL A
.C:2375  18          CLC
.C:2376  6D 41 FC    ADC current_actor_limb
.C:2379  AA          TAX
;Get the flip state for the actor limb, save it in current_limb_flip
.C:237a  BD 05 FC    LDA actor_limb_flip,X
.C:237d  8D 25 FC    STA current_limb_flip
;Apply displacement from _previous_ cell to vertical position, if needed
.C:2380  A5 3F       LDA current_sprite_y_pos
.C:2382  38          SEC
.C:2383  ED 04 FC    SBC intercell_vertical_displacement
.C:2386  85 3F       STA current_sprite_y_pos
;Calculate the cell pointer
.C:2388  20 D8 23    JSR calculate_sprite_cell_ptr
;BLit the limb cell
.C:238b  20 91 1E    JSR blit_and_mask_limb
;Do we have a vertical offset that is lower in the screen than the previous one?
;That is, do we have a vertical offset that is _higher_ in value?
.C:238e  A5 35       LDA vertical_offset
.C:2390  CD 55 CB    CMP sprite_vertical_offset
.C:2393  90 05       BCC next_limb
.C:2395  F0 03       BEQ next_limb
;If so, save it
.C:2397  8D 55 CB    STA sprite_vertical_offset
;-------------------------------------------
next_limb:
.C:239a  EE 41 FC    INC current_actor_limb
.C:239d  A9 08       LDA #$08
.C:239f  CD 41 FC    CMP current_actor_limb
.C:23a2  D0 CC       BNE draw_limb
.C:23a4  20 2C 24    JSR update_actor_sprite_vertical_positions_for_buffer
.C:23a7  60          RTS
;===========================================
; Copy sprite data from source (sprite_data_ptr) to destination (sprite_cell_ptr)
;
; Arguments:	sprite_data_ptr		Base pointer to input sprite data
;				sprite_cell_ptr		Base pointer to destination sprite cell
;
; Multicolor sprites (as used in the game) take up 2 bits per pixel and are 12 pixels wide
; This means that 3 bytes of memory (24 bits) make up one row of a sprite
; Sprites are 21 rows high
; This routine copies 7 rows only, which is exactly a vertical third of a sprite
;
;===========================================
sprite_data_ptr = $80
sprite_cell_ptr = $7e
row_counter = $cb54
temp_x = $2501

copy_vertical_third_of_sprite_data:
;Save original value of .X
.C:23a8  8E 01 25    STX temp_x
;Use .X as row counter, initialize it to #00
.C:23ab  A2 00       LDX #$00
.C:23ad  8E 54 CB    STX row_counter
next_group:
;Read the copy offset for this row
.C:23b0  BD FA 24    LDA copy_offsets,X
;Set the copy offset into .Y
.C:23b3  A8          TAY
.C:23b4  20 0C 24    JSR set_sprite_ptr_for_row					
.C:23b7  20 1E 24    JSR set_sprite_cell_ptr_address_as_sprite_data_ptr_minus_1
;Use .Y as the byte offset (in the range #02-#00, as 3 bytes make a whole row)
.C:23ba  A0 02       LDY #$02
;Copy the byte
.C:23bc  B1 80       LDA (sprite_data_ptr),Y
.C:23be  91 7E       STA (sprite_cell_ptr),Y
;Move to the next one
.C:23c0  88          DEY
;Repeat for the next 2 bytes
.C:23c1  B1 80       LDA (sprite_data_ptr),Y
.C:23c3  91 7E       STA (sprite_cell_ptr),Y
.C:23c5  88          DEY
.C:23c6  B1 80       LDA (sprite_data_ptr),Y
.C:23c8  91 7E       STA (sprite_cell_ptr),Y
;Move to the next row
.C:23ca  EE 54 CB    INC row_counter
;Are there rows pending? If not, exit
.C:23cd  AE 54 CB    LDX row_counter
.C:23d0  E0 07       CPX #$07
.C:23d2  D0 DC       BNE next_group
;Restore original value of .X
.C:23d4  AE 01 25    LDX temp_x
.C:23d7  60          RTS
;===========================================
; Calculates the pointer to the animation cell for the actor's sprite
;
; This takes into consideration:
;
;	-the current actor_limb (a combination of current actor and current limb)
;	-the current animation frame for the limb
;	-the current base cell number for the limb
;
; The base cell number for a limb is an index into the "limb cell" list,
; which contains cell numbers for each limb, for each frame.
; It's actually a list of lists.
;
; The format of the list is:

; 	<list_of_cells_0>
;	<list_of_cells_1>
;	...
;	<list_of_cells_n>
;
;	Each list contains cell numbers, one after the other.
;	Each list is terminated by an #FF byte.
;
;	actor_limb_base_cell_0:	cell_for_frame0 cell_for_frame1 ... cell_for_framen 0xFF
;	actor_limb_base_cell_1:
; Input:	actor_limb_animation_frame
;			actor_limb_current_cell
;===========================================
graphic_section_offset = $82
limb_cell_list = $84
offset_hi = $fc3b
sprite_cell_ptr = $7e

calculate_sprite_cell_ptr:
;Compute the actor_limb index into .X
.C:23d8  AD 36 FC    LDA actor_index_8th_multiple
.C:23db  18          CLC
.C:23dc  6D 41 FC    ADC current_actor_limb
.C:23df  AA          TAX
;------------------------------------------------------
;Add the animation frame index to the current base cell index
;The result is an index into the cell list
.C:23e0  BD 42 FC    LDA actor_limb_animation_frame,X
.C:23e3  18          CLC
.C:23e4  7D 62 FC    ADC actor_limb_current_cell,X
.C:23e7  A8          TAY
;------------------------------------------------------
;Load the desired cell index from the cell list
.C:23e8  B1 84       LDA (limb_cell_list),Y
.C:23ea  A8          TAY
;------------------------------------------------------
;Load the low byte for the cell's address
.C:23eb  B1 82       LDA (graphic_section_offset),Y
;Save low byte in .Y
.C:23ed  A8          TAY
;Add cell_addresses_hi_offset to get the offset into the hi byte
.C:23ee  18          CLC
.C:23ef  6D 53 CB    ADC cell_addresses_hi_offset
;Save result in offset_hi
.C:23f2  8D 3B FC    STA offset_hi
;------------------------------------------------------
;Restore low byte from .Y, add 2, save into .Y again
.C:23f5  98          TYA
.C:23f6  18          CLC
.C:23f7  6D 52 CB    ADC constant_02
.C:23fa  A8          TAY
;------------------------------------------------------
;Add the low byte of the offset to the base address (graphic_section_offset)
; to get the low part of the cell's _absolute_ address
.C:23fb  B1 82       LDA (graphic_section_offset),Y
.C:23fd  18          CLC
.C:23fe  65 82       ADC <graphic_section_offset
.C:2400  85 7E       STA <sprite_cell_ptr
;Add the hi byte of the offset to the base address (graphic_section_offset)
; to get the hi part of the cell's absolute address
.C:2402  AC 3B FC    LDY offset_hi
.C:2405  B1 82       LDA (graphic_section_offset),Y
.C:2407  65 83       ADC >graphic_section_offset
.C:2409  85 7F       STA >sprite_cell_ptr
.C:240b  60          RTS
;===========================================
; Sets the sprite pointer for the specified row
;
; Arguments:	.Y						row number
;				actor_sprite_base		base address of sprite
; Returns: 		sprite_data_ptr = actor_sprite_base + sprite_row_offsets[row]
;===========================================
sprite_data_ptr = $80

set_sprite_ptr_for_row:
;Get the byte offset for the desired row (low byte)
.C:240c  B9 A8 D5    LDA sprite_row_offsets_lo,Y
;Add it to the base address and save result in sprite_data_ptr
.C:240f  18          CLC
.C:2410  6D 2E FC    ADC <actor_sprite_base
.C:2413  85 80       STA <sprite_data_ptr
;Repeat with the high byte
.C:2415  B9 08 D5    LDA sprite_row_offsets_hi,Y
.C:2418  6D 2F FC    ADC >actor_sprite_base
.C:241b  85 81       STA >sprite_data_ptr
.C:241d  60          RTS
;===========================================
; Updates sprite_cell_ptr
; sprite_cell_ptr = sprite_data_ptr - 1
;===========================================
sprite_cell_ptr = $7e
sprite_data_ptr = $80

set_sprite_cell_ptr_address_as_sprite_data_ptr_minus_1:
.C:241e  A5 80       LDA <sprite_data_ptr
.C:2420  38          SEC
.C:2421  E9 00       SBC #$00
.C:2423  85 7E       STA <sprite_cell_ptr
.C:2425  A5 81       LDA >sprite_data_ptr
.C:2427  E9 01       SBC #$01
.C:2429  85 7F       STA >sprite_cell_ptr
.C:242b  60          RTS
;===========================================
; Updates an actor's sprite vertical position and offset
; for the current sprite buffer in use
;
; Arguments:	sprite_buffer
;				actor
;===========================================
update_actor_sprite_vertical_positions_for_buffer:
;Use .X as actor index, .Y as sprite index
.C:242c  A6 D8       LDX actor
.C:242e  BC 32 FC    LDY actor_sprite_index,X
;Switch based on the sprite buffer in use (#00 or #01)
.C:2431  AD 14 FD    LDA sprite_buffer
.C:2434  F0 0E       BEQ sprite_buffer_00
;------------------------------------------------------
sprite_buffer_01:
;Set the vertical offset
.C:2436  AD 55 CB    LDA sprite_vertical_offset
.C:2439  99 85 FD    STA buffer_01_vertical_offset_for_sprite,Y
;Set the vertical position
.C:243c  A5 3F       LDA current_sprite_y_pos
.C:243e  99 81 FD    STA buffer_01_y_position_for_sprite,Y
.C:2441  4C 4F 24    JMP save_vertical_offset_for_actor
;------------------------------------------------------
sprite_buffer_00:
;Set the vertical offset
.C:2444  AD 55 CB    LDA sprite_vertical_offset
.C:2447  99 8D FD    STA buffer_00_vertical_offset_for_sprite,Y
;Set the vertical position
.C:244a  A5 3F       LDA current_sprite_y_pos
.C:244c  99 89 FD    STA buffer_00_y_position_for_sprite,Y
;------------------------------------------------------
save_vertical_offset_for_actor:
;Save the vertical offset for this actor
.C:244f  AD 55 CB    LDA sprite_vertical_offset
.C:2452  9D 4F FD    STA max_vertical_offset_for_actor,X
.C:2455  60          RTS
;===========================================
; Set an actor's sprite's base address
;
; There are 2 sets of sprites used. 
; One starts at $E000, the other one at $E800.
; This is used as a kind of double buffering to modify one set of sprites while the other is being rendered on screen.
; sprite_buffer specifies which "sprite set" is in use.
;
; Each sprite occupies 64 bytes, so once the "sprite set" base address is determined,
; we simply have to multiply the sprite index by 64 and add it to the base address.
;
; multiple_64_lo/hi are precalculated multiples of 64
;
; Input:	.Y				sprite index
;			sprite_buffer	sprite buffer set in use (#00 or #01)
;
; Output:	actor_sprite_base =	sprite_set_base + [64 * sprite_index]
;===========================================
set_actor_sprite_base_address:
.C:2456  B9 EA 24    LDA multiple_64_lo,Y
.C:2459  8D 2E FC    STA <actor_sprite_base
.C:245c  B9 F2 24    LDA multiple_64_hi,Y
.C:245f  18          CLC
.C:2460  AC 14 FD    LDY sprite_buffer
.C:2463  F0 05       BEQ add_e8
.C:2465  69 E0       ADC #$E0
.C:2467  4C 6C 24    JMP set_pointer_hi
add_e8:
.C:246a  69 E8       ADC #$E8
set_pointer_hi:
.C:246c  8D 2F FC    STA >actor_sprite_base
.C:246f  60          RTS
;===========================================
; Setup costume for actor
;
; This routine will setup the essential addresses needed
; to decode animation data from a costume resource.
;
; This includes:
;
;	-the start of the graphic section
;	-the start of the "limb cell" list
;	-the start of the "animation sets" list
;
; Arguments:	active_costume						index of the active costume
; Returns:		current_costume_ptr_for_costume
;				graphic_data_ptr_for_actor
;				limb_cell_list_for_actor
;				animation_sets_for_actor
;===========================================
costume_base_address = $17

setup_costume_for_actor:
;Is there an actor assigned for this costume? If not, exit
.C:2470  AE 30 FC    LDX active_costume
.C:2473  BD 57 FE    LDA actor_for_costume,X
.C:2476  10 01       BPL check_if_new_costume_for_actor
.C:2478  60          RTS
;------------------------------------------------------
check_if_new_costume_for_actor:
;Is the current costume resource pointer already the one we want?
;If so, exit
.C:2479  BD 61 78    LDA costume_rsrc_ptrs_hi,X
.C:247c  DD 93 78    CMP rsrc_ptr_for_active_costume_hi,X
.C:247f  D0 09       BNE compute_data_pointer
.C:2481  BD 7A 78    LDA costume_rsrc_ptrs_lo,X
.C:2484  DD AC 78    CMP rsrc_ptr_for_active_costume_lo,X
.C:2487  D0 01       BNE compute_data_pointer
.C:2489  60          RTS
;------------------------------------------------------
compute_data_pointer:
;Save actor index in stack
.C:248a  8A          TXA
.C:248b  48          PHA
;Use .Y as actor index, .X as costume index
;Copy the costume resource address to costume_base_address
.C:248c  BD 61 78    LDA costume_rsrc_ptrs_hi,X
.C:248f  BC 57 FE    LDY actor_for_costume,X
.C:2492  99 46 CB    STA graphic_data_ptr_for_actor_hi,Y
.C:2495  85 18       STA >costume_base_address
.C:2497  BD 7A 78    LDA costume_rsrc_ptrs_lo,X
.C:249a  85 17       STA <costume_base_address
;Add 9 to the base address to get the address of the graphic section start (past the metadata section)
.C:249c  18          CLC
.C:249d  69 09       ADC #$09
.C:249f  99 42 CB    STA graphic_data_ptr_for_actor_lo,Y
;Add carry to the hi byte, if needed
.C:24a2  90 08       BCC set_new_costume_ptr_for_actor
.C:24a4  B9 46 CB    LDA graphic_data_ptr_for_actor_hi,Y
.C:24a7  69 00       ADC #$00
.C:24a9  99 46 CB    STA graphic_data_ptr_for_actor_hi,Y
;------------------------------------------------------
set_new_costume_ptr_for_actor:
;Set the costume pointer as the current costume pointer
.C:24ac  BD 61 78    LDA costume_rsrc_ptrs_hi,X
.C:24af  9D 93 78    STA rsrc_ptr_for_active_costume_hi,X
.C:24b2  BD 7A 78    LDA costume_rsrc_ptrs_lo,X
.C:24b5  9D AC 78    STA rsrc_ptr_for_active_costume_lo,X
;------------------------------------------------------
;Use .X now as actor index and .Y as read offset
.C:24b8  98          TYA
.C:24b9  AA          TAX
;Read from offset #04 - the value read is the offset to the start of the "hi byte" list of the cell addresses
.C:24ba  A0 04       LDY #$04
.C:24bc  B1 17       LDA (costume_base_address),Y
.C:24be  9D 4A CB    STA cell_addresses_hi_offset_for_actor,X
;------------------------------------------------------
;Read from offsets #05 and #06
;The values read are offsets into the limb cell list start, relative to the graphic data section start
;By adding the graphic data pointer, we get the actual addresses of the limb cell list
.C:24c1  C8          INY
.C:24c2  B1 17       LDA (costume_base_address),Y
.C:24c4  18          CLC
.C:24c5  7D 42 CB    ADC graphic_data_ptr_for_actor_lo,X
.C:24c8  9D 3A CB    STA limb_cell_list_for_actor_lo,X
.C:24cb  C8          INY
.C:24cc  B1 17       LDA (costume_base_address),Y
.C:24ce  7D 46 CB    ADC graphic_data_ptr_for_actor_hi,X
.C:24d1  9D 3E CB    STA limb_cell_list_for_actor_hi,X
;------------------------------------------------------
;Read from offsets #07 and #08
;The values read are offsets into the animation sets list start, relative to the graphic data section start
;By adding the graphic data pointer, we get the actual addresses of the animation sets list
.C:24d4  C8          INY
.C:24d5  B1 17       LDA (costume_base_address),Y
.C:24d7  18          CLC
.C:24d8  7D 42 CB    ADC graphic_data_ptr_for_actor_lo,X
.C:24db  9D 90 FE    STA animation_sets_for_actor_lo,X
.C:24de  C8          INY
.C:24df  B1 17       LDA (costume_base_address),Y
.C:24e1  7D 46 CB    ADC graphic_data_ptr_for_actor_hi,X
.C:24e4  9D 94 FE    STA animation_sets_for_actor_hi,X
.C:24e7  68          PLA
.C:24e8  AA          TAX
.C:24e9  60          RTS
;===========================================
multiple_64_lo = $24ea
.C:24ea  00 40 80 C0 00 40 80 C0
multiple_64_hi = $24f2
.C:24f2  00 00 00 00 01 01 01 01
copy_offsets: 
.C:24fa  0B 1F 33 47 5B 6F 83
;11, 31, 51, 71, 91, 111, 131

.C:2501  00
.C:2502  00
.C:2503  00
;===========================================
; Animate all actor's limbs
;
; Arguments:	active_costume
; Returns:		None
;===========================================
animate_actor_limbs:
;Setup the costume resource for the actor, if needed
.C:2504  20 70 24    JSR setup_costume_for_actor
;Handle speaking animation, if needed
.C:2507  20 F9 26    JSR animate_character_speaking
;Setup the cell list for this actor
.C:250a  20 DD 25    JSR setup_limb_cell_list
.C:250d  20 D3 25    JSR compute_actor_index_8th_multiple
;Init current_actor_limb to #00
.C:2510  A9 00       LDA #$00
.C:2512  8D 41 FC    STA current_actor_limb
animate_actor_limb:
;Update the base cell for this limb
.C:2515  20 8E 25    JSR update_limb_base_cell
;Animate the limb as needed
.C:2518  20 26 25    JSR animate_limb
;Move to the next limb
.C:251b  EE 41 FC    INC current_actor_limb
;Are there limbs pending? If so, continue - otherwise, exit
.C:251e  A9 08       LDA #$08
.C:2520  CD 41 FC    CMP current_actor_limb
.C:2523  D0 F0       BNE animate_actor_limb
.C:2525  60          RTS
;===========================================
; Animate a limb to its next animation 
;
; If the next animation frame points to an #FF value in the cell list,
; then the animation has exhausted its frames.
;
; The animation argument will dictate whether to:
;
;	-repeat the animation from the first frame (argument == #FF)
;	-or stop the animation (argument == #00)
;
; Arguments:	actor_index_8th_multiple
;				current_actor_limb
;				actor_limb_animation_frame
;				actor_limb_current_cell
;				actor_limb_current_argument
;===========================================
limb_cell_list = $84
actor_limb_animation_frame = $fc42
actor_limb_temp = $2502
previous_actor_limb_frame = $fc3b

animate_limb:
;Compute the actor_limb index into .X
.C:2526  AD 36 FC    LDA actor_index_8th_multiple
.C:2529  18          CLC
.C:252a  6D 41 FC    ADC current_actor_limb
.C:252d  AA          TAX
;Get the current animation frame index for the actor limb
.C:252e  BD 42 FC    LDA actor_limb_animation_frame,X
;Save it
.C:2531  8D 3B FC    STA previous_actor_limb_frame
;Increment the animation frame index
.C:2534  FE 42 FC    INC actor_limb_animation_frame,X
;Get the limb cell index for the new animation frame
.C:2537  BD 42 FC    LDA actor_limb_animation_frame,X
.C:253a  18          CLC
.C:253b  7D 62 FC    ADC actor_limb_current_cell,X
.C:253e  A8          TAY
.C:253f  B1 84       LDA (limb_cell_list),Y
;Is it #FF? If so, then we have reached the end of the animation frames
.C:2541  C9 FF       CMP #$FF
.C:2543  D0 36       BNE move_animation_state_if_needed
;Do we need to loop the animation?
.C:2545  BD C2 FC    LDA actor_limb_current_argument,X
.C:2548  F0 0C       BEQ stop_animation
.C:254a  C9 FF       CMP #$FF
.C:254c  F0 03       BEQ loop_from_first
.C:254e  DE C2 FC    DEC actor_limb_current_argument,X
loop_from_first:
.C:2551  A9 00       LDA #$00
.C:2553  4C 78 25    JMP set_new_frame
stop_animation:
;Go back to the previous frame number (which was the last one valid)
.C:2556  DE 42 FC    DEC actor_limb_animation_frame,X
;Save the actor limb index
.C:2559  8E 02 25    STX actor_limb_temp
;---------------------------------------------------
;Deactivate desired and current animation sets
.C:255c  A6 D8       LDX actor
.C:255e  A9 FF       LDA #$FF
.C:2560  9D 06 FD    STA desired_animation_set_for_actor,X
.C:2563  A9 FF       LDA #$FF
.C:2565  9D 02 FD    STA current_animation_set_for_actor,X
;Deactivate desired and current base cells for this limb
.C:2568  AE 02 25    LDX actor_limb_temp
.C:256b  A9 FF       LDA #$FF
.C:256d  9D A2 FC    STA actor_limb_desired_base_cell,X
.C:2570  A9 FF       LDA #$FF
.C:2572  9D 82 FC    STA actor_limb_current_base_cell,X
;---------------------------------------------------
;Load the frame number
.C:2575  BD 42 FC    LDA actor_limb_animation_frame,X
set_new_frame:
.C:2578  9D 42 FC    STA actor_limb_animation_frame,X
move_animation_state_if_needed:
;Did we change the limb frame?
.C:257b  AD 3B FC    LDA previous_actor_limb_frame
.C:257e  DD 42 FC    CMP actor_limb_animation_frame,X
;If not, exit
.C:2581  F0 0A       BEQ exit
;Otherwise, refresh animation
.C:2583  A6 D8       LDX actor
.C:2585  BD 97 FD    LDA animation_state_for_actor,X
.C:2588  09 01       ORA #$01
.C:258a  9D 97 FD    STA animation_state_for_actor,X
exit:
.C:258d  60          RTS
;===========================================
; Updates a base cell for an actor limb, if needed
;
; 
; Arguments:	actor_index_8th_multiple
;				current_actor_limb
;				actor_limb_desired_base_cell
;				actor_limb_desired_argument
;===========================================
limb_cell_list = $84
actor_limb_current_base_cell = $fc82

update_limb_base_cell:
;Compute the actor_limb index into .X
.C:258e  AD 36 FC    LDA actor_index_8th_multiple
.C:2591  18          CLC
.C:2592  6D 41 FC    ADC current_actor_limb
.C:2595  AA          TAX
;Is there a new desired base cell? If not, exit
.C:2596  BD A2 FC    LDA actor_limb_desired_base_cell,X
.C:2599  C9 FF       CMP #$FF
.C:259b  D0 01       BNE check_for_new_value
.C:259d  60          RTS
check_for_new_value:
;Is it different than the current one? If not, exit
.C:259e  DD 82 FC    CMP actor_limb_current_base_cell,X 
.C:25a1  D0 01       BNE assign_new_base_cell
.C:25a3  60          RTS
assign_new_base_cell:
;Set the desired values of base cell and argument as the new current ones
.C:25a4  BD A2 FC    LDA actor_limb_desired_base_cell,X
.C:25a7  9D 82 FC    STA actor_limb_current_base_cell,X
.C:25aa  BD E2 FC    LDA actor_limb_desired_argument,X
.C:25ad  9D C2 FC    STA actor_limb_current_argument,X
.C:25b0  20 C3 25    JSR compute_actor_limb_current_cell
;Initialize the animation frame for the limb
.C:25b3  A9 00       LDA #$00
.C:25b5  9D 42 FC    STA actor_limb_animation_frame,X
;Refresh animation
.C:25b8  A6 D8       LDX actor
.C:25ba  BD 97 FD    LDA animation_state_for_actor,X
.C:25bd  09 01       ORA #$01
.C:25bf  9D 97 FD    STA animation_state_for_actor,X
.C:25c2  60          RTS
;===========================================
; Arguments:	.X		actor_limb index
;				current_actor_limb
;===========================================
actor_limb_current_cell = $fc62

compute_actor_limb_current_cell:
.C:25c3  AC 41 FC    LDY current_actor_limb
;Get the base address for the limb index
.C:25c6  B1 84       LDA (limb_cell_list),Y
;Add the current base cell for the limb, store resulting offset into .Y
.C:25c8  18          CLC
.C:25c9  7D 82 FC    ADC actor_limb_current_base_cell,X
.C:25cc  A8          TAY
;Get the limb cell index
.C:25cd  B1 84       LDA (limb_cell_list),Y
;Store it as the current cell
.C:25cf  9D 62 FC    STA actor_limb_current_cell,X
.C:25d2  60          RTS
;===========================================
; Multiplies the current actor index by 8
;
; This is used in multiple animation routines.
;
; Arguments:	actor
; Returns:		actor_index_8th_multiple
;===========================================
compute_actor_index_8th_multiple:
.C:25d3  A5 D8       LDA actor
.C:25d5  18          CLC
.C:25d6  0A          ASL A
.C:25d7  0A          ASL A
.C:25d8  0A          ASL A
.C:25d9  8D 36 FC    STA actor_index_8th_multiple
.C:25dc  60          RTS
;===========================================
; Set the current limb cell list address for the current actor.
;
; Arguments:	actor
; Returns:		limb_cell_list
;===========================================
limb_cell_list = $84

setup_limb_cell_list:
.C:25dd  A6 D8       LDX actor
.C:25df  BD 3A CB    LDA limb_cell_list_for_actor_lo,X
.C:25e2  85 84       STA <limb_cell_list
.C:25e4  BD 3E CB    LDA limb_cell_list_for_actor_hi,X
.C:25e7  85 85       STA >limb_cell_list
.C:25e9  60          RTS
;===========================================
; Unused routine
;===========================================
;Compute the actor_limb index into .X
.C:25ea  20 D3 25    JSR compute_actor_index_8th_multiple
.C:25ed  18          CLC
.C:25ee  6D 41 FC    ADC current_actor_limb
.C:25f1  AA          TAX
.C:25f2  AD 12 FD    LDA $FD12
.C:25f5  9D A2 FC    STA actor_limb_desired_base_cell,X
.C:25f8  AD 13 FD    LDA $FD13
.C:25fb  9D E2 FC    STA actor_limb_desired_argument,X
.C:25fe  60          RTS
;===========================================
; Applies base limb cells for an actor, based on the animation set
;
; Arguments:	actor
;				desired_animation_set_for_actor
;				current_animation_set_for_actor
;				animation_argument_for_actor
;
; Returns:		actor_limb_desired_base_cell
;				actor_limb_current_base_cell
;				actor_limb_flip
;				actor_limb_desired_argument
;
; This routine will:
;	-load the desired animation set for the active actor
;	-if there isn't a desired set, it will exit
;	-cache the animation sets list pointer for the actor
;	-check if the desired animation set is new (different than the current one) - if it isn't, it will exit
;	-set the desired animation set as the current one
;
;	-for each of the 8 actor limbs
;		-load the animation cell index, set it as the desired base cell 
;		-set the horizontal flip for the limb as needed
;		-clear the current base cell for the limb
;		-copy the animation argument as the desired argument for the limb
;===========================================
actor_limb_temp = $fc3b
animation_sets = $17
limb_index = $2503
actor_limb_flip = $fc05

apply_base_cells_for_limbs:
;Setup the costume for this actor, if needed
.C:25ff  20 70 24    JSR setup_costume_for_actor
;Load the desired animation set for this actor
.C:2602  A6 D8       LDX actor
.C:2604  BD 06 FD    LDA desired_animation_set_for_actor,X
;If there's no valid desired animation set, exit
.C:2607  C9 FF       CMP #$FF
.C:2609  D0 01       BNE check_for_new_animation_set
.C:260b  60          RTS
;-----------------------------------------------------
check_for_new_animation_set:
;Copy the animation sets list pointer for this actor
.C:260c  BD 90 FE    LDA animation_sets_for_actor_lo,X
.C:260f  85 17       STA <animation_sets
.C:2611  BD 94 FE    LDA animation_sets_for_actor_hi,X
.C:2614  85 18       STA >animation_sets
;Does the desired animation set match the current one? If so, nothing to do, exit
.C:2616  BD 06 FD    LDA desired_animation_set_for_actor,X
.C:2619  DD 02 FD    CMP current_animation_set_for_actor,X
.C:261c  D0 01       BNE assign_new_animation_set
.C:261e  60          RTS
;-----------------------------------------------------
assign_new_animation_set:
;There's a new animation set desired, set it as current
.C:261f  9D 02 FD    STA current_animation_set_for_actor,X
;Use .Y as the index into the animation set
;.Y = current_animation_set_for_actor * 8
; Each animation set is a list of initial frames for each limb (8 in total)
.C:2622  0A          ASL A
.C:2623  0A          ASL A
.C:2624  0A          ASL A
.C:2625  A8          TAY
;Pre-compute actor_index_8th_multiple = actor index * 8 
.C:2626  20 D3 25    JSR compute_actor_index_8th_multiple
;-----------------------------------------------------
;Use .X as limb index
.C:2629  A2 00       LDX #$00
.C:262b  8E 03 25    STX limb_index
prepare_limb_frame:
;Compute "actor_limb" index into .X = actor * 8 + limb_index
.C:262e  18          CLC
.C:262f  AD 03 25    LDA limb_index
.C:2632  6D 36 FC    ADC actor_index_8th_multiple
.C:2635  AA          TAX
;.C:2636  AD 03 25    LDA limb_index ;Redundant code
;Load the frame for this limb in this animation set
.C:2639  B1 17       LDA (animation_sets),Y
;Is bit 7 clear?
.C:263b  10 23       BPL bit7_clear
bit7_set:
;Bit 7 set
;If value is #FF, continue with next limb
.C:263d  C9 FF       CMP #$FF
.C:263f  F0 19       BEQ next_limb_2
;Clear bit 7
.C:2641  29 7F       AND #$7F
;Set the result as the base limb cell
.C:2643  9D A2 FC    STA actor_limb_desired_base_cell,X
;Is flip set?
.C:2646  BD 05 FC    LDA actor_limb_flip,X
.C:2649  C9 80       CMP #$80
.C:264b  F0 05       BEQ set_horizontal_flip
.C:264d  A9 FF       LDA #$FF
.C:264f  9D 82 FC    STA actor_limb_current_base_cell,X
set_horizontal_flip:
;Set the flip
.C:2652  A9 80       LDA #$80
.C:2654  9D 05 FC    STA actor_limb_flip,X
.C:2657  4C 74 26    JMP copy_animation_argument
next_limb_2:
.C:265a  4C 82 26    JMP next_limb
;.C:265d  4C 74 26    JMP $2674		;Unreachable code
;-----------------------------------------------------
bit7_clear:
;Set the base limb cell
.C:2660  9D A2 FC    STA actor_limb_desired_base_cell,X
;Is flip clear?
.C:2663  BD 05 FC    LDA actor_limb_flip,X
.C:2666  C9 00       CMP #$00
.C:2668  F0 05       BEQ clear_horizontal_flip
.C:266a  A9 FF       LDA #$FF
.C:266c  9D 82 FC    STA actor_limb_current_base_cell,X
clear_horizontal_flip:
;Clear the flip
.C:266f  A9 00       LDA #$00
.C:2671  9D 05 FC    STA actor_limb_flip,X
copy_animation_argument:
;Save the actor limb index (.X) into a variable temporarily
.C:2674  8E 3B FC    STX actor_limb_temp
;Load the animation argument for this actor
.C:2677  A6 D8       LDX actor
.C:2679  BD 0A FD    LDA animation_argument_for_actor,X
;Restore the actor limb index and save the animation argument for this actor limb
.C:267c  AE 3B FC    LDX actor_limb_temp
.C:267f  9D E2 FC    STA actor_limb_desired_argument,X
;-----------------------------------------------------
next_limb:
;Move .Y to the next limb element in the animation set
.C:2682  C8          INY
;Are there limbs pending? If so, continue with the next one
.C:2683  EE 03 25    INC limb_index
.C:2686  AD 03 25    LDA limb_index
.C:2689  C9 08       CMP #$08
.C:268b  D0 A1       BNE prepare_limb_frame
;-----------------------------------------------------
.C:268d  A6 D8       LDX actor
.C:268f  BD 02 FD    LDA current_animation_set_for_actor,X
.C:2692  C9 08       CMP #$08
.C:2694  B0 05       BCS exit
.C:2696  29 03       AND #$03
.C:2698  9D 0E FD    STA $FD0E,X	;Animation direction (N/S/E/W) - apparently unused
exit:
.C:269b  60          RTS
;===========================================
; Put a costume directly at a destination (that is, "teleport" it instead of walking).
; This is used in scripts.
; After moving it, the costume gets released.
; If the destination room is the current room, it gets assigned to an available actor again. 
;===========================================
unused_var_1 = $26f7
unused_var_2 = $26f8

put_actor_at_destination:
;Copy the room for this costume
.C:269c  AE 30 FC    LDX active_costume
.C:269f  AD EA FD    LDA room_destination
.C:26a2  9D FC FE    STA room_for_character,X
;Copy the destination coordinates
.C:26a5  AD E6 FD    LDA x_destination
.C:26a8  9D 2E FF    STA costume_x_destination,X
.C:26ab  AD E7 FD    LDA y_destination
.C:26ae  9D 15 FF    STA costume_y_destination,X
;Unused variables
.C:26b1  AD E6 FD    LDA x_destination
.C:26b4  8D F7 26    STA unused_var_1
.C:26b7  AD E7 FD    LDA y_destination
.C:26ba  8D F8 26    STA unused_var_2
;Is there an assigned actor for this costume?
.C:26bd  BC 57 FE    LDY actor_for_costume,X
.C:26c0  30 24       BMI check_current_room
;An actor is assigned
;Is the destination the same as the current position? If so, exit
.C:26c2  BD 2E FF    LDA costume_x_destination,X
.C:26c5  D9 41 FD    CMP position_x_for_actor,Y
.C:26c8  D0 08       BNE move_actor
.C:26ca  BD 15 FF    LDA costume_y_destination,X
.C:26cd  D9 3D FD    CMP position_y_for_actor,Y
.C:26d0  F0 24       BEQ exit
move_actor:
;Destination not the same, set the position
.C:26d2  BD 2E FF    LDA costume_x_destination,X
.C:26d5  99 41 FD    STA position_x_for_actor,Y
.C:26d8  BD 15 FF    LDA costume_y_destination,X
.C:26db  99 3D FD    STA position_y_for_actor,Y
;Set default direction to down
.C:26de  A9 80       LDA #$80
.C:26e0  99 EB FD    STA path_direction_for_actor,Y
;Release it (assuming that it's not in the current room)
.C:26e3  20 E4 38    JSR release_costume
check_current_room:
;Is the destination rooom the current room? If not, exit
.C:26e6  AD EA FD    LDA room_destination
.C:26e9  F0 0B       BEQ exit
.C:26eb  CD 49 71    CMP current_room
.C:26ee  D0 06       BNE exit
;It's the current room, so we need to assign an actor
;Assign an available actor to the costume
.C:26f0  AE 30 FC    LDX active_costume
.C:26f3  20 11 39    JSR assign_available_actor
exit:
.C:26f6  60          RTS
;===========================================
; Animate a character that is speaking
;
; Arguments:	active_costume
;				character_animation_settings
;				mouth_state_for_actor
;
; If the character does not have a speaking animation, it will exit.
; The animation set for the current direction will be computed first.
;
; Then, depending on whether the mouth is open or closed, a value will be added
; to the animation set (#10 if mouth is closed, #0C if mouth is open).
;
; The resulting value will be the speaking animation set, which will be setup as needed.
;===========================================
animate_character_speaking:
;Check if the character animates when speaking (bit 7 clear of character_animation_settings)
.C:26f9  AE 30 FC    LDX active_costume
.C:26fc  BD D9 F0    LDA character_animation_settings,X
.C:26ff  10 01       BPL do_animate
;If not, exit
.C:2701  60          RTS
do_animate:
;Convert direction to base animation set index
.C:2702  A6 D8       LDX actor
.C:2704  20 7E 27    JSR get_animation_set_for_direction
.C:2707  18          CLC
;Check mouth state for the actor to determine mouth graphic
.C:2708  BC 9D FE    LDY mouth_state_for_actor,X
;Bit 7 set = mouth open (states #80 and #FF)
.C:270b  30 05       BMI mouth_open
mouth_closed:
;Bit 7 clear = mouth closed (states #00 and #01)
;Add #10 to the direction animation set to get the "mouth closed" animation set
.C:270d  69 10       ADC #$10
.C:270f  4C 14 27    JMP set_mouth_graphic
mouth_open:
;Add #0C to the direction animation set to get the "mouth open" animation set
.C:2712  69 0C       ADC #$0C
set_mouth_graphic:
.C:2714  8D E9 FD    STA desired_animation_set
;Set animation to "don't loop"
.C:2717  A9 FF       LDA #$FF
.C:2719  8D E8 FD    STA animation_argument
;Apply animation set
.C:271c  20 20 27    JSR apply_animation_set
.C:271f  60          RTS
;===========================================
; Applies a new animation set for a costume
;
; Arguments:	active_costume
;				desired_animation_set
;
; If the costume is not visible, it will set the animation set outright.
; If it's visible, it will:
;	-set the desired animation set and arguments
;	-update the actor's limbs
;	-compute the actor's direction
;===========================================
apply_animation_set:
;Is there an assigned actor for this costume?
;If not, the actor is not visible right now - skip this section
.C:2720  AE 30 FC    LDX active_costume
.C:2723  BD 57 FE    LDA actor_for_costume,X
.C:2726  30 42       BMI actor_unassigned
;Use .X as actor index
.C:2728  85 D8       STA actor
.C:272a  AA          TAX
;Save the desired animation set for this actor
.C:272b  AD E9 FD    LDA desired_animation_set
.C:272e  9D 06 FD    STA desired_animation_set_for_actor,X
;Save the desired animation argument for this actor
.C:2731  AD E8 FD    LDA animation_argument
.C:2734  9D 0A FD    STA animation_argument_for_actor,X
;Update limbs' base cells
.C:2737  20 FF 25    JSR apply_base_cells_for_limbs
;-------------------------
;Map animation set to path direction
.C:273a  AD E9 FD    LDA desired_animation_set
.C:273d  C9 04       CMP #$04
.C:273f  D0 05       BNE check_05
;Actor moving left
.C:2741  A9 01       LDA #$01
.C:2743  4C 62 27    JMP direction_determined
check_05:
.C:2746  C9 05       CMP #$05
.C:2748  D0 05       BNE check_06
;Actor moving right
.C:274a  A9 00       LDA #$00
.C:274c  4C 62 27    JMP direction_determined
check_06:
.C:274f  C9 06       CMP #$06
.C:2751  D0 05       BNE check_07
;Actor moving down
.C:2753  A9 80       LDA #$80
.C:2755  4C 62 27    JMP direction_determined
check_07:
.C:2758  C9 07       CMP #$07
.C:275a  D0 05       BNE default
;Actor moving up
.C:275c  A9 81       LDA #$81
.C:275e  4C 62 27    JMP direction_determined
default:
.C:2761  60          RTS
;-------------------------
direction_determined:
;Save the overall direction for this actor and exit
.C:2762  A6 D8       LDX actor
.C:2764  9D EB FD    STA path_direction_for_actor,X
.C:2767  4C 7D 27    JMP exit
;-------------------------
;The actor is not visible right now - assign the animation set directly
actor_unassigned:
;Is it a standing animation set? (#04-#07)
;If not, exit
.C:276a  AD E9 FD    LDA desired_animation_set
.C:276d  C9 04       CMP #$04
.C:276f  90 0C       BCC exit
.C:2771  C9 07       CMP #$07
.C:2773  F0 02       BEQ standing_animation_set
.C:2775  B0 06       BCS exit
standing_animation_set:
;It's a standing animation set, save it for the actor
.C:2777  AE 30 FC    LDX active_costume
.C:277a  9D 47 FF    STA animation_set_for_costume,X
exit:
.C:277d  60          RTS
;===========================================
; Converts an actor direction to the base animation set index
;
;	Arguments:	.X		actor
;	Returns:	.A		animation set
;
; Maps direction like this:
;
;	#01		->	#00		left
;	#00		->	#01		right
;	#80		->	#02		down
;	#81		-> 	#03		up
;===========================================
get_animation_set_for_direction:
.C:277e  BD EB FD    LDA path_direction_for_actor,X
.C:2781  C9 01       CMP #$01
.C:2783  D0 02       BNE check_00
;Actor moving left
.C:2785  A0 00       LDY #$00
check_00:
.C:2787  C9 00       CMP #$00
.C:2789  D0 02       BNE check_00
;Actor moving right
.C:278b  A0 01       LDY #$01
check_00:
.C:278d  C9 80       CMP #$80
.C:278f  D0 02       BNE check_00
;Actor moving down
.C:2791  A0 02       LDY #$02
check_00:
.C:2793  C9 81       CMP #$81
.C:2795  D0 02       BNE return
;Actor moving up
.C:2797  A0 03       LDY #$03
return:
.C:2799  98          TYA
.C:279a  60          RTS
;===========================================
; Arguments:	message_ptr		pointer to message
;				character_talking	
;
; If character_talking is #FF, nobody is talking (just print the message
; and no talking animation is needed).
;
; To save storage, space characters are encoded into regular characters
; by setting their bit 7. If a message byte has bit 7 set,
; then the message byte is printed, and then a space as well.
;===========================================
message_ptr = $15
append_message_mode = $28c1

print_msg_for_actor:
;If character_talking's bit 7 is set, set mode #00
.C:279b  AE 9A FE    LDX character_talking
.C:279e  30 25       BMI set_mode_00
;If actor_for_costume's bit 7 is clear, skip to update_actor
.C:27a0  BD 57 FE    LDA actor_for_costume,X
.C:27a3  10 05       BPL update_actor
;Set mode to #FF - this will NOT copy the message
.C:27a5  A2 FF       LDX #$FF
.C:27a7  4C CA 27    JMP set_mode_x
update_actor:
.C:27aa  20 34 28    JSR reset_talking
.C:27ad  AE 9A FE    LDX character_talking
.C:27b0  8E 9B FE    STX message_owner
;Test bit 6 of character_animation_settings
.C:27b3  BD D9 F0    LDA character_animation_settings,X
.C:27b6  29 40       AND #$40
.C:27b8  D0 08       BNE set_mode_x2
.C:27ba  BC 57 FE    LDY actor_for_costume,X
;Set mouth state to #01 (open)
.C:27bd  A9 01       LDA #$01
.C:27bf  99 9D FE    STA mouth_state_for_actor,Y
set_mode_x2:
.C:27c2  4C CA 27    JMP set_mode_x
set_mode_00:
.C:27c5  20 34 28    JSR reset_talking
.C:27c8  A2 00       LDX #$00
set_mode_x:
.C:27ca  8E C1 28    STX append_message_mode
;-----------------------------------------
;Use .Y as source index, start at #FF (incremented to zero on first iteration)
.C:27cd  A0 FF       LDY #$FF
;Use .X as destination index, start at #FF (incremented to zero on first iteration)
.C:27cf  A2 FF       LDX #$FF
check_next_char:
.C:27d1  C8          INY
.C:27d2  E8          INX
.C:27d3  AD C1 28    LDA append_message_mode
.C:27d6  10 05       BPL check_for_space_append
;If mode is #FF, don't append characters, just read and skip them
.C:27d8  B1 15       LDA (message_ptr),Y
.C:27da  4C EC 27    JMP check_end_of_string
check_for_space_append:
;If bit 7 is set, a space must be added after the character
.C:27dd  B1 15       LDA (message_ptr),Y
.C:27df  10 08       BPL append_char
;Clear bit 7 to get the original character and append it
.C:27e1  29 7F       AND #$7F
.C:27e3  9D 00 02    STA source_msg_base,X
;Append a space after the character
.C:27e6  E8          INX
.C:27e7  A9 20       LDA #$20				;Space
append_char:
.C:27e9  9D 00 02    STA source_msg_base,X
check_end_of_string:
;Have we found a #00 character? If not, continue
.C:27ec  D0 E3       BNE check_next_char
;-----------------------------------------
;End of string found
;Add the copied string length to the message pointer
.C:27ee  C8          INY
.C:27ef  98          TYA
.C:27f0  18          CLC
.C:27f1  65 15       ADC <message_ptr
.C:27f3  85 15       STA <message_ptr
.C:27f5  90 02       BCC check_if_color_needed
.C:27f7  E6 16       INC >message_ptr
;If mode is #FF, don't set the text color
check_if_color_needed:
.C:27f9  AD C1 28    LDA append_message_mode
.C:27fc  30 35       BMI exit
;-----------------------------------------
; Set text color
;-----------------------------------------
;Determine the message text color to use
;Does the message have an owner?
.C:27fe  AE 9B FE    LDX message_owner
.C:2801  10 05       BPL use_actor_text_color
;It doesn't - use #0E color by default
.C:2803  A9 0E       LDA #$0E
.C:2805  4C 0B 28    JMP text_color_determined
use_actor_text_color:
.C:2808  BD 72 D6    LDA actor_text_color,X
text_color_determined:
;map_in_io
.C:280b  A0 25       LDY #$25
.C:280d  84 01       STY processor_port_register
;Use .X as the top bar index, start at the end (#27), move downwards
.C:280f  A2 27       LDX #$27
color_loop:
;Set text color
.C:2811  9D 00 D8    STA color_ram,X
.C:2814  CA          DEX
.C:2815  10 FA       BPL color_loop
;map_out_io
.C:2817  A0 24       LDY #$24
.C:2819  84 01       STY processor_port_register
;-----------------------------------------
.C:281b  A9 00       LDA #$00
.C:281d  85 CA       STA source_msg_offset
;A new message is ready to be printed - set top bar mode to #FF
.C:281f  A2 FF       LDX #$FF
.C:2821  86 C9       STX top_bar_msg_mode
;Set some debugging variables
.C:2823  8E 6A FF    STX var_msg_flag
.C:2826  A9 00       LDA #$00
.C:2828  8D 71 FF    STA var_message_length
;Set message delay to #0001
.C:282b  A9 01       LDA #$01
.C:282d  85 CB       STA <current_message_delay
.C:282f  A9 00       LDA #$00
.C:2831  85 CC       STA >current_message_delay
exit:
.C:2833  60          RTS
;===========================================
; Resets talking by shutting down any talking action in place
;
; If there's a message owner, it shuts its mouth.
; Message owner is then reset to #FF and the message bar is cleared.
;===========================================
reset_talking:
;Set top bar mode to #00
.C:2834  A9 00       LDA #$00
.C:2836  85 C9       STA top_bar_msg_mode
;Reset msg delay to zero
.C:2838  85 CB       STA <current_message_delay
.C:283a  85 CC       STA >current_message_delay
;Get the message owner
.C:283c  AE 9B FE    LDX message_owner
;If it's nobody (#FF), clear the message bar and exit
.C:283f  30 16       BMI clear_msg_bar_text
;If the owner actor is offscreen, then clear the owner and the message bar
.C:2841  BC 57 FE    LDY actor_for_costume,X
.C:2844  30 0C       BMI clear_msg_owner
;Does this character animate its mouth when speaking? If not, skip this part
.C:2846  BD D9 F0    LDA character_animation_settings,X
.C:2849  29 40       AND #$40
.C:284b  D0 05       BNE clear_msg_owner
;It does - set mouth state to #00 (closed)
.C:284d  A9 00       LDA #$00
.C:284f  99 9D FE    STA mouth_state_for_actor,Y
clear_msg_owner:
;Set message owner to #FF (nobody)
.C:2852  A9 FF       LDA #$FF
.C:2854  8D 9B FE    STA message_owner
;Fall through - clear message bar
;===========================================
; Clears the message bar's text
;
; Arguments: None
;===========================================
clear_msg_bar_text:
.C:2857  A0 27       LDY text_bar_length
.C:2859  A9 00       LDA #$00
clear_loop:
.C:285b  99 00 CC    STA msg_bar_text_base,Y
.C:285e  88          DEY
.C:285f  10 FA       BPL clear_loop
.C:2861  60          RTS
;===========================================
; Print message on message bar
;
; Arguments:	
;		source_msg_offset		Offset from which the message to print starts.
;								The base address is source_msg_base.
;		top_bar_msg_mode		
;		text_delay				Text speed factor - it will affect the message delay
;	Note: character #25 is the ellipsis (...) symbol
;===========================================
source_msg_offset = $CA
standard_message_delay = $Cd

print_message_on_top_bar:
;--------------------------------------
; Exit if no delay countdown is in progress
;--------------------------------------
;Check if the msg delay is already zero - if so, no countdown is ongoing, exit
.C:2862  A5 CB       LDA <current_message_delay
.C:2864  05 CC       ORA >current_message_delay
.C:2866  F0 58       BEQ exit	
;--------------------------------------
;Decrement delay countdown and exit if it's still ongoing
;--------------------------------------
;Decrement the text delay
.C:2868  A5 CB       LDA <current_message_delay
.C:286a  D0 02       BNE decrement_delay_lo
;If lo part is zero, decrement hi also
.C:286c  C6 CC       DEC >current_message_delay
decrement_delay_lo:
.C:286e  C6 CB       DEC <current_message_delay
;Check if delay has been exhausted - if not, exit
.C:2870  A5 CB       LDA <current_message_delay
.C:2872  05 CC       ORA >current_message_delay
.C:2874  D0 4A       BNE exit
;--------------------------------------
;Delay countdown has reached zero
.C:2876  A5 C9       LDA top_bar_msg_mode
;Is bit 7 of top_bar_msg_mode clear? 
;If so, skip to reset_talking
.C:2878  10 43       BPL reset_talking_2
;Bit 7 is set - clear the msg bar
.C:287a  20 57 28    JSR clear_msg_bar_text
;Copy standard delay into the current delay
.C:287d  A5 CD       LDA <standard_message_delay
.C:287f  85 CB       STA <current_message_delay
.C:2881  A5 CE       LDA >standard_message_delay
.C:2883  85 CC       STA >current_message_delay
;--------------------------------------
;Use .Y as source msg offset
;If a line break occurred before, the offset will continue at the next line
.C:2885  A4 CA       LDY source_msg_offset
.C:2887  A2 00       LDX #$00
next_character:
;Read the source character
.C:2889  B9 00 02    LDA source_msg_base,Y
.C:288c  C8          INY
;Check special cases (end of string or line break)
.C:288d  C9 00       CMP #$00	
.C:288f  D0 05       BNE check_for_line_break
;--------------------------------------
;Case #00 - normal end of string
;Set mode as #01 and exit
.C:2891  A9 01       LDA #$01
.C:2893  85 C9       STA top_bar_msg_mode
.C:2895  60          RTS
;Check if we have a line break character
check_for_line_break:
.C:2896  C9 2F       CMP #$2F		;Line break
.C:2898  D0 07       BNE regular_character
;--------------------------------------
;Case #2F - line break
handle_line_break:
;Set mode as #FF, save source offset and exit
.C:289a  A9 FF       LDA #$FF
.C:289c  85 C9       STA top_bar_msg_mode
.C:289e  84 CA       STY source_msg_offset
.C:28a0  60          RTS
;--------------------------------------
; Regular character processing - copy it and add per-character delay
;--------------------------------------
regular_character:
;Copy it to the msg bar text
.C:28a1  9D 00 CC    STA msg_bar_text_base,X
;Increase message length (for debugging purposes)
.C:28a4  EE 71 FF    INC var_message_length
;Add the text_delay factor to the delay
;This is done for each regular character processed, effectively becoming a multiplication factor of the standard delay
.C:28a7  A5 CB       LDA <current_message_delay
.C:28a9  18          CLC
.C:28aa  65 CF       ADC text_delay
.C:28ac  85 CB       STA <current_message_delay
.C:28ae  90 02       BCC end_of_bar_check
;If there was a carry, increase the hi part
.C:28b0  E6 CC       INC >current_message_delay
;--------------------------------------
end_of_bar_check:
;Have we reached the end of the msg bar? 
.C:28b2  E8          INX
.C:28b3  E0 28       CPX #$28
;If not, process next character
.C:28b5  D0 D2       BNE next_character	
;We reached the end of the msg bar. Treat it as a line break.
.C:28b7  4C 9A 28    JMP handle_line_break
;.C:28ba  4C C0 28    JMP exit	;Unreachable code
;--------------------------------------
reset_talking_2:
.C:28bd  20 34 28    JSR reset_talking
exit:
.C:28c0  60          RTS
;===========================================
; Handles any keys pressed
; 
; Arguments:	None
;===========================================
key_to_process = $29f7

handle_keys:
;Scan for keys pressed, return key in .A
.C:28c2  20 44 22    JSR kbd_key_read
;Save the key pressed
.C:28c5  8D F7 29    STA key_to_process
.C:28c8  C9 04       CMP #$04		;F7 key
.C:28ca  D0 2C       BNE check_space
;---------------------------------
;F7 - bypass cutscene
;---------------------------------
;Was there an interrupted script? If so, script offset is nonzero
.C:28cc  AD A4 FE    LDA interrupted_script_offset_lo
.C:28cf  0D A5 FE    ORA interrupted_script_offset_hi
;Otherwise, exit
.C:28d2  F0 23       BEQ exit_f7
;There was an interrupted script - load the interrupted script index
.C:28d4  AE A7 FE    LDX interrupted_script_index
;Restore the offsets
.C:28d7  AD A4 FE    LDA interrupted_script_offset_lo
.C:28da  9D C9 70    STA script_offsets_lo,X
.C:28dd  AD A5 FE    LDA interrupted_script_offset_hi
.C:28e0  9D B9 70    STA script_offsets_hi,X
;Set script state as running (#02)
.C:28e3  A9 02       LDA #$02
.C:28e5  9D D9 70    STA script_state_for_script_slot,X
;Set debugging variable to #01
.C:28e8  A9 01       LDA #$01
.C:28ea  8D 6D FF    STA var_destination_x
;Clear interrupted script offset
.C:28ed  A9 00       LDA #$00
.C:28ef  8D A4 FE    STA interrupted_script_offset_lo
.C:28f2  A9 00       LDA #$00
.C:28f4  8D A5 FE    STA interrupted_script_offset_hi
exit_f7:
.C:28f7  60          RTS
;---------------------------------
check_space:
.C:28f8  C9 20       CMP #$20		;Space key?
.C:28fa  D0 45       BNE check_f8_key
;---------------------------------
;Space key - pause game
;---------------------------------
;Pause game
.C:28fc  20 D1 18    JSR pause_game
;Print the paused game message on the command bar
.C:28ff  A0 27       LDY #$27	;Game pause message string length
copy_game_paused_msg:
.C:2901  B9 A6 3B    LDA game_paused_msg,Y
.C:2904  99 D0 CE    STA SENTENCE_BAR_BASE,Y
.C:2907  88          DEY
.C:2908  10 F7       BPL copy_game_paused_msg
;map_in_io
.C:290a  A0 25       LDY #$25
.C:290c  84 01       STY processor_port_register
;Set sound volume to #00
.C:290e  A9 00       LDA #$00
.C:2910  8D 18 D4    STA volume_control_register
;---------------------------------
;Wait indefinitely for the space key to be pressed
wait_for_space_key:
;Set keyboard polling delay to #00
.C:2913  A9 00       LDA #$00
.C:2915  8D 4D FE    STA kbd_delay_lo
.C:2918  A9 00       LDA #$00
.C:291a  8D 4E FE    STA kbd_delay_hi
;Check for keys
.C:291d  20 44 22    JSR kbd_key_read
;If the Space key was not pressed, loop back
.C:2920  C9 20       CMP #$20		;Space key
.C:2922  D0 EF       BNE wait_for_space_key
;---------------------------------
;Unpause game
;Restore volume settings
.C:2924  AD 6A 47    LDA volume_control_reg_copy
.C:2927  8D 18 D4    STA volume_control_register
;map_out_io
.C:292a  A0 24       LDY #$24
.C:292c  84 01       STY processor_port_register
;Unpause game
.C:292e  20 DF 18    JSR unpause_game
;Enable refreshing the sentence bar
.C:2931  A9 01       LDA #$01
.C:2933  8D 49 FE    STA refresh_sentence_bar_flag
;Clear out the paused game message from the command bar
.C:2936  A0 27       LDY #$27
clear_game_paused_msg:
.C:2938  A9 00       LDA #$00
.C:293a  99 D0 CE    STA SENTENCE_BAR_BASE,Y
.C:293d  88          DEY
.C:293e  10 F8       BPL clear_game_paused_msg
.C:2940  60          RTS
;---------------------------------
check_f8_key:
.C:2941  C9 08       CMP #$08		;F8 key?
.C:2943  D0 08       BNE check_plus_key
;---------------------------------
; F8 - restart game
;---------------------------------
.C:2945  A9 FF       LDA #$FF		
.C:2947  8D B8 70    STA current_script_slot
.C:294a  4C C3 6A    JMP restart_game
;---------------------------------
check_plus_key:
.C:294d  C9 2B       CMP #$2B		;"+" key?
.C:294f  D0 09       BNE check_minus_key
;---------------------------------
; Plus key - accelerate text speed
;---------------------------------
.C:2951  C6 CF       DEC text_delay		
.C:2953  10 04       BPL plus_key_exit
.C:2955  A9 00       LDA #$00
.C:2957  85 CF       STA text_delay
plus_key_exit:
.C:2959  60          RTS
;---------------------------------
check_minus_key:
.C:295a  C9 2D       CMP #$2D		;"-" key?
.C:295c  D0 0D       BNE check_function_keys
;---------------------------------
; Minus key - decelerate text speed
;---------------------------------
.C:295e  E6 CF       INC text_delay		
.C:2960  A5 CF       LDA text_delay
.C:2962  C9 0B       CMP #$0B
.C:2964  D0 04       BNE minus_key_exit
.C:2966  A9 0A       LDA #$0A
.C:2968  85 CF       STA text_delay
minus_key_exit:
.C:296a  60          RTS
;---------------------------------
check_function_keys:
;Check which control mode is current
.C:296b  AD A8 FE    LDA control_mode
;If control mode is #00 (cutscene), load/save is disabled
.C:296e  C9 00       CMP #$00
.C:2970  F0 16       BEQ check_new_kid_key
;Control mode is not #00, so check if F2 was pressed
.C:2972  AD F7 29    LDA key_to_process
.C:2975  C9 05       CMP #$05		;F2 key?
.C:2977  D0 0F       BNE check_new_kid_key
;---------------------------------
; F2 key - save/load game
;---------------------------------
;Are we already executing script 2? (Is it loaded in memory?)
.C:2979  AD D9 7A    LDA script_2_mem_attr		
;If so, continue
.C:297c  D0 0A       BNE check_new_kid_key
;Disable current script execution
.C:297e  A9 FF       LDA #$FF
.C:2980  8D B8 70    STA current_script_slot
;Execute script #2 (load-save game)
.C:2983  A9 02       LDA #$02
.C:2985  4C 8A 5E    JMP start_global_script		
;---------------------------------
check_new_kid_key:
;Check which control mode is current
.C:2988  AD A8 FE    LDA control_mode
;If control mode != #03, changing kid is disabled, at least via the Function keys. 
; You can still use the "New kid" verb, which is a bug.
.C:298b  C9 03       CMP #$03
.C:298d  D0 1E       BNE exit
;---------------------------------
;Change kid is enabled - check if any of the new kid keys have been pressed
;---------------------------------
.C:298f  AD F7 29    LDA key_to_process
.C:2992  C9 01       CMP #$01		;F1 key?
.C:2994  D0 05       BNE check_f3_key
;F1 pressed - set kid index to #00
.C:2996  A9 00       LDA #$00
.C:2998  4C AE 29    JMP validate_new_kid_change
check_f3_key:
.C:299b  C9 02       CMP #$02		;F3 key?
.C:299d  D0 05       BNE check_f5_key
;F3 pressed - set kid index to #01
.C:299f  A9 01       LDA #$01
.C:29a1  4C AE 29    JMP validate_new_kid_change
check_f5_key:
.C:29a4  C9 03       CMP #$03		;F5 key?
.C:29a6  D0 05       BNE exit
;F5 pressed - set kid index to #02
.C:29a8  A9 02       LDA #$02
.C:29aa  4C AE 29    JMP validate_new_kid_change
exit:
.C:29ad  60          RTS
;---------------------------------
validate_new_kid_change:
;.X = index of F key (0/1/2 for F1/F3/F5 respectively)
.C:29ae  AA          TAX			
;Fetch the kid ID for the index
.C:29af  BD C8 FF    LDA kid_ids,X	
;Is it already the current kid? If so, exit
.C:29b2  CD 67 FF    CMP current_kid		
.C:29b5  D0 01       BNE change_to_new_kid
.C:29b7  60          RTS
change_to_new_kid:
;Set the new kid
.C:29b8  8D 67 FF    STA current_kid
.C:29bb  8D 67 FF    STA current_kid
;Stop script execution
.C:29be  A9 FF       LDA #$FF
.C:29c0  8D B8 70    STA current_script_slot
;Fix camera on the new kid actor
.C:29c3  AD 67 FF    LDA current_kid
.C:29c6  20 23 68    JSR fix_camera_on_actor
;Refresh inventory displayed
.C:29c9  20 2B 5F    JSR refresh_items_displayed
;===========================================
; Resets all components of the sentence queue system
;===========================================
reset_sentence_queue_system:
;Clear the destination entity
.C:29cc  A9 00       LDA #$00
.C:29ce  8D 51 FE    STA destination_entity
.C:29d1  A9 01       LDA #$01
.C:29d3  8D 49 FE    STA refresh_sentence_bar_flag
;Reset the sentence queue capacity
.C:29d6  A9 06       LDA #$06
.C:29d8  8D 18 FE    STA sentence_queue_free_capacity
;Reset the sentence queue index
.C:29db  A9 FF       LDA #$FF
.C:29dd  8D 17 FE    STA sentence_queue_index
;Set current verb to "Walk to"
.C:29e0  A9 0D       LDA #$0D
.C:29e2  8D 1F FE    STA current_verb
;Clear direct object, indirect object and preposition
.C:29e5  A9 00       LDA #$00
.C:29e7  8D 20 FE    STA direct_object_idx_lo
.C:29ea  8D 21 FE    STA direct_object_idx_hi
.C:29ed  8D 22 FE    STA preposition
.C:29f0  8D 23 FE    STA indirect_object_idx_lo
.C:29f3  8D 24 FE    STA indirect_object_idx_hi
.C:29f6  60          RTS
;===========================================
motion_needed = $fc3b

move_actor_on_path:
;Is the active waypoint the desired waypoint?
;If not, process the new desired waypoint
.C:29f8  A6 D8       LDX actor
.C:29fa  BD 29 FD    LDA desired_waypoint_x_for_actor,X
.C:29fd  DD 25 FD    CMP active_waypoint_x_for_actor,X
.C:2a00  D0 25       BNE set_new_active_waypoint
.C:2a02  BD 31 FD    LDA desired_waypoint_y_for_actor,X
.C:2a05  DD 2D FD    CMP active_waypoint_y_for_actor,X
.C:2a08  D0 1D       BNE set_new_active_waypoint
;--------------------------------------------
;The desired waypoint is the currently active one
;Is the actor about to stop? (#01)
;If so, animate actor
.C:2a0a  BD 68 FD    LDA motion_state_for_actor,X
.C:2a0d  29 7F       AND #$7F
.C:2a0f  C9 01       CMP #$01
.C:2a11  F0 11       BEQ animate_actor
;--------------------------------------------
;Actor not about to stop yet
;Has it reached the final position for this waypoint?
;If not, continue animating the actor by walking
.C:2a13  BD 31 FD    LDA desired_waypoint_y_for_actor,X
.C:2a16  DD 3D FD    CMP position_y_for_actor,X
.C:2a19  D0 09       BNE animate_actor
.C:2a1b  BD 29 FD    LDA desired_waypoint_x_for_actor,X
.C:2a1e  DD 41 FD    CMP position_x_for_actor,X
.C:2a21  D0 01       BNE animate_actor
.C:2a23  60          RTS
;--------------------------------------------
animate_actor:
.C:2a24  4C 9A 2A    JMP animate_actor_when_walking
;--------------------------------------------
set_new_active_waypoint:
;Copy the new active path
.C:2a27  BD 29 FD    LDA desired_waypoint_x_for_actor,X
.C:2a2a  9D 25 FD    STA active_waypoint_x_for_actor,X
.C:2a2d  BD 31 FD    LDA desired_waypoint_y_for_actor,X
.C:2a30  9D 2D FD    STA active_waypoint_y_for_actor,X
;--------------------------------------------
set_state_to_moving:
;Set state to "moving" (#00)
.C:2a33  A6 D8       LDX actor
.C:2a35  BD 68 FD    LDA motion_state_for_actor,X
.C:2a38  29 F0       AND #$F0
.C:2a3a  9D 68 FD    STA motion_state_for_actor,X
;--------------------------------------------
;Copy the current position to the "position to waypoint"
.C:2a3d  BD 41 FD    LDA position_x_for_actor,X
.C:2a40  9D 45 FD    STA position_to_waypoint_x_for_actor,X
.C:2a43  BD 3D FD    LDA position_y_for_actor,X
.C:2a46  9D 49 FD    STA position_to_waypoint_y_for_actor,X
;--------------------------------------------
;Compute the path deltas
;Result = #00 if there's at least one real delta (motion needed)
;		  #01 if there are no deltas (no motion needed)
.C:2a49  20 6F 2F    JSR set_path_deltas
.C:2a4c  A6 D8       LDX actor
.C:2a4e  8D 3B FC    STA motion_needed
;--------------------------------------------
;If motion is needed, the state be set to #00 (moving)
;Otherwise, it will be set to #01 (about to stop)
.C:2a51  BD 68 FD    LDA motion_state_for_actor,X
.C:2a54  29 F0       AND #$F0
.C:2a56  0D 3B FC    ORA motion_needed
.C:2a59  9D 68 FD    STA motion_state_for_actor,X
;--------------------------------------------
;Map the dominant axis and direction to the appropriate "directions bitmask" value
.C:2a5c  AD 66 CB    LDA path_dominant_axis
.C:2a5f  D0 0F       BNE y_dominant_direction
x_dominant_direction:
.C:2a61  AD 58 CB    LDA path_delta_x_direction
.C:2a64  F0 05       BEQ x_direction_left
x_direction_right:
.C:2a66  A9 00       LDA #$00
.C:2a68  4C 7C 2A    JMP set_delta_directions_for_actor
x_direction_left:
.C:2a6b  A9 01       LDA #$01
.C:2a6d  4C 7C 2A    JMP set_delta_directions_for_actor
;--------------------------------------------
y_dominant_direction:
.C:2a70  AD 59 CB    LDA path_delta_y_direction
.C:2a73  F0 05       BEQ y_direction_up
y_direction_down:
.C:2a75  A9 80       LDA #$80
.C:2a77  4C 7C 2A    JMP set_delta_directions_for_actor
y_direction_up:
.C:2a7a  A9 81       LDA #$81
set_delta_directions_for_actor:
;Set the resulting bitmask
.C:2a7c  9D EF FD    STA path_delta_directions_for_actor,X
;--------------------------------------------
;.C:2a7f  BD A8 FD    LDA layer_3_for_actor,X	;Redundant code
;.C:2a82  C9 03       CMP #$03		;Redundant code
;.C:2a84  D0 00       BNE $2A86		;Redundant code
;.C:2a86  20 22 2C    JSR do_nothing
.C:2a89  20 70 2B    JSR update_motion_state
.C:2a8c  20 CA 2B    JSR set_actor_limbs_for_standing
;Is the actor walking or standing/turning? 
.C:2a8f  BD 68 FD    LDA motion_state_for_actor,X
;BEQ will be taken if Z is set
;Z will be set if the AND yields zero
;Which will happen if bit 7 is clear
;So bit 7 clear means walking, set means standing/turning
.C:2a92  29 80       AND #$80
.C:2a94  F0 01       BEQ setup_walking
;It's standing or turning, exit
.C:2a96  60          RTS
;--------------------------------------------
setup_walking:
.C:2a97  20 F6 2B    JSR set_actor_limbs_for_walking
;Fall through
;===========================================
; Animates an actor when it's walking
;
; Arguments: 	motion_state_for_actor
; 
; The logic is slightly convoluted and can be described as:
; -If the actor is stopped, it will exit
; -If the actor is about to stop, it will reset the animation state and exit
; -If the actor is standing/turning, it will update the motion state and set its standing limbs
; 	-If after that, its motion state hasn't changed, it will exit
;	-Otherwise, the motion state has changed to walking, so it will set its limbs for walking
;
; By this point, the actor is walking.
; -The low nibble of the motion state will be inspected to check if a traversal of an intermediate walkbox is ongoing
;	-If so, it will delegate traversal to the appropriate routine
;
; Otherwise, no ongoing walkbox traversal is occurring, so it's doing a "regular motion" (self-contained in a single walkbox).
; -It will finally perform an update of motion on the X and Y axis (to move towards the intended waypoint, regardless of it being intermediate or final)
; -If the waypoint position has been fully reached (on both axes), it will signal that the actor is about to stop
; -If it has been reached only on one axis and there are no walkbox traversals, it will return #00
; -If there's a walkbox traversal, it will set the delta directions bitmask based on the axis direction and then delegate to the traversal routine
;===========================================
position_reached = $fc3b

animate_actor_when_walking:
.C:2a9a  A6 D8       LDX actor
;Is the actor stopped? (#02) If so, exit
.C:2a9c  BD 68 FD    LDA motion_state_for_actor,X
.C:2a9f  C9 02       CMP #$02
.C:2aa1  D0 01       BNE check_if_about_to_stop
.C:2aa3  60          RTS
check_if_about_to_stop:
;Is it about to stop? (#01)
.C:2aa4  29 0F       AND #$0F
.C:2aa6  C9 01       CMP #$01
.C:2aa8  D0 03       BNE is_actor_walking
;It's about to stop, reset animation
.C:2aaa  4C 23 2C    JMP reset_actor_animation_state
;--------------------------------------------
is_actor_walking:
;Is actor not turning? 
.C:2aad  BD 68 FD    LDA motion_state_for_actor,X
.C:2ab0  29 80       AND #$80
.C:2ab2  F0 11       BEQ actor_is_walking
;--------------------------------------------
;Actor is standing or turning
;Update the motion state again
.C:2ab4  20 70 2B    JSR update_motion_state
;Set limbs for standing
.C:2ab7  20 CA 2B    JSR set_actor_limbs_for_standing
;Is actor still not turning? If so, handle walking
.C:2aba  BD 68 FD    LDA motion_state_for_actor,X
.C:2abd  29 80       AND #$80
.C:2abf  F0 01       BEQ set_walking_limbs
;We're still standing or turning, exit
.C:2ac1  60          RTS
;--------------------------------------------
;Actor walking
set_walking_limbs:
.C:2ac2  20 F6 2B    JSR set_actor_limbs_for_walking
actor_is_walking:
.C:2ac5  A6 D8       LDX actor
;.C:2ac7  BD A8 FD    LDA layer_3_for_actor,X	;Redundant code
;.C:2aca  C9 03       CMP #$03
;.C:2acc  D0 00       BNE $2ACE
;
;Get the low nibble of the motion state
.C:2ace  BD 68 FD    LDA motion_state_for_actor,X
.C:2ad1  29 0F       AND #$0F
;--------------------------------------------
check_vertical_traversal:
;Is the actor traversing an intermediate box vertically?
.C:2ad3  C9 03       CMP #$03
.C:2ad5  D0 03       BNE check_horizontal_traversal
.C:2ad7  4C 36 2C    JMP traverse_box_horizontally
;--------------------------------------------
check_horizontal_traversal:
;Is the actor traversing an intermediate box horizontally?
.C:2ada  C9 04       CMP #$04
.C:2adc  D0 03       BNE check_regular_motion
.C:2ade  4C A3 2C    JMP traverse_box_vertically
check_regular_motion:
;Is the actor just moving "normally"?
.C:2ae1  C9 00       CMP #$00
.C:2ae3  F0 03       BEQ regular_motion
;For any other state, exit (we shouldn't reach this point ever)
.C:2ae5  4C 6F 2B    JMP exit
;--------------------------------------------
regular_motion:
.C:2ae8  20 8C 2E    JSR update_actor_x_axis
; Returns:	.A	#00		Waypoint X position not reached yet and no change of walkbox
;				#01		Waypoint X position has been reached
;				#03		Walkbox changed on X axis
;Has the waypoint X position been reached?
.C:2aeb  C9 01       CMP #$01
.C:2aed  D0 1D       BNE x_position_not_reached
x_position_reached:
.C:2aef  20 CD 2E    JSR update_actor_y_axis
; Returns:	.A	#00		Waypoint Y position not reached yet and no change of walkbox
;				#01		Waypoint Y position has been reached
;				#04		Walkbox changed on Y axis
;Has the waypoint Y position been reached?
.C:2af2  C9 01       CMP #$01
.C:2af4  D0 0E       BNE y_position_not_reached
;--------------------------------------------
waypoint_reached:
;We reached the final position in both axes, signal we're about to stop in the motion state (set bit 0)
.C:2af6  A6 D8       LDX actor
.C:2af8  8D 3B FC    STA position_reached
.C:2afb  29 F0       AND #$F0
.C:2afd  0D 3B FC    ORA position_reached
.C:2b00  9D 68 FD    STA motion_state_for_actor,X
.C:2b03  60          RTS
;--------------------------------------------
y_position_not_reached:
;We reached the waypoint's X position but not the Y one
;Are we traversing vertically into a new walkbox?
.C:2b04  C9 04       CMP #$04
.C:2b06  D0 03       BNE exit_2
;If so, reset the animation state
.C:2b08  4C 23 2C    JMP reset_actor_animation_state
exit_2:
;We're not traversing into a new walkbox, we're simply moving vertically, exit
.C:2b0b  60          RTS
;--------------------------------------------
x_position_not_reached:
;We have not reached the waypoint's X position yet
;Are we traversing horizontally into a new walkbox?
.C:2b0c  C9 03       CMP #$03
.C:2b0e  D0 29       BNE x_walkbox_not_changed
;We're traversing into a new walkbox, reflect that in the motion state (#03)
.C:2b10  8D 3B FC    STA position_reached
.C:2b13  BD 68 FD    LDA motion_state_for_actor,X
.C:2b16  29 F0       AND #$F0
.C:2b18  0D 3B FC    ORA position_reached
.C:2b1b  9D 68 FD    STA motion_state_for_actor,X
;--------------------------------------------
;Set the "delta directions" based on the vertical direction
.C:2b1e  BD 0B FE    LDA path_delta_y_direction_for_actor,X
.C:2b21  F0 08       BEQ direction_up
direction_down:
;Set direction to #80 (down)
.C:2b23  A9 80       LDA #$80
.C:2b25  9D EF FD    STA path_delta_directions_for_actor,X
.C:2b28  4C 30 2B    JMP path_direction_y_set
direction_up:
;Set direction to #81 (up)
.C:2b2b  A9 81       LDA #$81
.C:2b2d  9D EF FD    STA path_delta_directions_for_actor,X
path_direction_y_set:
;Update motion state and update limbs for walking
.C:2b30  20 70 2B    JSR update_motion_state
.C:2b33  20 F6 2B    JSR set_actor_limbs_for_walking
;We're traversing into a new walkbox horizontally, so continue at that routine
.C:2b36  4C 36 2C    JMP traverse_box_horizontally
;--------------------------------------------
x_walkbox_not_changed:
;We have not reached the waypoint's X position yet
;but we're not traversing horizontally into a new walkbox
;Update motion on the Y axis
.C:2b39  20 CD 2E    JSR update_actor_y_axis
;Are we traversing vertically into a new walkbox?
.C:2b3c  C9 04       CMP #$04
.C:2b3e  F0 06       BEQ y_walkbox_changed
;No change in walkboxes and waypoint position not reached yet - return #00
.C:2b40  A9 00       LDA #$00
.C:2b42  60          RTS
;.C:2b43  4C 66 2B    JMP path_direction_x_set
y_walkbox_changed:
;We're traversing into a new walkbox, reflect that in the motion state (#04)
.C:2b46  8D 3B FC    STA position_reached
.C:2b49  BD 68 FD    LDA motion_state_for_actor,X
.C:2b4c  29 F0       AND #$F0
.C:2b4e  0D 3B FC    ORA position_reached
.C:2b51  9D 68 FD    STA motion_state_for_actor,X
;--------------------------------------------
;Set the "delta directions" based on the horizontal direction
.C:2b54  BD 07 FE    LDA path_delta_x_direction_for_actor,X
.C:2b57  F0 08       BEQ direction_left
direction_right:
;Set direction to #00 (right)
.C:2b59  A9 00       LDA #$00
.C:2b5b  9D EF FD    STA path_delta_directions_for_actor,X
.C:2b5e  4C 66 2B    JMP path_direction_x_set
direction_left:
;Set direction to #01 (left)
.C:2b61  A9 01       LDA #$01
.C:2b63  9D EF FD    STA path_delta_directions_for_actor,X
path_direction_x_set:
;Update motion state and update limbs for walking
.C:2b66  20 70 2B    JSR update_motion_state
.C:2b69  20 F6 2B    JSR set_actor_limbs_for_walking
;We're traversing into a new walkbox vertically, so continue at that routine
.C:2b6c  4C A3 2C    JMP traverse_box_vertically
exit:
.C:2b6f  60          RTS
;===========================================
attribute_bit7 = $fc3b

update_motion_state:
.C:2b70  A6 D8       LDX actor
;--------------------------------------------
test_bit6_layer2:
.C:2b72  BD A4 FD    LDA layer_2_for_actor,X
.C:2b75  29 40       AND #$40
.C:2b77  F0 08       BEQ compare_directions_with_attribute
;--------------------------------------------
clear_bit6_layer2:
;Clear bit 6 and set as path delta directions
.C:2b79  BD A4 FD    LDA layer_2_for_actor,X
.C:2b7c  29 BF       AND #$BF
.C:2b7e  9D EF FD    STA path_delta_directions_for_actor,X
;--------------------------------------------
compare_directions_with_attribute:
.C:2b81  BD EF FD    LDA path_delta_directions_for_actor,X
.C:2b84  DD EB FD    CMP path_direction_for_actor,X
;If directions and attributes are equal, clear the "turning" state bit
.C:2b87  F0 38       BEQ clear_turning_state_bit
;--------------------------------------------
;Is actor turning?
.C:2b89  BD 68 FD    LDA motion_state_for_actor,X
.C:2b8c  30 22       BMI set_directions_as_attribute
;--------------------------------------------
;Actor not turning
.C:2b8e  BD EB FD    LDA path_direction_for_actor,X
.C:2b91  29 80       AND #$80
.C:2b93  8D 3B FC    STA attribute_bit7
.C:2b96  BD EF FD    LDA path_delta_directions_for_actor,X
.C:2b99  29 80       AND #$80
.C:2b9b  CD 3B FC    CMP attribute_bit7
.C:2b9e  F0 06       BEQ flip_bit7_clear_bit0
.C:2ba0  BD EF FD    LDA path_delta_directions_for_actor,X
.C:2ba3  4C B3 2B    JMP set_attribute
;--------------------------------------------
flip_bit7_clear_bit0:
.C:2ba6  BD EB FD    LDA path_direction_for_actor,X
.C:2ba9  49 80       EOR #$80
.C:2bab  29 FE       AND #$FE
.C:2bad  4C B3 2B    JMP set_attribute
;--------------------------------------------
set_directions_as_attribute:
.C:2bb0  BD EF FD    LDA path_delta_directions_for_actor,X
;--------------------------------------------
set_attribute:
.C:2bb3  9D EB FD    STA path_direction_for_actor,X
;--------------------------------------------
set_turning_state_bit:
;Set bit 7, which represents if an actor is turning
.C:2bb6  BD 68 FD    LDA motion_state_for_actor,X
.C:2bb9  09 80       ORA #$80
.C:2bbb  9D 68 FD    STA motion_state_for_actor,X
.C:2bbe  4C C9 2B    JMP exit
;--------------------------------------------
clear_turning_state_bit:
;Clear bit 7, which represents if an actor is turning
.C:2bc1  BD 68 FD    LDA motion_state_for_actor,X
.C:2bc4  29 7F       AND #$7F
.C:2bc6  9D 68 FD    STA motion_state_for_actor,X
;--------------------------------------------
exit:
.C:2bc9  60          RTS
;===========================================
; Sets an actor's limbs for standing based on the path direction bitmask
;===========================================
desired_animation_set = $fde9

set_actor_limbs_for_standing:
;Map the path direction bitmask to an animation set for the walking direction 
;(00,01,80,81 -> 05,04,06,07)
.C:2bca  BD EB FD    LDA path_direction_for_actor,X
check_00:
.C:2bcd  D0 05       BNE check_01
;------------------------------------------
map_00:
.C:2bcf  A9 05       LDA #$05
.C:2bd1  4C E8 2B    JMP set_animation_mode
;------------------------------------------
check_01:
.C:2bd4  C9 01       CMP #$01
.C:2bd6  D0 05       BNE check_81
;------------------------------------------
map_01:
.C:2bd8  A9 04       LDA #$04
.C:2bda  4C E8 2B    JMP set_animation_mode
;------------------------------------------
check_81:
.C:2bdd  C9 81       CMP #$81
.C:2bdf  D0 05       BNE map_80
;------------------------------------------
map_81:
.C:2be1  A9 07       LDA #$07
.C:2be3  4C E8 2B    JMP set_animation_mode
;------------------------------------------
map_80:
.C:2be6  A9 06       LDA #$06
;------------------------------------------
set_animation_mode:
;Save the animation set
.C:2be8  8D E9 FD    STA desired_animation_set
;Set default animation argument
.C:2beb  A9 FF       LDA #$FF
.C:2bed  8D E8 FD    STA animation_argument
;Update actor's limbs
.C:2bf0  20 20 27    JSR apply_animation_set
.C:2bf3  A6 D8       LDX actor
.C:2bf5  60          RTS
;===========================================
; Sets an actor's limbs for walking based on the path direction bitmask
;===========================================
set_actor_limbs_for_walking:
;Map the path direction bitmask to an animation set for the walking direction 
;(00,01,80,81 -> 01,00,02,03)
.C:2bf6  BD EB FD    LDA path_direction_for_actor,X
.C:2bf9  D0 05       BNE check_01
;--------------------------------------------
map_00:
.C:2bfb  A9 01       LDA #$01
.C:2bfd  4C 14 2C    JMP set_animation_mode
;--------------------------------------------
check_01:
.C:2c00  C9 01       CMP #$01
.C:2c02  D0 05       BNE check_81
;--------------------------------------------
map_01:
.C:2c04  A9 00       LDA #$00
.C:2c06  4C 14 2C    JMP set_animation_mode
;--------------------------------------------
check_81:
.C:2c09  C9 81       CMP #$81
.C:2c0b  D0 05       BNE convert_80
;--------------------------------------------
map_81:
.C:2c0d  A9 03       LDA #$03
.C:2c0f  4C 14 2C    JMP set_animation_mode
;--------------------------------------------
map_80:
.C:2c12  A9 02       LDA #$02
;--------------------------------------------
set_animation_mode:
;Save the desired animation set
.C:2c14  9D 06 FD    STA desired_animation_set_for_actor,X
;Set default animation argument
.C:2c17  A9 FF       LDA #$FF
.C:2c19  9D 0A FD    STA animation_argument_for_actor,X
;Update limbs' base cells
.C:2c1c  20 FF 25    JSR apply_base_cells_for_limbs
.C:2c1f  A6 D8       LDX actor
.C:2c21  60          RTS
;===========================================
do_nothing:
.C:2c22  60          RTS
;===========================================
; Resets an actor's motion and animation states
;
; The motion state gets reset to stopped.
; The animation state gets set to "refresh needed" and "actor needs to be drawn".
;===========================================
reset_actor_animation_state:
.C:2c23  A6 D8       LDX actor
.C:2c25  20 CA 2B    JSR set_actor_limbs_for_standing
;Set motion state to stopped (#02)
.C:2c28  A9 02       LDA #$02
.C:2c2a  9D 68 FD    STA motion_state_for_actor,X
;Refresh animation and set the "actor needs to be drawn" state
.C:2c2d  BD 97 FD    LDA animation_state_for_actor,X
.C:2c30  09 21       ORA #$21
.C:2c32  9D 97 FD    STA animation_state_for_actor,X
.C:2c35  60          RTS
;===========================================
; Traverse an intermediate walkbox horizontally
;===========================================
traverse_box_horizontally:
.C:2c36  A6 D8       LDX actor
.C:2c38  20 1B 2F    JSR save_actor_path_data
;Check the X direction
.C:2c3b  BD 07 FE    LDA path_delta_x_direction_for_actor,X
.C:2c3e  D0 06       BNE move_right
;----------------------------------------------------
move_left:
.C:2c40  DE 41 FD    DEC position_x_for_actor,X
.C:2c43  4C 49 2C    JMP update_depth
;----------------------------------------------------
move_right:
.C:2c46  FE 41 FD    INC position_x_for_actor,X
;----------------------------------------------------
update_depth:
;Returns #FF if the current box could not be determined
.C:2c49  20 F4 2C    JSR update_current_box_for_actor
;Is layer_3 #03?
.C:2c4c  BC A8 FD    LDY layer_3_for_actor,X
.C:2c4f  C0 03       CPY #$03
.C:2c51  D0 0F       BNE check_layer3_ff
;layer_3 == #03
.C:2c53  BD E1 FD    LDA path_update_needed_for_actor,X
.C:2c56  F0 08       BEQ $2C60
;Clear layer_3
.C:2c58  A9 00       LDA #$00
.C:2c5a  9D A8 FD    STA layer_3_for_actor,X
.C:2c5d  4C 62 2C    JMP check_layer3_ff
:
.C:2c60  A9 FF       LDA #$FF
check_layer3_ff:
.C:2c62  C9 FF       CMP #$FF
.C:2c64  F0 06       BEQ current_box_not_determined
.C:2c66  20 48 2F    JSR restore_actor_path_data
.C:2c69  4C 33 2A    JMP set_state_to_moving
;----------------------------------------------------
current_box_not_determined:
.C:2c6c  20 48 2F    JSR restore_actor_path_data
;Have we reached the waypoint's Y coordinate?
.C:2c6f  BD 2D FD    LDA active_waypoint_y_for_actor,X
.C:2c72  DD 49 FD    CMP position_to_waypoint_y_for_actor,X
.C:2c75  D0 03       BNE check_y_direction
;Y coordinate of waypoint reached - reset animation
.C:2c77  4C 23 2C    JMP reset_actor_animation_state
check_y_direction:
.C:2c7a  BD 0B FE    LDA path_delta_y_direction_for_actor,X
.C:2c7d  D0 06       BNE move_down
;----------------------------------------------------
;Waypoint Y coordinate not reached yet - move position
move_up:
.C:2c7f  DE 49 FD    DEC position_to_waypoint_y_for_actor,X
.C:2c82  4C 88 2C    JMP update_current_box_2
;----------------------------------------------------
move_down:
.C:2c85  FE 49 FD    INC position_to_waypoint_y_for_actor,X
;----------------------------------------------------
update_current_box_2:
.C:2c88  20 1B 2F    JSR save_actor_path_data
.C:2c8b  20 F4 2C    JSR update_current_box_for_actor
;Has a box been determined? If so, exit
.C:2c8e  C9 FF       CMP #$FF
.C:2c90  D0 06       BNE exit
;Box not determined - reset animation
.C:2c92  20 48 2F    JSR restore_actor_path_data
.C:2c95  4C 23 2C    JMP reset_actor_animation_state
;Completely redundant section of code
;.C:2c98  C9 FF       CMP #$FF
;.C:2c9a  D0 06       BNE $2CA2
;.C:2c9c  20 48 2F    JSR restore_actor_path_data
;.C:2c9f  4C 23 2C    JMP reset_actor_animation_state
exit:
.C:2ca2  60          RTS
;===========================================
; Traverse an intermediate walkbox vertically
;===========================================
traverse_box_vertically:
.C:2ca3  A6 D8       LDX actor
.C:2ca5  20 1B 2F    JSR save_actor_path_data
;Check the Y direction
check_y_direction:
.C:2ca8  BD 0B FE    LDA path_delta_y_direction_for_actor,X
.C:2cab  D0 06       BNE move_down
;----------------------------------------------------
move_up:
.C:2cad  DE 3D FD    DEC position_y_for_actor,X
.C:2cb0  4C B6 2C    JMP update_depth
;----------------------------------------------------
move_down:
.C:2cb3  FE 3D FD    INC position_y_for_actor,X
;----------------------------------------------------
update_depth:
;Returns #FF if the current box could not be determined
.C:2cb6  20 F4 2C    JSR update_current_box_for_actor
;Has the current box been determined?
.C:2cb9  C9 FF       CMP #$FF
.C:2cbb  F0 0A       BEQ current_box_not_determined
;.C:2cbd  C9 FF       CMP #$FF		;Redundant code
;.C:2cbf  F0 06       BEQ $2CC7
.C:2cc1  20 48 2F    JSR restore_actor_path_data
.C:2cc4  4C 33 2A    JMP set_state_to_moving
;----------------------------------------------------
current_box_not_determined:
.C:2cc7  20 48 2F    JSR restore_actor_path_data
;Have we reached the waypoint's X coordinate?
.C:2cca  BD 25 FD    LDA active_waypoint_x_for_actor,X
.C:2ccd  DD 45 FD    CMP position_to_waypoint_x_for_actor,X
.C:2cd0  D0 03       BNE check_x_direction
;X coordinate of waypoint reached - reset animation
.C:2cd2  4C 23 2C    JMP reset_actor_animation_state
;----------------------------------------------------
;Waypoint X coordinate not reached yet - move position
check_x_direction:
.C:2cd5  BD 07 FE    LDA path_delta_x_direction_for_actor,X
.C:2cd8  D0 06       BNE move_right
;----------------------------------------------------
move_left:
.C:2cda  DE 45 FD    DEC position_to_waypoint_x_for_actor,X
.C:2cdd  4C E3 2C    JMP update_current_box_2
;----------------------------------------------------
move_right:
.C:2ce0  FE 45 FD    INC position_to_waypoint_x_for_actor,X
;----------------------------------------------------
update_current_box_2:
.C:2ce3  20 1B 2F    JSR save_actor_path_data
.C:2ce6  20 F4 2C    JSR update_current_box_for_actor
;Has a box been determined? If so, exit
.C:2ce9  C9 FF       CMP #$FF
.C:2ceb  D0 06       BNE exit
;Box not determined - reset animation
.C:2ced  20 48 2F    JSR restore_actor_path_data
.C:2cf0  4C 23 2C    JMP reset_actor_animation_state
exit:
.C:2cf3  60          RTS
;===========================================
; Updates the current box for an actor
;
;	Returns:		.X	actor
;					.A	#00		if the current box has not changed
;						#01		if the current box has changed
;						#FF		if the current box could not be determined
;===========================================
box_data_ptr = $17
active_layer_depth = $fc3b
active_layer_1 = $fc3d
box_vertical_edge = $fc3f
current_box_index = $fdac

update_current_box_for_actor:
.C:2cf4  A6 D8       LDX actor
;Load the walkboxes for the active costume
.C:2cf6  20 B1 2D    JSR get_walkboxes_for_costume
;If room resource not in memory, exit
.C:2cf9  C9 FF       CMP #$FF
.C:2cfb  D0 01       BNE entry
.C:2cfd  60          RTS
;--------------------------------------------------------
entry:
;Get the current box for the actor
.C:2cfe  BD CD FD    LDA current_box_for_actor,X
;Get the current box offset in .Y
.C:2d01  20 D0 30    JSR get_walkbox_offset
;Is the actor inside the current box? #00 if inside, #FF if outside
.C:2d04  20 AD 30    JSR is_actor_pos_inside_box
.C:2d07  D0 01       BNE actor_not_inside_current_box
;If it is, exit, return #00 (current box not changed)
.C:2d09  60          RTS
;--------------------------------------------------------
actor_not_inside_current_box:
;Initialize current box index - in the first iteration #FF will be increased to #00
.C:2d0a  A9 FF       LDA #$FF
.C:2d0c  8D AC FD    STA current_box_index
;Fetch active layer depth and layer 1 for this actor
.C:2d0f  BD 18 FD    LDA layer_depth_for_actor,X
.C:2d12  8D 3B FC    STA active_layer_depth
.C:2d15  BD A0 FD    LDA layer_1_for_actor,X
.C:2d18  8D 3D FC    STA active_layer_1
;Use .Y as walkbox data offset
.C:2d1b  A0 00       LDY #$00
.C:2d1d  A9 00       LDA #$00
.C:2d1f  9D 18 FD    STA layer_depth_for_actor,X
.C:2d22  8D 3F FC    STA box_vertical_edge
;--------------------------------------------------------
next_box:
.C:2d25  EE AC FD    INC current_box_index
;Do we have a valid vertical edge of the previous box? 
.C:2d28  AD 3F FC    LDA box_vertical_edge
.C:2d2b  C9 FF       CMP #$FF
.C:2d2d  D0 06       BNE check_current_box
;Invalid box edge - return #FF as we couldn't determine the current box
.C:2d2f  A9 FF       LDA #$FF
.C:2d31  60          RTS
;--------------------------------------------------------
;.C:2d32  4C 3E 2D    JMP $2D3E	;Unreachable code
check_current_box:
;Get the current current box index
.C:2d35  AD AC FD    LDA current_box_index
;Get the current box offset in .Y
.C:2d38  20 D0 30    JSR get_walkbox_offset
;Is the actor inside the current box? #00 if inside, #FF if outside
;This call updates .Y
.C:2d3b  20 AD 30    JSR is_actor_pos_inside_box
.C:2d3e  D0 29       BNE actor_not_inside_current_box_2
;Actor is inside the current box
;As the actor is inside the box, .Y has been advanced by 3 in is_actor_pos_inside_box
;Point to the attribute value (offset 4 of the box data)
.C:2d40  C8          INY
;Load the box attribute value
.C:2d41  B1 17       LDA (box_data_ptr),Y
;Is it a valid value?
.C:2d43  C9 FF       CMP #$FF
;If not, continue
.C:2d45  D0 05       BNE valid_attribute
;It's invalid (we exhausted the list?)
;Break
;Load #00 into .A to avoid taking the branch of BNE and thus breaking the loop
.C:2d47  A9 00       LDA #$00
.C:2d49  4C 72 2D    JMP break_or_continue
;--------------------------------------------------------
valid_attribute:
.C:2d4c  AD AC FD    LDA current_box_index
;Is this the same as the last box for the actor?
.C:2d4f  DD D1 FD    CMP last_box_for_actor,X
.C:2d52  F0 05       BEQ set_current_box
;Continue with the next box
;Load #FF into .A to take the branch of BNE and continue with the next box
.C:2d54  A9 FF       LDA #$FF
.C:2d56  4C 72 2D    JMP break_or_continue
;--------------------------------------------------------
set_current_box:
.C:2d59  A9 01       LDA #$01
.C:2d5b  9D E1 FD    STA path_update_needed_for_actor,X
.C:2d5e  AD AC FD    LDA current_box_index
.C:2d61  9D CD FD    STA current_box_for_actor,X
;Break
;Load #00 into .A to avoid taking the branch of BNE and thus breaking the loop
.C:2d64  A9 00       LDA #$00
.C:2d66  4C 72 2D    JMP break_or_continue
;--------------------------------------------------------
actor_not_inside_current_box_2:
;Point to vertical edge of box
.C:2d69  C8          INY
.C:2d6a  C8          INY
;Copy it into box_vertical_edge
.C:2d6b  B1 17       LDA (box_data_ptr),Y
.C:2d6d  8D 3F FC    STA box_vertical_edge
;Continue with the next box
;Load #FF into .A to take the branch of BNE and continue with the next box
.C:2d70  A9 FF       LDA #$FF
;--------------------------------------------------------
break_or_continue:
;Continue (loop) if .A != #00, break otherwise
.C:2d72  D0 B1       BNE next_box
;--------------------------------------------------------
;Copy the layer depth from the attribute
.C:2d74  B1 17       LDA (box_data_ptr),Y
.C:2d76  9D 18 FD    STA layer_depth_for_actor,X
;If it's #FF, don't set this box as the current one
.C:2d79  C9 FF       CMP #$FF
.C:2d7b  F0 06       BEQ check_layer_depth
;It's not #FF, so set this box as the current box
.C:2d7d  AD AC FD    LDA current_box_index
.C:2d80  9D CD FD    STA current_box_for_actor,X
;--------------------------------------------------------
check_layer_depth:
;Is the depth bit 7 set?
.C:2d83  BD 18 FD    LDA layer_depth_for_actor,X
.C:2d86  10 0E       BPL check_layer_1
;It's set, check if the depth is #FF, if so, exit
.C:2d88  C9 FF       CMP #$FF
.C:2d8a  F0 07       BEQ exit_2
;--------------------------------------------------------
;It's not #FF but has bit 7 set
;Update the actor layer
.C:2d8c  20 D7 2D    JSR update_actor_layer
.C:2d8f  A6 D8       LDX actor
;Return #01 as the current box has changed
.C:2d91  A9 01       LDA #$01
exit_2:
.C:2d93  4C A2 2D    JMP exit
;--------------------------------------------------------
check_layer_1:
;If layer_1 is not zero, clear the layer values
.C:2d96  AD 3D FC    LDA active_layer_1
;If it's zero, return #00
.C:2d99  F0 07       BEQ exit
.C:2d9b  20 10 2E    JSR clear_layer_values_for_actor
.C:2d9e  A6 D8       LDX actor
;Return #01 as the current box has changed
.C:2da0  A9 01       LDA #$01
exit:
.C:2da2  60          RTS
;===========================================
; Get a boundary boxes pointer for the target room
;
; Arguments:	walkbox_room	target room index
; Returns:		#FF		if room resource not in memory
;				Otherwise, returns what get_walkboxes_ptr yields.
;===========================================
get_walkboxes_for_room:
;Get target room
.C:2da3  AC 74 FE    LDY walkbox_room
;Get room resource pointer
.C:2da6  B9 F3 77    LDA room_rsrc_ptrs_hi,Y
.C:2da9  D0 03       BNE ptr_present
;Room resource not in memory, return #FF
.C:2dab  A9 FF       LDA #$FF
.C:2dad  60          RTS
ptr_present:
.C:2dae  4C C0 2D    JMP get_walkboxes_ptr
;===========================================
; Get a boundary boxes pointer for the active character's room
;
; Arguments:	active_costume	
; Returns:		#FF		if room resource not in memory
;				Otherwise, returns what get_walkboxes_ptr yields.
;===========================================
get_walkboxes_for_costume:
;Get character in action
.C:2db1  AC 30 FC    LDY active_costume
;Get room for character
.C:2db4  B9 FC FE    LDA room_for_character,Y
;Get room resource pointer
.C:2db7  A8          TAY
.C:2db8  B9 F3 77    LDA room_rsrc_ptrs_hi,Y
.C:2dbb  D0 03       BNE get_walkboxes_ptr
;Room resource not in memory, return #FF
.C:2dbd  A9 FF       LDA #$FF
.C:2dbf  60          RTS
;===========================================
; Get a pointer to the room's boundary boxes data
;
; Arguments:	.Y	room index
;				.A	room resource pointer hi
;
; Returns:		box_data_ptr	pointer
;				.A	#00
;===========================================
box_data_ptr = $17

get_walkboxes_ptr:
;Copy low and hi bytes of the room resource to the read pointer
.C:2dc0  85 18       STA >box_data_ptr
.C:2dc2  B9 2A 78    LDA room_rsrc_ptrs_lo,Y
.C:2dc5  85 17       STA <box_data_ptr
;Set read offset to #15
;IMPORTANT - this is an offset from the block's start, not the room data
;So the offset from the room's data would be: #15 - block_header_size = #11
.C:2dc7  A0 15       LDY #$15
;Read the offset from the read pointer
.C:2dc9  B1 17       LDA (box_data_ptr),Y
;Add it to the read pointer
.C:2dcb  18          CLC
.C:2dcc  65 17       ADC <box_data_ptr
.C:2dce  85 17       STA <box_data_ptr
.C:2dd0  90 02       BCC exit
.C:2dd2  E6 18       INC >box_data_ptr
exit:
;Return #00
.C:2dd4  A9 00       LDA #$00
.C:2dd6  60          RTS
;===========================================
; Arguments:	.A	layer_depth 
;===========================================
update_actor_layer:
;Clear bits 7, 1 and 0
.C:2dd7  29 7C       AND #$7C
;Shift right twice
.C:2dd9  4A          LSR A
.C:2dda  4A          LSR A
;Does it match layer_1?
.C:2ddb  DD A0 FD    CMP layer_1_for_actor,X
.C:2dde  D0 07       BNE layer_1_mismatch
;It matches - set the active layer depth as the layer depth for the actor and exit
.C:2de0  AD 3B FC    LDA active_layer_depth
.C:2de3  9D 18 FD    STA layer_depth_for_actor,X
.C:2de6  60          RTS
layer_1_mismatch:
;It doesn't match, save the value as the active depth
.C:2de7  8D 3B FC    STA active_layer_depth
;Clear the 3 layer values for the actor
.C:2dea  20 10 2E    JSR clear_layer_values_for_actor
;Set the current depth as the layer 1 value
.C:2ded  AD 3B FC    LDA active_layer_depth
.C:2df0  9D A0 FD    STA layer_1_for_actor,X
.C:2df3  BD 18 FD    LDA layer_depth_for_actor,X
.C:2df6  29 03       AND #$03
.C:2df8  9D 18 FD    STA layer_depth_for_actor,X
;Load the layer subroutine index into .Y
.C:2dfb  BC A0 FD    LDY layer_1_for_actor,X
;Copy the subroutine index into .X
.C:2dfe  98          TYA
.C:2dff  AA          TAX
;Inline the subroutine pointer
.C:2e00  BD 6E 2E    LDA layer_ptrs_lo,X
.C:2e03  8D 0D 2E    STA <inlined_layer_subroutine
.C:2e06  BD 73 2E    LDA layer_ptrs_hi,X
.C:2e09  8D 0E 2E    STA >inlined_layer_subroutine
;Invoke the subroutine
inlined_layer_subroutine = $2e0d
.C:2e0c  20 00 00    JSR $0000
.C:2e0f  60          RTS
;===========================================
; Clears layer_1_for_actor, layer_2_for_actor and layer_3_for_actor by
; writing a #00 value to each of them.
;
; Arguments:	.X	actor index
;===========================================
layer_value_ptr = $17

clear_layer_values_for_actor:
;Point to layer_1_for_actor
.C:2e10  A9 A0       LDA #$A0
.C:2e12  85 17       STA <layer_value_ptr
.C:2e14  A9 FD       LDA #$FD
.C:2e16  85 18       STA >layer_value_ptr
;Move .X to .Y - use .Y as actor index
.C:2e18  8A          TXA
.C:2e19  A8          TAY
;Use .X as layer counter, start from #00
.C:2e1a  A2 00       LDX #$00
clear_layer_value:
;Clear the layer value for this actor
.C:2e1c  A9 00       LDA #$00
.C:2e1e  91 17       STA (layer_value_ptr),Y
;Add 4 to the pointer to point to the next layer value
.C:2e20  A5 17       LDA <layer_value_ptr
.C:2e22  18          CLC
.C:2e23  69 04       ADC #$04
.C:2e25  85 17       STA <layer_value_ptr
.C:2e27  90 02       BCC next
.C:2e29  E6 18       INC >layer_value_ptr
next_layer_value:
;Layer values pending? If not, exit
.C:2e2b  E8          INX
.C:2e2c  E0 02       CPX #$02
.C:2e2e  90 EC       BCC clear_layer_value
.C:2e30  F0 EA       BEQ clear_layer_value
.C:2e32  98          TYA
.C:2e33  AA          TAX
.C:2e34  60          RTS
;===========================================
set_layer_2_as_c1:
.C:2e35  A6 D8       LDX actor
.C:2e37  A9 C1       LDA #$C1
.C:2e39  9D A4 FD    STA layer_2_for_actor,X
.C:2e3c  60          RTS
;===========================================
clear_layer_1_for_actor:
.C:2e3d  A6 D8       LDX actor
.C:2e3f  A9 00       LDA #$00
.C:2e41  9D A0 FD    STA layer_1_for_actor,X
.C:2e44  60          RTS
;===========================================
clear_layer_1_for_actor_b:
.C:2e45  A6 D8       LDX actor
.C:2e47  A9 00       LDA #$00
.C:2e49  9D A0 FD    STA layer_1_for_actor,X
.C:2e4c  60          RTS
;===========================================
debug_semaphore = $2f

set_layer_3_as_3:
.C:2e4d  A6 D8       LDX actor
.C:2e4f  A9 03       LDA #$03
.C:2e51  9D A8 FD    STA layer_3_for_actor,X
;-------------------------------------
;I highly suspect debug_semaphore was intended to halt execution and inspect data while debugging
;Is the semaphore bit 7 set? If so, exit
.C:2e54  A5 2F       LDA debug_semaphore
.C:2e56  30 15       BMI exit
;Clear semaphore
.C:2e58  A9 00       LDA #$00
.C:2e5a  85 2F       STA debug_semaphore
;map_in_io
.C:2e5c  A0 25       LDY #$25
.C:2e5e  84 01       STY processor_port_register
loop:
.C:2e60  A9 05       LDA #$05
.C:2e62  8D 20 D0    STA vic_border_color_register
;Wait for semaphore to be clear
.C:2e65  A5 2F       LDA debug_semaphore
.C:2e67  F0 F7       BEQ loop
;map_out_io
.C:2e69  A0 24       LDY #$24
.C:2e6b  84 01       STY processor_port_register
;-------------------------------------
exit:
.C:2e6d  60          RTS
;===========================================
layer_ptrs_lo = $2e6e
layer_ptrs_lo:
.C:2e6e  0F 35 3D 45 4D

layer_ptrs_lo = $2e73
layer_ptrs_hi:
.C:2e73  2E 2E 2E 2E 2E 
;2E0F		do_nothing
;2E35		set_layer_2_as_c1
;2E3D		clear_layer_1_for_actor
;2E45		clear_layer_1_for_actor_b
;2E4D		set_layer_3_as_3

.C:2e78  8D 12 FD    STA $FD12
.C:2e7b  8E 13 FD    STX $FD13
.C:2e7e  A0 07       LDY #$07
.C:2e80  8C 41 FC    STY current_actor_limb
;===========================================
;Unused routine
:
.C:2e83  20 EA 25    JSR $25EA
.C:2e86  CE 41 FC    DEC current_actor_limb
.C:2e89  10 F8       BPL $2E83
.C:2e8b  60          RTS
;===========================================
; Updates an actor's motion along the X axis
;
; The algorithm used considers the total rate of motion along the X axis (path_delta_x)
; versus the total rate of motion on the dominant axis (path_delta_dominant).
;
; In case the dominant axis is the X axis, the rates will match. Otherwise, they might not.
;
; On each execution, the routine will determine if the "accumulated" rate of motion for the X axis matches or exceeds the dominant rate of motion.
; If that's the case, then motion along the X axis is needed, and the actor's position is updated accordingly.
; Also, the accumulated motion will get deducted the dominant motion, as the threshold has been exceeded and needs to be accounted for.
;
; If the accumulated rate has not exceeded the dominant rate, then the accumulated rate is updated accordingly and the actor's position is NOT updated.
; This represents the case in which the axis rate is lower than the dominant rate.
;	
; Returns:	.A	#00		Waypoint X position not reached yet and no change of walkbox
;				#01		Waypoint X position has been reached
;				#03		Walkbox changed on X axis
;===========================================
update_actor_x_axis:
.C:2e8c  A6 D8       LDX actor
;Compute the accumulated motion in .A: delta_x + delta_x_step
.C:2e8e  BD F7 FD    LDA path_delta_x_step_for_actor,X
.C:2e91  18          CLC
.C:2e92  7D 03 FE    ADC path_delta_x_for_actor,X
; accumulated < dominant ?  
; If so, don't move on this axis this time
; Do: delta_x_step += delta_x to reflect the accumulated step
; This value is already in .A, so we can jump to update_delta_x_step directly to set it
.C:2e95  DD F3 FD    CMP path_delta_dominant_for_actor,X
.C:2e98  90 12       BCC update_delta_x_step
;------------------------------------------------------------
; accumulated >= dominant
; We have matched/exceeded the threshold for the dominant rate - time to update the actor's position (based on direction)
.C:2e9a  BC 07 FE    LDY path_delta_x_direction_for_actor,X
.C:2e9d  D0 06       BNE move_right
;------------------------------------------------------------
move_left:
.C:2e9f  DE 45 FD    DEC position_to_waypoint_x_for_actor,X
.C:2ea2  4C A8 2E    JMP adjust_accumulated_after_motion
;------------------------------------------------------------
move_right:
.C:2ea5  FE 45 FD    INC position_to_waypoint_x_for_actor,X
;------------------------------------------------------------
adjust_accumulated_after_motion:
;After moving, we have to deduct the dominant rate of motion to the accumulated delta
; step = accumulated_delta - delta_dominant
; step = delta_x + delta_x_step - delta_dominant
; As .A already has delta_x + delta_x_step, we only have to subtract delta_dominant
.C:2ea8  38          SEC
.C:2ea9  FD F3 FD    SBC path_delta_dominant_for_actor,X
update_delta_x_step:
.C:2eac  9D F7 FD    STA path_delta_x_step_for_actor,X
;------------------------------------------------------------
.C:2eaf  20 1B 2F    JSR save_actor_path_data
.C:2eb2  20 F4 2C    JSR update_current_box_for_actor
.C:2eb5  C9 FF       CMP #$FF
.C:2eb7  D0 06       BNE has_waypoint_pos_been_reached
.C:2eb9  20 48 2F    JSR restore_actor_path_data
;The walkbox has changed - return #03
.C:2ebc  A9 03       LDA #$03
.C:2ebe  60          RTS
;------------------------------------------------------------
has_waypoint_pos_been_reached:
.C:2ebf  BD 45 FD    LDA position_to_waypoint_x_for_actor,X
.C:2ec2  DD 25 FD    CMP active_waypoint_x_for_actor,X
.C:2ec5  D0 03       BNE pos_not_reached
;------------------------------------------------------------
pos_reached:
;Path position on this axis reached - return #01
.C:2ec7  A9 01       LDA #$01
.C:2ec9  60          RTS
;------------------------------------------------------------
pos_not_reached:
;Path position on this axis not reached yet - return #00
.C:2eca  A9 00       LDA #$00
.C:2ecc  60          RTS
;===========================================
; This is a variant of update_actor_x_axis but for the Y axis.
;
; Returns:	.A	#00		Waypoint Y position not reached yet and no change of walkbox
;				#01		Waypoint Y position has been reached
;				#04		Walkbox changed on Y axis
;===========================================
update_actor_y_axis:
;Compute the accumulated motion in .A: delta_y + delta_y_step
.C:2ecd  BD FB FD    LDA path_delta_y_step_for_actor,X
.C:2ed0  18          CLC
.C:2ed1  7D FF FD    ADC path_delta_y_for_actor,X
; accumulated < dominant ?  
; If so, don't move on this axis this time
; Do: delta_y_step += delta_y to reflect the accumulated step
; This value is already in .A, so we can jump to update_delta_y_step directly to set it
.C:2ed4  DD F3 FD    CMP path_delta_dominant_for_actor,X
.C:2ed7  90 12       BCC set_delta_y_copy
;------------------------------------------------------------
; accumulated >= dominant
; We have matched/exceeded the threshold for the dominant rate - time to update the actor's position (based on direction)
.C:2ed9  BC 0B FE    LDY path_delta_y_direction_for_actor,X
.C:2edc  D0 06       BNE move_up
;------------------------------------------------------------
move_down:
.C:2ede  DE 49 FD    DEC position_to_waypoint_y_for_actor,X
.C:2ee1  4C E7 2E    JMP adjust_accumulated_after_motion
;------------------------------------------------------------
move_up:
.C:2ee4  FE 49 FD    INC position_to_waypoint_y_for_actor,X
;------------------------------------------------------------
adjust_accumulated_after_motion:
;After moving, we have to deduct the dominant rate of motion to the accumulated delta
; step = accumulated_delta - delta_dominant
; step = delta_y + delta_y_step - delta_dominant
; As .A already has delta_y + delta_y_step, we only have to subtract delta_dominant
.C:2ee7  38          SEC
.C:2ee8  FD F3 FD    SBC path_delta_dominant_for_actor,X
update_delta_y_step:
.C:2eeb  9D FB FD    STA path_delta_y_step_for_actor,X
;------------------------------------------------------------
.C:2eee  20 1B 2F    JSR save_actor_path_data
.C:2ef1  20 F4 2C    JSR update_current_box_for_actor
.C:2ef4  C9 FF       CMP #$FF
.C:2ef6  D0 06       BNE depth_determined
.C:2ef8  20 48 2F    JSR restore_actor_path_data
;The walkbox has changed - return #04
.C:2efb  A9 04       LDA #$04
.C:2efd  60          RTS
;------------------------------------------------------------
depth_determined:
.C:2efe  BD FF FD    LDA path_delta_y_for_actor,X
.C:2f01  F0 0A       BEQ has_waypoint_pos_been_reached
.C:2f03  C9 FF       CMP #$FF
.C:2f05  D0 06       BNE has_waypoint_pos_been_reached
.C:2f07  20 48 2F    JSR restore_actor_path_data
;Return #04
.C:2f0a  A9 04       LDA #$04
.C:2f0c  60          RTS
;------------------------------------------------------------
has_waypoint_pos_been_reached:
.C:2f0d  BD 49 FD    LDA position_to_waypoint_y_for_actor,X
.C:2f10  DD 2D FD    CMP active_waypoint_y_for_actor,X
.C:2f13  D0 03       BNE pos_not_reached
;------------------------------------------------------------
pos_reached:
.C:2f15  A9 01       LDA #$01
.C:2f17  60          RTS
;------------------------------------------------------------
pos_not_reached:
.C:2f18  A9 00       LDA #$00
.C:2f1a  60          RTS
;===========================================
; Saves an actor's path data variables
;
; Also sets the current position variables to use the "copy" sets
; That is: position_x_for_actor = position_to_waypoint_x_for_actor (and accordingly for the Y axis)
;===========================================
save_actor_path_data:
.C:2f1b  A6 D8       LDX actor
;Save actor's X and Y position
.C:2f1d  BD 41 FD    LDA position_x_for_actor,X
.C:2f20  8D 5A CB    STA saved_position_x_for_actor
.C:2f23  BD 3D FD    LDA position_y_for_actor,X
.C:2f26  8D 5B CB    STA saved_position_y_for_actor
;Save layer depth
.C:2f29  BD 18 FD    LDA layer_depth_for_actor,X
.C:2f2c  8D 5D CB    STA saved_layer_depth_for_actor
;Set position to use the copy values
.C:2f2f  BD 45 FD    LDA position_to_waypoint_x_for_actor,X
.C:2f32  9D 41 FD    STA position_x_for_actor,X
.C:2f35  BD 49 FD    LDA position_to_waypoint_y_for_actor,X
.C:2f38  9D 3D FD    STA position_y_for_actor,X
;Save current box and path update
.C:2f3b  BD CD FD    LDA current_box_for_actor,X
.C:2f3e  8D 5E CB    STA saved_current_box_for_actor
.C:2f41  BD E1 FD    LDA path_update_needed_for_actor,X
.C:2f44  8D 5F CB    STA saved_path_update_needed_for_actor
.C:2f47  60          RTS
;===========================================
; Restores an actor's path data variables
;===========================================
restore_actor_path_data:
.C:2f48  A6 D8       LDX actor
;Restore the saved position
.C:2f4a  AD 5A CB    LDA saved_position_x_for_actor
.C:2f4d  9D 41 FD    STA position_x_for_actor,X
.C:2f50  9D 45 FD    STA position_to_waypoint_x_for_actor,X
.C:2f53  AD 5B CB    LDA saved_position_y_for_actor
.C:2f56  9D 3D FD    STA position_y_for_actor,X
.C:2f59  9D 49 FD    STA position_to_waypoint_y_for_actor,X
;Restore layer depth
.C:2f5c  AD 5D CB    LDA saved_layer_depth_for_actor
.C:2f5f  9D 18 FD    STA layer_depth_for_actor,X
;Restore current box
.C:2f62  AD 5E CB    LDA saved_current_box_for_actor
.C:2f65  9D CD FD    STA current_box_for_actor,X
;Restore path update
.C:2f68  AD 5F CB    LDA saved_path_update_needed_for_actor
.C:2f6b  9D E1 FD    STA path_update_needed_for_actor,X
.C:2f6e  60          RTS
;========================================================================================
; Set path delta variables for an actor, given its current position and path destination
;
; Arguments:		active_waypoint_x_for_actor
;					active_waypoint_y_for_actor
;					position_to_waypoint_x_for_actor
;					position_to_waypoint_y_for_actor
;
; Returns:	.A		#00	if there's at least one non-zero delta (movement needed)
;					#01	if both deltas (vertical and horizontal) are zero (movement not needed)
;
;					path_dominant_axis					#00 = horizontal, #01 = vertical
;					path_delta_dominant_for_actor		The dominant delta value (the largest between the deltas for the 2 axis)
;					path_delta_x_for_actor				Absolute value of delta between current position and path destination (X axis)
;					path_delta_y_for_actor				Absolute value of delta between current position and path destination (Y axis)
;					path_delta_x_step_for_actor			How much to move along this axis on each step to match the rate of motion on the other axis
;					path_delta_y_step_for_actor			Same as above but for the Y axis
;					path_delta_x_direction_for_actor	#00 = left, #01 = right
;					path_delta_y_direction_for_actor	#00 = up, #01 = down
;========================================================================================
path_delta_y = $cb61			;Absolute value of delta between current position and path destination (Y axis)
path_delta_x = $cb62			;Absolute value of delta between current position and path destination (X axis)
path_delta_dominant = $cb63		;The dominant delta value (the largest between the deltas for the 2 axis)
path_delta_x_step = $cb64		;How much to move along this axis on each step to match the rate of motion on the other axis
path_delta_y_step = $cb65		;Same as above but for the Y axis

set_path_deltas:
;Initialize X direction to #00 (left), Y direction to #00 (up), dominant axis to #00 (horizontal)
.C:2f6f  A0 00       LDY #$00
.C:2f71  8C 58 CB    STY path_delta_x_direction
.C:2f74  8C 59 CB    STY path_delta_y_direction
.C:2f77  8C 66 CB    STY path_dominant_axis
;-----------------------------------------------
;Compare X position vs. path X destination
.C:2f7a  A6 D8       LDX actor
.C:2f7c  BD 25 FD    LDA active_waypoint_x_for_actor,X
.C:2f7f  DD 45 FD    CMP position_to_waypoint_x_for_actor,X
.C:2f82  90 09       BCC path_x_le_pos
;-----------------------------------------------
path_x_gt_pos:
;Path >= position
;Do: path - position to compute the delta
.C:2f84  FD 45 FD    SBC position_to_waypoint_x_for_actor,X
;As position < path, the position - path subtraction doesn't need a borrow
;This means the carry, after subtraction, is set
;Rotate the carry into path_delta_x_direction
;This sets the delta X direction to #01 (right)
.C:2f87  2E 58 CB    ROL path_delta_x_direction
.C:2f8a  4C 94 2F    JMP set_path_delta_x
;-----------------------------------------------
path_x_le_pos:
;Path < position
;Do: position - path to compute the delta
.C:2f8d  BD 45 FD    LDA position_to_waypoint_x_for_actor,X
.C:2f90  38          SEC
.C:2f91  FD 25 FD    SBC active_waypoint_x_for_actor,X
;Note: Carry #01 is NOT set into path_delta_x_direction
;This keeps the delta X direction at its current value of #00 (left)
;-----------------------------------------------
set_path_delta_x:
.C:2f94  8D 62 CB    STA path_delta_x
;-----------------------------------------------
;Repeat the same logic with the Y coordinates
.C:2f97  BD 2D FD    LDA active_waypoint_y_for_actor,X
.C:2f9a  DD 49 FD    CMP position_to_waypoint_y_for_actor,X
.C:2f9d  90 09       BCC path_y_le_pos
;-----------------------------------------------
path_y_gt_pos:
;Path destination >= position
;Do: path - position to compute the delta
.C:2f9f  FD 49 FD    SBC position_to_waypoint_y_for_actor,X
;Rotate the carry (#01 as there was no borrow) into path_delta_y_direction
;This sets the delta Y direction to #01 (down)
.C:2fa2  2E 59 CB    ROL path_delta_y_direction
.C:2fa5  4C AF 2F    JMP set_path_delta_y
;-----------------------------------------------
path_y_le_pos:
;Path destination < position
;Do: position - path to compute the delta
.C:2fa8  BD 49 FD    LDA position_to_waypoint_y_for_actor,X
.C:2fab  38          SEC
.C:2fac  FD 2D FD    SBC active_waypoint_y_for_actor,X
;Delta Y direction value remains at #00 (up)
set_path_delta_y:
.C:2faf  8D 61 CB    STA path_delta_y
;-----------------------------------------------
;Did we have any non-zero delta? If so, continue
.C:2fb2  AD 62 CB    LDA path_delta_x
.C:2fb5  D0 08       BNE determine_dominant_axis
.C:2fb7  AC 61 CB    LDY path_delta_y
.C:2fba  D0 03       BNE determine_dominant_axis
;Deltas are both zero - return #01
.C:2fbc  A9 01       LDA #$01
.C:2fbe  60          RTS
;-----------------------------------------------
determine_dominant_axis:
;Which axis of motion is dominant? Vertical or horizontal?
;That is, which delta of the two is greater in value?
;This is used to move the actor facing along the dominant axis to make it look more natural
.C:2fbf  AD 62 CB    LDA path_delta_x
.C:2fc2  CD 61 CB    CMP path_delta_y
;If delta_x >= delta_y, the horizontal axis is dominant
;Continue and keep path_dominant_axis with its value of #00 (horizontal)
.C:2fc5  B0 05       BCS determine_dominant_value
;delta_y > delta_x
;Vertical axis is dominant
;Set path_dominant_axis as #01 (vertical)
.C:2fc7  A9 01       LDA #$01
.C:2fc9  8D 66 CB    STA path_dominant_axis
;-----------------------------------------------
;The comparison is performed again, but now it's used to set the greater delta value as the "dominant value"
; instead of setting the dominant axis.
;Which of the 2 deltas is dominant? Compare them to find out
determine_dominant_value:
.C:2fcc  AD 62 CB    LDA path_delta_x
.C:2fcf  CD 61 CB    CMP path_delta_y
.C:2fd2  B0 03       BCS set_delta_dominant
.C:2fd4  AD 61 CB    LDA path_delta_y
set_delta_dominant:
;Set the result as the "path delta dominant" value
.C:2fd7  8D 63 CB    STA path_delta_dominant
;-----------------------------------------------
;Copy deltas as initial step delta values
.C:2fda  AD 62 CB    LDA path_delta_x
.C:2fdd  8D 64 CB    STA path_delta_x_step
.C:2fe0  AD 61 CB    LDA path_delta_y
.C:2fe3  8D 65 CB    STA path_delta_y_step
;Copy the delta directions for this actor
.C:2fe6  A6 D8       LDX actor
.C:2fe8  AD 58 CB    LDA path_delta_x_direction
.C:2feb  9D 07 FE    STA path_delta_x_direction_for_actor,X
.C:2fee  AD 59 CB    LDA path_delta_y_direction
.C:2ff1  9D 0B FE    STA path_delta_y_direction_for_actor,X
;Copy the delta dominant value for this actor
.C:2ff4  AD 63 CB    LDA path_delta_dominant
.C:2ff7  9D F3 FD    STA path_delta_dominant_for_actor,X
;Copy the delta values for this actor
.C:2ffa  AD 61 CB    LDA path_delta_y
.C:2ffd  9D FF FD    STA path_delta_y_for_actor,X
.C:3000  AD 62 CB    LDA path_delta_x
.C:3003  9D 03 FE    STA path_delta_x_for_actor,X
;Copy the initial step values
.C:3006  AD 64 CB    LDA path_delta_x_step
.C:3009  9D F7 FD    STA path_delta_x_step_for_actor,X
.C:300c  AD 65 CB    LDA path_delta_y_step
.C:300f  9D FB FD    STA path_delta_y_step_for_actor,X
;Return #00
.C:3012  A9 00       LDA #$00
.C:3014  60          RTS
;===========================================
; Converts an actor's position to a sprite position
;===========================================
convert_actor_pos_to_sprite_pos:
.C:3015  20 F7 3F    JSR update_actor_visibility_in_scene
;Clear the actor's sprite's hi byte for the X coordinate
.C:3018  A6 D8       LDX actor
.C:301a  A9 00       LDA #$00
.C:301c  9D 39 FD    STA character_sprite_x_hi,X
;Convert the actor's X coordinate to sprite coordinate
;Subtract the room's visible left edge
.C:301f  BD 41 FD    LDA position_x_for_actor,X
.C:3022  38          SEC
.C:3023  ED 64 06    SBC room_scene_left_edge
;Add 3
.C:3026  18          CLC
.C:3027  69 03       ADC #$03
;Multiply by 8 to convert from tile coordinate to pixel coordinate
.C:3029  0A          ASL A
.C:302a  0A          ASL A
.C:302b  0A          ASL A
;Add 1 and rotate left into x Hi
.C:302c  A8          TAY
.C:302d  C8          INY
.C:302e  98          TYA
.C:302f  3E 39 FD    ROL character_sprite_x_hi,X
;Copy the lo part and subtract 1
.C:3032  9D 1C FD    STA character_sprite_x_lo,X
.C:3035  DE 1C FD    DEC character_sprite_x_lo,X
;Convert the actor's Y coordinate to sprite coordinate
;Multiply by 2 and add 2
.C:3038  BD 3D FD    LDA position_y_for_actor,X
.C:303b  0A          ASL A
.C:303c  18          CLC
.C:303d  69 02       ADC #$02
.C:303f  9D 37 FC    STA character_sprite_y,X
.C:3042  60          RTS
;===========================================
; Advances the animation for all characters.
;
; This routine will:
;	-scan for all characters that have an actor assigned
;		-for those that do, updates the actor's visibility in the scene
;	-updates all active actors graphics
;	-for each actor that has an active sprite
;		-it will check the animation counter for that actor
;		-if it has reached #00, it will translate the actor's position to a sprite's coordinates on screen
;			and update the sprite's coordinates accordingly
;		-otherwise, it will decrement the animation counter
;===========================================
actor_index = $3043

advance_characters_animation:
;Use active_costume as costume index
.C:3044  A9 00       LDA #$00
.C:3046  8D 30 FC    STA active_costume
check_character:
;Load the actor for this costume
.C:3049  AE 30 FC    LDX active_costume
.C:304c  BD 57 FE    LDA actor_for_costume,X
;If actor is inactive, continue with the next one
.C:304f  30 05       BMI next_character
.C:3051  85 D8       STA actor
;Update the actor's visiblity in the room scene
.C:3053  20 F7 3F    JSR update_actor_visibility_in_scene
next_character:
;If more characters are pending, continue
.C:3056  EE 30 FC    INC active_costume
.C:3059  AD 30 FC    LDA active_costume
.C:305c  C9 19       CMP #$19
.C:305e  D0 E9       BNE check_character
;------------------------------------------------
;Assign sprites to all actors
.C:3060  20 D3 3E    JSR assign_sprites_to_actors
;Use actor_index as actor index
.C:3063  A2 00       LDX #$00
.C:3065  8E 43 30    STX actor_index
do_actor:
.C:3068  AE 43 30    LDX actor_index
.C:306b  86 D8       STX actor
;Is there an active sprite for this actor? If not, continue
.C:306d  BD 32 FC    LDA actor_sprite_index,X
.C:3070  C9 FF       CMP #$FF
.C:3072  F0 2E       BEQ next_actor
;------------------------------------------------
;Have we exhausted the animation counter? If so, move the actor sprite to the next position
.C:3074  BD 93 FD    LDA animation_counter_for_actor,X
.C:3077  F0 0E       BEQ move_actor_sprite
;------------------------------------------------
;Animation counter not exhausted yet
;Decrement it
.C:3079  DE 93 FD    DEC animation_counter_for_actor,X
;Refresh animation and set the "actor needs to be drawn" state
.C:307c  BD 97 FD    LDA animation_state_for_actor,X
.C:307f  09 21       ORA #$21
.C:3081  9D 97 FD    STA animation_state_for_actor,X
;Continue with next actor
.C:3084  4C A2 30    JMP next_actor
;------------------------------------------------
move_actor_sprite:
;Is the actor stopped? (#02)
;Z will be set if bits 6-0 == #02
;If Z is set, BNE will NOT be taken
;So if the actor is stopped, the branch will not be taken
.C:3087  BD 68 FD    LDA motion_state_for_actor,X
.C:308a  29 7F       AND #$7F
.C:308c  C9 02       CMP #$02
.C:308e  D0 12       BNE next_actor
;Bits are equal - actor is stopped
;Convert the actor's position to a sprite position
.C:3090  20 15 30    JSR convert_actor_pos_to_sprite_pos
;Copy the new sprite's coordinates
.C:3093  BD 1C FD    LDA character_sprite_x_lo,X
.C:3096  BC 32 FC    LDY actor_sprite_index,X
.C:3099  99 60 FD    STA actor_sprite_x_lo,Y
.C:309c  BD 39 FD    LDA character_sprite_x_hi,X
.C:309f  99 58 FD    STA actor_sprite_x_hi,Y
;------------------------------------------------
next_actor:
;If more actors are pending, continue
.C:30a2  EE 43 30    INC actor_index
.C:30a5  AD 43 30    LDA actor_index
.C:30a8  C9 04       CMP #$04
.C:30aa  D0 BC       BNE do_actor
.C:30ac  60          RTS
;===========================================
;Check if actor's position is outside a specific box
;
;	Arguments:		box_ptr		pointer to box data
;					.Y			offset to box data (relative to box_ptr)
;	Returns:		.A	#00	if inside
;						#FF if outside
;
; 	Note:	if the actor is inside the box, .Y will be advanced by 3
;===========================================
box_ptr = $17

is_actor_pos_inside_box:
;Compare X against left edge
.C:30ad  BD 41 FD    LDA position_x_for_actor,X
.C:30b0  D1 17       CMP (box_ptr),Y
;If X < left edge, return #FF
.C:30b2  90 19       BCC return_ff
;Compare X against right edge
.C:30b4  C8          INY
.C:30b5  D1 17       CMP (box_ptr),Y
.C:30b7  F0 02       BEQ check_y
;If X > right edge, return #FF
.C:30b9  B0 12       BCS return_ff
check_y:
;Check Y against top edge
.C:30bb  C8          INY
.C:30bc  BD 3D FD    LDA position_y_for_actor,X
.C:30bf  D1 17       CMP (box_ptr),Y
;If Y < top edge, return #FF
.C:30c1  90 0A       BCC return_ff
;Check Y against bottom edge
.C:30c3  C8          INY
.C:30c4  D1 17       CMP (box_ptr),Y
;If Y == bottom_edge, return #00
.C:30c6  F0 02       BEQ return_00
;If Y > bottom_edge, return #FF
.C:30c8  B0 03       BCS return_ff
return_00:
.C:30ca  A9 00       LDA #$00
.C:30cc  60          RTS
return_ff:
.C:30cd  A9 FF       LDA #$FF
.C:30cf  60          RTS
;===========================================
; Get a walkbox offset for a given walkbox index
;
; Argument:	.A	walkbox index
; Returns:	.Y	walkbox offset
;
; To do this, it multiplies the walkbox index by 5
;
; This is done with a multiplication by 4 and an addition.
; result = value * 5 = value * (4 + 1) = value * 4 + value * 1
; result = value * 4 + value
;===========================================
get_walkbox_offset:
operand = $fc3f
;Store operand
.C:30d0  8D 3F FC    STA operand
;Multiply operand by 4
.C:30d3  0A          ASL A
.C:30d4  0A          ASL A
.C:30d5  18          CLC
;Add result to operand
.C:30d6  6D 3F FC    ADC operand
;Copy to .Y and return
.C:30d9  A8          TAY
.C:30da  60          RTS
;===========================================
; Arguments:
;		actor_tile_x_coordinate
;===========================================
sprite_ptr = $80
room_scene_mask_layer_row_ptr = $86
actor_sprite_base_lo_copy = $cb68
actor_sprite_base_hi_copy = $cb69
y_coordinate = $fc28
top_coordinate = $fc29
original_top_coordinate = $fc3b
row_in_tile = $fd23
actor_tile_x_coordinate = $fd20
actor_tile_column_index = $fd24
counter = $cb67

mask_actor_with_foreground_layer:
.C:30db  A6 D8       LDX actor
.C:30dd  BD 37 FC    LDA character_sprite_y,X
.C:30e0  8D 28 FC    STA y_coordinate
;Calculate top coordinate
.C:30e3  AD 28 FC    LDA y_coordinate
.C:30e6  38          SEC
.C:30e7  FD 4F FD    SBC max_vertical_offset_for_actor,X
.C:30ea  8D 29 FC    STA top_coordinate
.C:30ed  CE 29 FC    DEC top_coordinate
;Compare #91 (145) vs. top_coordinate and y_coordinate
.C:30f0  A9 91       LDA #$91
; #91 >= top_coordinate?
.C:30f2  CD 29 FC    CMP top_coordinate
.C:30f5  B0 11       BCS $3108
; #91 < top_coordinate
; #91 >= y_coordinate?
.C:30f7  CD 28 FC    CMP y_coordinate
.C:30fa  B0 01       BCS y_coordinate_le_91
;#91 < both coordinates, exit
.C:30fc  60          RTS
y_coordinate_le_91:
; #91 >= y_coordinate
.C:30fd  AD 29 FC    LDA top_coordinate
.C:3100  8D 3B FC    STA original_top_coordinate
.C:3103  A9 00       LDA #$00
.C:3105  8D 29 FC    STA top_coordinate
:
.C:3108  A9 91       LDA #$91
.C:310a  CD 28 FC    CMP y_coordinate
.C:310d  B0 05       BCS $3114
.C:310f  A9 91       LDA #$91
.C:3111  8D 28 FC    STA y_coordinate
:
.C:3114  A6 D8       LDX actor
.C:3116  BC 32 FC    LDY actor_sprite_index,X
.C:3119  20 56 24    JSR set_actor_sprite_base_address
.C:311c  AD 2E FC    LDA <actor_sprite_base
.C:311f  8D 68 CB    STA actor_sprite_base_lo_copy
.C:3122  AD 2F FC    LDA >actor_sprite_base
.C:3125  8D 69 CB    STA actor_sprite_base_hi_copy
.C:3128  AD 28 FC    LDA y_coordinate
.C:312b  4A          LSR A
.C:312c  4A          LSR A
.C:312d  4A          LSR A
.C:312e  AA          TAX
.C:312f  18          CLC
;------------------------------------------------------
;Compute pointer to mask layer row
.C:3130  BD 40 D6    LDA room_scene_row_offsets_lo,X
.C:3133  6D 6D FD    ADC <room_scene_mask_layer_ptr
.C:3136  85 86       STA <room_scene_mask_layer_row_ptr
.C:3138  BD 59 D6    LDA room_scene_row_offsets_hi,X
.C:313b  6D 6E FD    ADC >room_scene_mask_layer_ptr
.C:313e  85 87       STA >room_scene_mask_layer_row_ptr
.C:3140  AD 20 FD    LDA actor_tile_x_coordinate
.C:3143  8D 24 FD    STA actor_tile_column_index
.C:3146  20 99 31    JSR compute_global_mask_index_ptrs
;------------------------------------------------------
compute_sprite_pointer:
.C:3149  AE 28 FC    LDX y_coordinate
.C:314c  EC 29 FC    CPX top_coordinate
.C:314f  F0 47       BEQ exit
.C:3151  BD A8 D5    LDA sprite_row_offsets_lo,X
.C:3154  18          CLC
.C:3155  6D 68 CB    ADC actor_sprite_base_lo_copy
.C:3158  85 80       STA <sprite_ptr
.C:315a  BD 08 D5    LDA sprite_row_offsets_hi,X
.C:315d  6D 69 CB    ADC actor_sprite_base_hi_copy
.C:3160  85 81       STA >sprite_ptr
;If y_coordinate % 8 == 0, move to next mask layer row
.C:3162  8A          TXA
.C:3163  29 07       AND #$07
.C:3165  D0 14       BNE next_sprite_row
;------------------------------------------------------
; Next mask layer row
;------------------------------------------------------
;Point to previous row in mask layer
.C:3167  A5 86       LDA <room_scene_mask_layer_row_ptr
.C:3169  38          SEC
.C:316a  E9 28       SBC #$28
.C:316c  85 86       STA <room_scene_mask_layer_row_ptr
.C:316e  B0 02       BCS $3172
.C:3170  C6 87       DEC >room_scene_mask_layer_row_ptr
:
.C:3172  AE 20 FD    LDX actor_tile_x_coordinate
.C:3175  8E 24 FD    STX actor_tile_column_index
.C:3178  20 99 31    JSR compute_global_mask_index_ptrs
;------------------------------------------------------
next_sprite_row:
;Did we reach the final row of the sprite? If so, exit
.C:317b  AE 28 FC    LDX y_coordinate
.C:317e  EC 29 FC    CPX top_coordinate
.C:3181  90 15       BCC exit
;Move to next row of the sprite
.C:3183  CA          DEX
.C:3184  8E 28 FC    STX y_coordinate
;Calculate y_coordinate % 8 to get the row in the tile
.C:3187  8A          TXA
.C:3188  29 07       AND #$07
.C:318a  8D 23 FD    STA row_in_tile
.C:318d  A0 00       LDY #$00
.C:318f  8C 67 CB    STY counter
.C:3192  20 24 32    JSR apply_mask
.C:3195  4C 49 31    JMP compute_sprite_pointer
exit:
.C:3198  60          RTS
;===========================================
; Compute pointers to the global mask indexes for the actor's sprites
;
; Arguments:	actor_tile_column_index
;				room_scene_mask_layer_row_ptr
;
; Returns:	global_mask_index_ptr_1		first pointer
;			global_mask_index_ptr_2		second pointer 
;			global_mask_index_ptr_3		third pointer
;
; In the code, we'll see this sequence of instructions:
;
;  ASL A
;  TAY
;  TXA
;  ROL A
;  TAX
;  TYA
;
; These are the effects of each of them:
;
; 			C		A						X						Y
; 					a7a6a5a4a3a2a1a0		x7x6x5x4x3x2x1x0
; ASL A
; 			a7		a6a5a4a3a2a1a0--		x7x6x5x4x3x2x1x0
; TAY
; 			a7		a6a5a4a3a2a1a0--		x7x6x5x4x3x2x1x0		a6a5a4a3a2a1a0--
; TXA
; 			a7		x7x6x5x4x3x2x1x0		x7x6x5x4x3x2x1x0		a6a5a4a3a2a1a0--
; ROL A
;			x7		x6x5x4x3x2x1x0a7		x7x6x5x4x3x2x1x0		a6a5a4a3a2a1a0--
; TAX
; 			x7		x6x5x4x3x2x1x0a7		x6x5x4x3x2x1x0a7		a6a5a4a3a2a1a0--
; TYA
; 			x7		a6a5a4a3a2a1a0--		x6x5x4x3x2x1x0a7		a6a5a4a3a2a1a0--
; 
;
; If we had an ROL X instruction (which doesn't exist), then an equivalent, more readable, sequence of instructions would be:
;
;	ASL A
;	ROL X
;
; The net effect of these instructions is to move bit 7 of .A into bit 0 of .X, using .Y as a register to swap values around. 
; This is equivalent to a multiplication of .A by 2.
; The result is a 16-bit value, stored as .X/.A (hi/lo).
;
; By repeating this 3 times, we perform a multiplication of .A by 8.
;
;===========================================
actor_tile_column_index = $fd24

compute_global_mask_index_ptrs:
;Load the column index into .Y
.C:3199  AC 24 FD    LDY actor_tile_column_index
.C:319c  EE 24 FD    INC actor_tile_column_index
;Get the mask layer index for this row and column
.C:319f  B1 86       LDA (room_scene_mask_layer_row_ptr),Y
;Multiply the mask layer index in .A by 8 into .X/.A
;Each mask layer "tile" occupies 8 bytes (8x8 pixels)
.C:31a1  A2 00       LDX #$00
.C:31a3  0A          ASL A
.C:31a4  A8          TAY
.C:31a5  8A          TXA
.C:31a6  2A          ROL A
.C:31a7  AA          TAX
.C:31a8  98          TYA
.C:31a9  0A          ASL A
.C:31aa  A8          TAY
.C:31ab  8A          TXA
.C:31ac  2A          ROL A
.C:31ad  AA          TAX
.C:31ae  98          TYA
.C:31af  0A          ASL A
.C:31b0  A8          TAY
.C:31b1  8A          TXA
.C:31b2  2A          ROL A
.C:31b3  AA          TAX
.C:31b4  98          TYA
;Add 4 to result to skip the block header size, adjust carry into .X if needed
.C:31b5  18          CLC
.C:31b6  69 04       ADC #$04
.C:31b8  90 01       BCC compute_first_mask_pointer
.C:31ba  E8          INX
compute_first_mask_pointer:
;Add offset to base (mask_bit_patterns resource) to compute the first bit pattern pointer
.C:31bb  18          CLC
.C:31bc  6D 7A 7B    ADC mask_bit_patterns_rsrc_lo
.C:31bf  85 43       STA <global_mask_index_ptr_1
.C:31c1  8A          TXA
.C:31c2  6D 78 7B    ADC mask_bit_patterns_rsrc_hi
.C:31c5  85 44       STA >global_mask_index_ptr_1
;--------------------------------------------------
;Repeat the same logic for the second pointer
.C:31c7  AC 24 FD    LDY actor_tile_column_index
.C:31ca  EE 24 FD    INC actor_tile_column_index
;Get the mask layer index for this row and column
.C:31cd  B1 86       LDA (room_scene_mask_layer_row_ptr),Y
;Multiply the mask layer index in .A by 8 into .X/.A
.C:31cf  A2 00       LDX #$00
.C:31d1  0A          ASL A
.C:31d2  A8          TAY
.C:31d3  8A          TXA
.C:31d4  2A          ROL A
.C:31d5  AA          TAX
.C:31d6  98          TYA
.C:31d7  0A          ASL A
.C:31d8  A8          TAY
.C:31d9  8A          TXA
.C:31da  2A          ROL A
.C:31db  AA          TAX
.C:31dc  98          TYA
.C:31dd  0A          ASL A
.C:31de  A8          TAY
.C:31df  8A          TXA
.C:31e0  2A          ROL A
.C:31e1  AA          TAX
.C:31e2  98          TYA
;Add 4 to result to skip the block header size, adjust carry into .X if needed
.C:31e3  18          CLC
.C:31e4  69 04       ADC #$04
.C:31e6  90 01       BCC compute_second_mask_pointer
.C:31e8  E8          INX
compute_second_mask_pointer:
;Add offset to base and store result
.C:31e9  18          CLC
.C:31ea  6D 7A 7B    ADC mask_bit_patterns_rsrc_lo
.C:31ed  85 45       STA <global_mask_index_ptr_2
.C:31ef  8A          TXA
.C:31f0  6D 78 7B    ADC mask_bit_patterns_rsrc_hi
.C:31f3  85 46       STA >global_mask_index_ptr_2
;--------------------------------------------------
;Repeat the same logic for the third pointer
.C:31f5  AC 24 FD    LDY actor_tile_column_index
.C:31f8  EE 24 FD    INC actor_tile_column_index
;Get the mask layer index for this row and column
.C:31fb  B1 86       LDA (room_scene_mask_layer_row_ptr),Y
;Multiply the mask layer index in .A by 8 into .X/.A
.C:31fd  A2 00       LDX #$00
.C:31ff  0A          ASL A
.C:3200  A8          TAY
.C:3201  8A          TXA
.C:3202  2A          ROL A
.C:3203  AA          TAX
.C:3204  98          TYA
.C:3205  0A          ASL A
.C:3206  A8          TAY
.C:3207  8A          TXA
.C:3208  2A          ROL A
.C:3209  AA          TAX
.C:320a  98          TYA
.C:320b  0A          ASL A
.C:320c  A8          TAY
.C:320d  8A          TXA
.C:320e  2A          ROL A
.C:320f  AA          TAX
.C:3210  98          TYA
;Add 4 to result to skip the block header size, adjust carry into .X if needed
.C:3211  18          CLC
.C:3212  69 04       ADC #$04
.C:3214  90 01       BCC compute_third_mask_pointer
.C:3216  E8          INX
compute_third_mask_pointer:
;Add offset to base and store result
.C:3217  18          CLC
.C:3218  6D 7A 7B    ADC mask_bit_patterns_rsrc_lo
.C:321b  85 47       STA <global_mask_index_ptr_3
.C:321d  8A          TXA
.C:321e  6D 78 7B    ADC mask_bit_patterns_rsrc_hi
.C:3221  85 48       STA >global_mask_index_ptr_3
.C:3223  60          RTS
;===========================================
; Apply a mask to an actor's sprites
;
; This will clear a sprite pixels according to the mask,
; so that when they are drawn to the screen, they are "obscured" by a foreground layer.
;
; Arguments:
;		row_in_tile					Number of row in an 8x8 tile
;		global_mask_index_ptr_1-3	Pointers to global mask indexes
;		sprite_ptr					Pointer to actor's sprites
;===========================================
global_mask_patterns_ptr = $8a
pixel_mask = $cb6a
counter = $cb67
row_in_tile = $fd23
sprite_ptr = $80

apply_mask:
.C:3224  AC 23 FD    LDY row_in_tile
;Get global mask index for this row
.C:3227  B1 43       LDA (global_mask_index_ptr_1),Y
.C:3229  A8          TAY
;Get the global mask pattern for that index
.C:322a  B1 8A       LDA (global_mask_patterns_ptr),Y
.C:322c  8D 6A CB    STA pixel_mask
;Clear out all the odd bits (7, 5, 3, 1) - no net effect, as explained in the "mask_bit_patterns" comments
.C:322f  29 55       AND #$55
;"Duplicate" even bits 6, 4, 2 and 0 into their odd siblings (7, 5, 3, 1)
; by doing a shift left and then an OR operation
.C:3231  0A          ASL A
.C:3232  0D 6A CB    ORA pixel_mask
;Mask out the sprite pixels with the pixel mask in .A
.C:3235  AC 67 CB    LDY counter
.C:3238  31 80       AND (sprite_ptr),Y
.C:323a  91 80       STA (sprite_ptr),Y
.C:323c  EE 67 CB    INC counter
;------------------------------------------------------
;Repeat the same logic for the next sprite
.C:323f  AC 23 FD    LDY row_in_tile
.C:3242  B1 45       LDA (global_mask_index_ptr_2),Y
.C:3244  A8          TAY
.C:3245  B1 8A       LDA (global_mask_patterns_ptr),Y
.C:3247  8D 6A CB    STA pixel_mask
.C:324a  29 55       AND #$55
.C:324c  0A          ASL A
.C:324d  0D 6A CB    ORA pixel_mask
.C:3250  AC 67 CB    LDY counter
.C:3253  31 80       AND (sprite_ptr),Y
.C:3255  91 80       STA (sprite_ptr),Y
.C:3257  EE 67 CB    INC counter
;------------------------------------------------------
;Repeat the same logic for the next sprite
.C:325a  AC 23 FD    LDY row_in_tile
.C:325d  B1 47       LDA (global_mask_index_ptr_3),Y
.C:325f  A8          TAY
.C:3260  B1 8A       LDA (global_mask_patterns_ptr),Y
.C:3262  8D 6A CB    STA pixel_mask
.C:3265  29 55       AND #$55
.C:3267  0A          ASL A
.C:3268  0D 6A CB    ORA pixel_mask
.C:326b  AC 67 CB    LDY counter
.C:326e  31 80       AND (sprite_ptr),Y
.C:3270  91 80       STA (sprite_ptr),Y
.C:3272  60          RTS
;===========================================
clear_flashlight_area:
.C:3273  AE 79 FE    LDX flashlight_beam_x
.C:3276  AC 7A FE    LDY flashlight_beam_y
.C:3279  A9 00       LDA #$00
.C:327b  20 8B 32    JSR update_flashlight_area
.C:327e  60          RTS
;===========================================
draw_flashlight_area:
.C:327f  AE 79 FE    LDX flashlight_beam_x
.C:3282  AC 7A FE    LDY flashlight_beam_y
.C:3285  A9 01       LDA #$01
.C:3287  20 8B 32    JSR update_flashlight_area
.C:328a  60          RTS
;===========================================
; Arguments:
;			.A		operation mode
;				#00	clear the flashlight beam area
;				#01	draw the flashlight beam area
;			.X		flashlight beam X
;			.Y		flashlight beam Y
;===========================================
mode = $1b
destination = $17
source = $19

update_flashlight_area:
.C:328b  85 1B       STA mode
;Beam Y coordinate is the actual vertical line divided by 2 (cursor_y_pixel_half)
;Y = (Y * 4) - 3
.C:328d  98          TYA
.C:328e  4A          LSR A
.C:328f  4A          LSR A
.C:3290  38          SEC
.C:3291  E9 03       SBC #$03
.C:3293  A8          TAY
;X = X - 3
.C:3294  8A          TXA
.C:3295  38          SEC
.C:3296  E9 03       SBC #$03
.C:3298  AA          TAX
;Select the proper source and destination pointers based on the current active frame buffer
.C:3299  A5 23       LDA frame_buffer
.C:329b  C9 01       CMP #$01
.C:329d  D0 13       BNE frame_buffer_02
frame_buffer_01:
;Frame buffer #01 is paired with current base video memory at C800
;Set source = CC00, destination = C800
.C:329f  A9 00       LDA #$00
.C:32a1  85 17       STA <destination
.C:32a3  A9 C8       LDA #$C8
.C:32a5  85 18       STA >destination
.C:32a7  A9 00       LDA #$00
.C:32a9  85 19       STA <source
.C:32ab  A9 CC       LDA #$CC
.C:32ad  85 1A       STA >source
.C:32af  4C C2 32    JMP check_x_lower_bound
frame_buffer_02:
;Frame buffer #02 is paired with current base video memory at CC00
;Set source = C800, destination = CC00
.C:32b2  A9 00       LDA #$00
.C:32b4  85 19       STA <source
.C:32b6  A9 C8       LDA #$C8
.C:32b8  85 1A       STA >source
.C:32ba  A9 00       LDA #$00
.C:32bc  85 17       STA <destination
.C:32be  A9 CC       LDA #$CC
.C:32c0  85 18       STA >destination
check_x_lower_bound:
;If X < 0, set it to #00
.C:32c2  E0 00       CPX #$00
.C:32c4  10 02       BPL check_x_upper_bound
.C:32c6  A2 00       LDX #$00
check_x_upper_bound:
;If X > #22, set it to #22
.C:32c8  E0 22       CPX #$22
.C:32ca  90 04       BCC check_y_lower_bound
.C:32cc  F0 02       BEQ check_y_lower_bound
.C:32ce  A2 22       LDX #$22
check_y_lower_bound:
.C:32d0  C0 01       CPY #$01
.C:32d2  70 04       BVS check_negative
.C:32d4  10 06       BPL check_y_upper_bound
.C:32d6  30 02       BMI cap_y_lower
check_negative:
.C:32d8  30 02       BMI check_y_upper_bound
cap_y_lower:
.C:32da  A0 01       LDY #$01
check_y_upper_bound:
;If Y > #0E, set it to #0E
.C:32dc  C0 0E       CPY #$0E
.C:32de  90 04       BCC inline_offsets
.C:32e0  F0 02       BEQ inline_offsets
.C:32e2  A0 0E       LDY #$0E
;Calculate the hi and lo offsets for the screen row
;And set it in the inlined src and dest pointers
inline_offsets:
.C:32e4  B9 BA 3E    LDA screen_row_offsets_lo,Y
.C:32e7  18          CLC
.C:32e8  65 17       ADC <destination
.C:32ea  8D 31 33    STA <inlined_dest
.C:32ed  B9 A1 3E    LDA screen_row_offsets_hi,Y
.C:32f0  65 18       ADC >destination
.C:32f2  8D 32 33    STA >inlined_dest
.C:32f5  B9 BA 3E    LDA screen_row_offsets_lo,Y
.C:32f8  18          CLC
.C:32f9  65 19       ADC <source
.C:32fb  8D 2E 33    STA <inlined_src
.C:32fe  B9 A1 3E    LDA screen_row_offsets_hi,Y
.C:3301  65 1A       ADC >source
.C:3303  8D 2F 33    STA >inlined_src
;Now add the column to both pointers
.C:3306  8A          TXA
.C:3307  18          CLC
.C:3308  6D 2E 33    ADC <inlined_src
.C:330b  8D 2E 33    STA <inlined_src
.C:330e  90 03       BCC add_x_to_dest
.C:3310  EE 2F 33    INC >inlined_src
add_x_to_dest:
.C:3313  8A          TXA
.C:3314  18          CLC
.C:3315  6D 31 33    ADC <inlined_dest
.C:3318  8D 31 33    STA <inlined_dest
.C:331b  90 03       BCC process_area
.C:331d  EE 32 33    INC >inlined_dest
; At this point, the src and dest pointers have different base addresses (C800 vs. CC00)
; but they have the same offsets. 
; These offsets point to the top-left coordinate of the flashlight beam area, which is a 3x5 region.
;
; We'll now process the area, depending on the operation mode.
;
; Mode #00 will clear the area (used when moving the flashlight away from the area)
; Mode #01 will copy the area (used when moving the flashlight to a new area)
;
; When clearing, the destination area will be set to darkness.
;
; When copying, the original room graphics in the source frame buffer (which are fully illuminated)
; are copied to the destination frame buffer, thus providing a small illuminated area of the room.
process_area:
.C:3320  A0 03       LDY #$03
process_row:
.C:3322  A2 05       LDX #$05
copy_or_clear:
;If mode is #00, we're in clear mode (write out a #00 to destination)
;If mode is #01, we're in copy mode (copy from source to destination)
.C:3324  A5 1B       LDA mode
.C:3326  D0 05       BNE copy_mode
;Clear mode - write out a #00
.C:3328  A9 00       LDA #$00
.C:332a  4C 30 33    JMP store_to_destination
inlined_src = $332e
inlined_dest = $3331
;Copy mode - read from source, then store to destination
copy_mode:
.C:332d  BD FF FF    LDA $FFFF,X	;Inlined argument
store_to_destination:
.C:3330  9D FF FF    STA $FFFF,X	;Inlined argument
;Move to next column
.C:3333  CA          DEX
;If there are columns pending, loop to the copy/clear section
.C:3334  10 EE       BPL copy_or_clear
;Next row - Update src and dest offsets
;As there are #28 columns per row, add #28 to source and destination pointers
.C:3336  18          CLC
.C:3337  AD 2E 33    LDA <inlined_src
.C:333a  69 28       ADC #$28
.C:333c  8D 2E 33    STA <inlined_src
.C:333f  AD 2F 33    LDA >inlined_src
.C:3342  69 00       ADC #$00
.C:3344  8D 2F 33    STA >inlined_src
.C:3347  18          CLC
.C:3348  AD 31 33    LDA <inlined_dest
.C:334b  69 28       ADC #$28
.C:334d  8D 31 33    STA <inlined_dest
.C:3350  AD 32 33    LDA >inlined_dest
.C:3353  69 00       ADC #$00
.C:3355  8D 32 33    STA >inlined_dest
;Count next row
.C:3358  88          DEY
;If there are rows pending, loop accordingly
.C:3359  10 C7       BPL process_row
.C:335b  60          RTS
;===========================================
; Update all characters positions and animation limbs
;
; Arguments: None
;===========================================
character_index = $335e

update_characters_positions_and_limbs:
;Init character_index with #00
.C:3361  A9 00       LDA #$00
.C:3363  8D 5E 33    STA character_index
check_character:
;Get the actor assigned for this character/costume
.C:3366  AE 5E 33    LDX character_index
.C:3369  BD 57 FE    LDA actor_for_costume,X
;Is an actor assigned? If not, continue
.C:336c  30 13       BMI next_character
;Save the actor and costume in action
.C:336e  85 D8       STA actor
.C:3370  8E 30 FC    STX active_costume
;Is the costume resource in memory? If not, continue
.C:3373  BD 61 78    LDA costume_rsrc_ptrs_hi,X
.C:3376  F0 09       BEQ next_character
;Set the waypoint for this actor
.C:3378  20 81 1C    JSR set_desired_waypoint_for_actor
;Move the actor along the path
.C:337b  20 F8 29    JSR move_actor_on_path
;Animate the actor's limbs
.C:337e  20 04 25    JSR animate_actor_limbs
next_character:
;Move to the next character
.C:3381  EE 5E 33    INC character_index
;Are there characters pending? If so, continue with the next one
.C:3384  AD 5E 33    LDA character_index
.C:3387  C9 19       CMP #$19
.C:3389  D0 DB       BNE check_character
;Otherwise, exit
.C:338b  60          RTS
;===========================================
; Redraws all active actors that have the "refresh animation" state set
;===========================================
redraw_actors_that_need_refresh:
.C:338c  A9 00       LDA #$00
.C:338e  85 D8       STA actor
;----------------------------------------------------
check_actor:
;Is the actor active? If not, skip it
.C:3390  A6 D8       LDX actor
.C:3392  BD 53 FE    LDA costume_for_actor,X
.C:3395  30 38       BMI next_actor
.C:3397  8D 30 FC    STA active_costume
;Animation needs a refresh? If not, skip it
.C:339a  BD 97 FD    LDA animation_state_for_actor,X
.C:339d  29 01       AND #$01
.C:339f  F0 2E       BEQ next_actor
;Clear "animation refresh" state
.C:33a1  BD 97 FD    LDA animation_state_for_actor,X
.C:33a4  29 FE       AND #$FE
.C:33a6  9D 97 FD    STA animation_state_for_actor,X
;Update the actor's visibility in the scene
.C:33a9  20 F7 3F    JSR update_actor_visibility_in_scene
;Convert the actor's position in the room to sprite's positions in the screen
.C:33ac  20 15 30    JSR convert_actor_pos_to_sprite_pos
;Assign sprites to all actors
.C:33af  20 D3 3E    JSR assign_sprites_to_actors
;Is the actor visible in the scene? If not, continue with the next one
.C:33b2  A6 D8       LDX actor
.C:33b4  BD 6F FD    LDA visibility_in_scene_for_actor,X
.C:33b7  F0 16       BEQ next_actor
;Draw the actor in the scene
.C:33b9  20 52 22    JSR draw_actor
;Is the actor stopped? (#02)
.C:33bc  A6 D8       LDX actor
.C:33be  BD 68 FD    LDA motion_state_for_actor,X
.C:33c1  29 0F       AND #$0F
.C:33c3  C9 02       CMP #$02
;If not, continue with next actor
.C:33c5  D0 08       BNE next_actor
;Actor stopped, set "actor needs to be drawn" state
.C:33c7  A9 20       LDA #$20
.C:33c9  1D 97 FD    ORA animation_state_for_actor,X
.C:33cc  9D 97 FD    STA animation_state_for_actor,X
;----------------------------------------------------
next_actor:
;Move to the next actor
.C:33cf  E6 D8       INC actor
;Are there actors pending? If so, continue
.C:33d1  A5 D8       LDA actor
.C:33d3  C9 04       CMP #$04
.C:33d5  D0 B9       BNE check_actor
;----------------------------------------------------
;Toggle the sprite buffer
.C:33d7  A9 01       LDA #$01
.C:33d9  4D 14 FD    EOR sprite_buffer
.C:33dc  8D 14 FD    STA sprite_buffer
.C:33df  60          RTS
;===========================================
init_sprites_sound:
.C:33e0  AD 16 48    LDA music_playback_in_progress
.C:33e3  F0 01       BEQ check_raster_setup_needed
.C:33e5  60          RTS
check_raster_setup_needed:
;Is raster setup needed?
;If so, exit, as the next section will lock and wait for a synchronization flag
; that only the irq_handler will set. And that will happen only AFTER doing the raster setup.
.C:33e6  A5 96       LDA raster_setup_needed
.C:33e8  D0 31       BNE exit
;map_in_io
.C:33ea  A0 25       LDY #$25
.C:33ec  84 01       STY processor_port_register
;Wait for irq_handler1 to be executed at least once
;Set the synchronization flag and wait for the IRQ handler to clear it
.C:33ee  A9 01       LDA #$01
.C:33f0  85 E3       STA irq_lock
wait_for_irq_handler_entry:
.C:33f2  A5 E3       LDA irq_lock
.C:33f4  D0 FC       BNE wait_for_irq_handler_entry
;At this point, we're sure the IRQ handler has just exited
;Disable interrupts
.C:33f6  78          SEI
;Set blank screen, 25 rows, vertical scroll 3
.C:33f7  A9 0B       LDA #$0B		
.C:33f9  8D 11 D0    STA vic_screen_control_register_1
;Disable all sprites
.C:33fc  A9 00       LDA #$00
.C:33fe  8D 15 D0    STA vic_sprite_enable_register
;Set border color to black
.C:3401  A9 00       LDA #$00
.C:3403  8D 20 D0    STA vic_border_color_register
;???
.C:3406  AD 0C 48    LDA voices_executing_instruction
.C:3409  8D 65 34    STA $3465
.C:340c  F0 05       BEQ io_finished
;Set volume to 0, disable all filters
.C:340e  A9 00       LDA #$00
.C:3410  8D 18 D4    STA volume_control_register
io_finished:
;map_out_io
.C:3413  A0 24       LDY #$24
.C:3415  84 01       STY processor_port_register
;Signal that raster setup is needed
.C:3417  A9 01       LDA #$01
.C:3419  85 96       STA raster_setup_needed
exit:
.C:341b  60          RTS
;===========================================
; General setup for raster interrupts
;===========================================
raster_setup:
;Is raster setup not needed? If so, exit
.C:341c  A5 96       LDA raster_setup_needed
.C:341e  F0 44       BEQ exit
;map_in_io
.C:3420  A0 25       LDY #$25
.C:3422  84 01       STY processor_port_register
;Enable all sprites
.C:3424  A9 FF       LDA #$FF
.C:3426  8D 15 D0    STA vic_sprite_enable_register
;Set IRQ handler to irq_handler1
.C:3429  A9 7A       LDA <irq_handler1
.C:342b  8D FE FF    STA <irq_handler
.C:342e  A9 16       LDA >irq_handler1
.C:3430  8D FF FF    STA >irq_handler
;Set 25 rows, vertical scroll 3
.C:3433  A9 1B       LDA #$1B	
.C:3435  8D 11 D0    STA vic_screen_control_register_1
;Set next raster line for interrupt
.C:3438  A9 FA       LDA #$FA					
.C:343a  8D 12 D0    STA raster_line_register
;Acknowledge raster interrupt (in case one triggered before)
.C:343d  A9 81       LDA #$81	
.C:343f  8D 19 D0    STA vic_irq_flag_register
;Set raster interrupt as the only VIC interrupt enabled
.C:3442  8D 1A D0    STA vic_irq_mask_register
.C:3445  AD 0D DC    LDA cia1_irq_status_register
.C:3448  AD 00 DD    LDA cia2_port_a_data_register
;Set border color to black
.C:344b  A9 00       LDA BLACK_COLOR
.C:344d  8D 20 D0    STA vic_border_color_register
.C:3450  AD 65 34    LDA $3465
.C:3453  F0 06       BEQ finalize_setup
;Reset the SID volume control
.C:3455  AD 6A 47    LDA volume_control_reg_copy
.C:3458  8D 18 D4    STA volume_control_register
finalize_setup:
;map_out_io
.C:345b  A0 24       LDY #$24
.C:345d  84 01       STY processor_port_register
;Enable interrupts
.C:345f  58          CLI
;Raster setup is complete, mark as not needed
.C:3460  A9 00       LDA #$00
.C:3462  85 96       STA raster_setup_needed
exit:
.C:3464  60          RTS
;===========================================
; Load a room - when entering with the current kid
;
; Arguments:	.X		room being entered
;===========================================
load_room:
;Save new room index in stack
.C:3466  8A          TXA
.C:3467  48          PHA
;Reset the sentence queue
.C:3468  20 CC 29    JSR reset_sentence_queue_system
;Execute the current room's exit script
.C:346b  20 9D 3A    JSR execute_room_exit_script
.C:346e  20 CE 3B    JSR clear_actors_visibility_in_scene
;-----------------------------------------
;Release all costumes in use
;Use .X as costume index
.C:3471  A2 18       LDX #$18
release_costume_in_use:
;Is an actor assigned? If not, continue with the next one
.C:3473  BD 57 FE    LDA actor_for_costume,X
.C:3476  30 07       BMI next_costume
.C:3478  8A          TXA
.C:3479  48          PHA
.C:347a  20 E4 38    JSR release_costume
.C:347d  68          PLA
.C:347e  AA          TAX
next_costume:
.C:347f  CA          DEX
.C:3480  D0 F1       BNE release_costume_in_use
;-----------------------------------------
;Restore new room index from stack
.C:3482  68          PLA
.C:3483  AA          TAX
;Copy it to a debugging variable
.C:3484  8E 6B FF    STX var_current_room
;Set default camera position
.C:3487  A9 C8       LDA #$C8
.C:3489  8D 66 06    STA camera_desired_position
;Initialize sprites and sound
.C:348c  20 E0 33    JSR init_sprites_sound
;Load new room's graphics
.C:348f  20 A4 34    JSR setup_rsrcs_for_gfx_and_objects
;Execute the room's entry script
.C:3492  20 7D 3A    JSR execute_room_entry_script
;Load the room's sounds and scripts
.C:3495  20 D5 35    JSR load_room_sounds_and_scripts
;Load actors in the room
.C:3498  20 81 38    JSR load_actors_in_room
;As we just loaded a new room, signal that we need to do the "open shutter" effect
.C:349b  A9 01       LDA #$01
.C:349d  8D 6E 06    STA open_shutter_flag
;Reset the raster IRQ handlers
.C:34a0  20 1C 34    JSR raster_setup
.C:34a3  60          RTS
;===========================================
; Set up resources for loading a room's graphics and objects
;===========================================
setup_rsrcs_for_gfx_and_objects:
.C:34a4  AC 49 71    LDY current_room
.C:34a7  F0 0C       BEQ set_result
;----------------------------------------------
; Set room age to 1 - keep locking status unchanged (bit 7)
;----------------------------------------------
;Is the room unlocked?
.C:34a9  B9 BC 77    LDA room_memory_attrs,Y
.C:34ac  10 05       BPL room_unlocked
;Room is locked - keep it locked, set age to 1
.C:34ae  A9 81       LDA #$81
.C:34b0  4C B5 34    JMP set_result
room_unlocked:
;Keep it unlocked, set age to 1
.C:34b3  A9 01       LDA #$01
set_result:
.C:34b5  99 BC 77    STA room_memory_attrs,Y
;----------------------------------------------
.C:34b8  8E 49 71    STX current_room
.C:34bb  AD 49 71    LDA current_room
.C:34be  8D 6B FF    STA var_current_room
;----------------------------------------------
;Release room layers resource if needed
.C:34c1  AE 79 7B    LDX room_layers_rsrc_lo
.C:34c4  AC 77 7B    LDY room_layers_rsrc_hi
.C:34c7  F0 03       BEQ clear_foreground_mask_layer_rsrc
.C:34c9  20 03 55    JSR release_resource
clear_foreground_mask_layer_rsrc:
.C:34cc  A9 00       LDA #$00
.C:34ce  8D 77 7B    STA room_layers_rsrc_hi
;----------------------------------------------
;Release mask bit patterns resource, if needed
.C:34d1  AE 7A 7B    LDX mask_bit_patterns_rsrc_lo
.C:34d4  AC 78 7B    LDY mask_bit_patterns_rsrc_hi
.C:34d7  F0 03       BEQ clear_mask_bit_patterns_rsrc
.C:34d9  20 03 55    JSR release_resource
clear_mask_bit_patterns_rsrc:
.C:34dc  A9 00       LDA #$00
.C:34de  8D 78 7B    STA mask_bit_patterns_rsrc_hi
;----------------------------------------------
;Do we have a valid room? If so, load its graphics and objects
.C:34e1  AE 49 71    LDX current_room
.C:34e4  D0 11       BNE load_room_gfx_and_objects
;Otherwise, clear the exit and entry script pointers
.C:34e6  A9 00       LDA #$00
.C:34e8  8D 56 71    STA <room_exit_script
.C:34eb  8D 57 71    STA >room_exit_script
.C:34ee  8D 58 71    STA <room_entry_script
.C:34f1  8D 59 71    STA >room_entry_script
.C:34f4  68          PLA
.C:34f5  68          PLA
.C:34f6  60          RTS
;===========================================
; Load and setup a "room scene" (the room graphics)
;===========================================
load_room_gfx_and_objects:
.C:34f7  20 33 38    JSR load_room_resource
.C:34fa  AE 49 71    LDX current_room
;---------------------------
;Set room age to 0, keeping locked/unlocked status unchanged (bit 7)
;Load resource memory attribute
.C:34fd  BD BC 77    LDA room_memory_attrs,X
;If room is unlocked, set age to 00
.C:3500  10 05       BPL room_unlocked
;Room is locked, set age to 00
.C:3502  A9 80       LDA #$80
.C:3504  4C 09 35    JMP set_result
room_unlocked:
.C:3507  A9 00       LDA #$00
set_result:
.C:3509  9D BC 77    STA room_memory_attrs,X
;---------------------------
.C:350c  20 32 35    JSR read_room_misc_data		
.C:350f  20 31 36    JSR read_room_objects		
.C:3512  20 10 37    JSR read_room_graphics
.C:3515  20 12 43    JSR setup_room_scene_rsrc
;----------------------------------------------
; Room age updates for LRU algorithm
;----------------------------------------------
;Increase age for all rooms in memory that have a non-zero age
;Set .X as room counter, start at #36, move downwards
.C:3518  A2 36       LDX #$36
check_room_in_memory:
;Is the room resource in memory? If not, skip to the next one
.C:351a  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:351d  F0 0C       BEQ next_room
;Unlock room
.C:351f  BD BC 77    LDA room_memory_attrs,X
.C:3522  29 7F       AND #$7F
;Is the room age zero? If it is, leave it as zero.
.C:3524  C9 00       CMP #$00
.C:3526  F0 03       BEQ next_room
;If not, increment by 1
.C:3528  FE BC 77    INC room_memory_attrs,X
next_room:
.C:352b  CA          DEX
.C:352c  D0 EC       BNE check_room_in_memory
;----------------------------------------------
.C:352e  AE 49 71    LDX current_room
.C:3531  60          RTS
;===========================================
; Reads and sets up miscellaneous data for a room.
; This includes:
;	-offsets to several compressed sets of data
;	-the background colors
;	-the entry and exit script offsets
; 	-room scene layers dictionaries (for decompression)
;===========================================
room_block_ptr_lo_copy = $C3
room_block_ptr_hi_copy = $C4
read_ptr_lo = $15
read_ptr_hi = $16

read_room_misc_data:
;Read pointer to room block, store a copy in room_block_ptr_copy
.C:3532  AE 49 71    LDX current_room
.C:3535  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:3538  8D 5B 71    STA >current_room_rsrc
.C:353b  85 C4       STA room_block_ptr_hi_copy
.C:353d  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:3540  8D 5A 71    STA <current_room_rsrc
.C:3543  85 C3       STA room_block_ptr_lo_copy
;----------------------------------------------
;Compute the read pointer (adding 4 bytes, thus skipping the header)
.C:3545  18          CLC
.C:3546  A5 C3       LDA room_block_ptr_lo_copy
.C:3548  69 04       ADC #$04
.C:354a  85 15       STA read_ptr_lo
.C:354c  A5 C4       LDA room_block_ptr_hi_copy
.C:354e  69 00       ADC #$00
.C:3550  85 16       STA read_ptr_hi
;----------------------------------------------
;Copy room's width and height, and its background colors
.C:3552  A0 00       LDY #$00
copy_loop_1:
.C:3554  B1 15       LDA (read_ptr_lo),Y
.C:3556  99 39 71    STA room_data,Y
.C:3559  C8          INY
.C:355a  C0 06       CPY #$06
.C:355c  D0 F6       BNE copy_loop_1
;----------------------------------------------
;Copy room scene graphic layers offsets
.C:355e  A0 06       LDY #$06
copy_loop_2:
.C:3560  B1 15       LDA (read_ptr_lo),Y
.C:3562  99 39 71    STA room_data,Y
.C:3565  C8          INY
.C:3566  B1 15       LDA (read_ptr_lo),Y
.C:3568  99 39 71    STA room_data,Y
.C:356b  C8          INY
.C:356c  C0 10       CPY #$10
.C:356e  D0 F0       BNE copy_loop_2
;----------------------------------------------
;Copy room entry and exit script offsets
.C:3570  A0 14       LDY #$14
.C:3572  B1 15       LDA (read_ptr_lo),Y
.C:3574  8D 56 71    STA <room_exit_script
.C:3577  C8          INY
.C:3578  B1 15       LDA (read_ptr_lo),Y
.C:357a  8D 57 71    STA >room_exit_script
.C:357d  C8          INY
.C:357e  B1 15       LDA (read_ptr_lo),Y
.C:3580  8D 58 71    STA <room_entry_script
.C:3583  C8          INY
.C:3584  B1 15       LDA (read_ptr_lo),Y
.C:3586  8D 59 71    STA >room_entry_script
;----------------------------------------------
;Compute new read_ptr by doing room_block_ptr + room_tile_matrix_offset
.C:3589  18          CLC
.C:358a  A5 C3       LDA room_block_ptr_lo_copy
.C:358c  6D 41 71    ADC <room_tile_matrix_offset
.C:358f  85 15       STA read_ptr_lo
.C:3591  A5 C4       LDA room_block_ptr_hi_copy
.C:3593  6D 42 71    ADC >room_tile_matrix_offset
.C:3596  85 16       STA read_ptr_hi
;----------------------------------------------
;Copy symbol dictionary for tile matrix
.C:3598  A0 03       LDY #$03
copy_loop_3:
.C:359a  B1 15       LDA (read_ptr_lo),Y
.C:359c  99 4A 71    STA symbol_dictionary_for_tile_matrix,Y
.C:359f  88          DEY
.C:35a0  10 F8       BPL copy_loop_3
;----------------------------------------------
;Compute new read_ptr by doing room_block_ptr + room_color_layer_offset
.C:35a2  18          CLC
.C:35a3  A5 C3       LDA room_block_ptr_lo_copy
.C:35a5  6D 43 71    ADC <room_color_layer_offset
.C:35a8  85 15       STA read_ptr_lo
.C:35aa  A5 C4       LDA room_block_ptr_hi_copy
.C:35ac  6D 44 71    ADC >room_color_layer_offset
.C:35af  85 16       STA read_ptr_hi
;----------------------------------------------
;Copy symbol dictionary for color layer
.C:35b1  A0 03       LDY #$03
copy_loop_4:
.C:35b3  B1 15       LDA (read_ptr_lo),Y
.C:35b5  99 4E 71    STA symbol_dictionary_for_color_layer,Y
.C:35b8  88          DEY
.C:35b9  10 F8       BPL copy_loop_4
;----------------------------------------------
;Compute new read_ptr by doing room_block_ptr + room_mask_layer_offset
.C:35bb  18          CLC
.C:35bc  A5 C3       LDA room_block_ptr_lo_copy
.C:35be  6D 45 71    ADC <room_mask_layer_offset
.C:35c1  85 15       STA read_ptr_lo
.C:35c3  A5 C4       LDA room_block_ptr_hi_copy
.C:35c5  6D 46 71    ADC >room_mask_layer_offset
.C:35c8  85 16       STA read_ptr_hi
;----------------------------------------------
;Copy symbol dictionary for mask layer
.C:35ca  A0 03       LDY #$03
copy_loop_5:
.C:35cc  B1 15       LDA (read_ptr_lo),Y
.C:35ce  99 52 71    STA symbol_dictionary_for_mask_layer,Y
.C:35d1  88          DEY
.C:35d2  10 F8       BPL copy_loop_5
.C:35d4  60          RTS
;===========================================
; Load a room's sounds and scripts
;
; This routine:
;	-reads the total number of sounds (offset #12)
;	-reads the total number of scripts (offset #13)
;	-computes the start address of the room's subresources
;		to start reading from it
;	-reads each sound index in succession from the subresources section
;		and loads each sound, by sound index
;	-reads each script index in succession from the subresources section
;		and loads each script, by script index
;===========================================
room_subresources_ptr = $15
sound_counter = $17
script_counter = $18
data_start = $19

load_room_sounds_and_scripts:
;Compute the actual data start address (skip the header - 4 bytes)
.C:35d5  AE 49 71    LDX current_room
.C:35d8  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:35db  18          CLC
.C:35dc  69 04       ADC #$04
.C:35de  85 19       STA <data_start
.C:35e0  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:35e3  69 00       ADC #$00
.C:35e5  85 1A       STA >data_start
;Read sound and script counters from offsets #12 and #13
.C:35e7  A0 12       LDY #$12
.C:35e9  B1 19       LDA (data_start),Y
.C:35eb  85 17       STA sound_counter
.C:35ed  A0 13       LDY #$13
.C:35ef  B1 19       LDA (data_start),Y
.C:35f1  85 18       STA script_counter
;-------------------------------
;Load sounds
.C:35f3  A0 00       LDY #$00
.C:35f5  A5 17       LDA sound_counter
.C:35f7  F0 0D       BEQ load_scripts
next_sound:
;Even though the room subresource pointer is recomputed on every loop iteration,
;it's actually the same base pointer. The only thing that changes is the .Y index
.C:35f9  20 18 36    JSR get_room_subresources_ptr
;Read sound index
.C:35fc  B1 15       LDA (room_subresources_ptr),Y
;Load the sound by index
.C:35fe  20 E6 39    JSR load_sound
;Move to the next byte, update counter, continue if needed
.C:3601  C8          INY
.C:3602  C6 17       DEC sound_counter
.C:3604  D0 F3       BNE next_sound
;-------------------------------
load_scripts:
.C:3606  A5 18       LDA script_counter
.C:3608  F0 0D       BEQ exit
next_script:
.C:360a  20 18 36    JSR get_room_subresources_ptr
;Read script index
.C:360d  B1 15       LDA (room_subresources_ptr),Y
;Load the script by index
.C:360f  20 29 3A    JSR load_script
;Move to the next byte, update counter, continue if needed
.C:3612  C8          INY
.C:3613  C6 18       DEC script_counter
.C:3615  D0 F3       BNE next_script
exit:
.C:3617  60          RTS
;===========================================
; Get a pointer to the start of a room's sub-resources
; 
; Arguments:	current_room
; Returns:		room_subresources_ptr
;===========================================
room_subresources_ptr = $15
get_room_subresources_ptr:
.C:3618  AE 49 71    LDX current_room
;Calculate 4 * total_objects_in_room (to skip the objects metadata)
.C:361b  AD 5C 71    LDA total_objects_in_room
.C:361e  0A          ASL A
.C:361f  0A          ASL A
;Skip room header (#1C bytes long)
.C:3620  18          CLC
.C:3621  69 1C       ADC #$1C
;Add the resulting offset to the room resource address to get the desired pointer
.C:3623  18          CLC
.C:3624  7D 2A 78    ADC room_rsrc_ptrs_lo,X
.C:3627  85 15       STA <room_subresources_ptr
.C:3629  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:362c  69 00       ADC #$00
.C:362e  85 16       STA >room_subresources_ptr
.C:3630  60          RTS
;===========================================
; Read all of the room's objects into memory
;
; Arguments:	current_room
;
; This will copy each room's object data into static memory.
; It will not allocate a memory block for it.
;
; Read the object's layout description at the beginning of this file
; for more details.
;===========================================
room_block_ptr_lo_copy = $C3
room_block_ptr_hi_copy = $C4
read_ptr_lo = $15
read_ptr_hi = $16
total_objects_copy = $1d
object_counter = $1b

read_room_objects:
;Get pointer to current room's resource
.C:3631  AE 49 71    LDX current_room
.C:3634  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:3637  85 C4       STA room_block_ptr_hi_copy
.C:3639  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:363c  85 C3       STA room_block_ptr_lo_copy
;------------
; Skip the block header
.C:363e  18          CLC
.C:363f  A5 C3       LDA room_block_ptr_lo_copy
.C:3641  69 04       ADC #$04
.C:3643  85 15       STA read_ptr_lo
.C:3645  A5 C4       LDA room_block_ptr_hi_copy
.C:3647  69 00       ADC #$00
.C:3649  85 16       STA read_ptr_hi
;------------
; Get the total_objects_in_room
.C:364b  A0 10       LDY #$10
.C:364d  B1 15       LDA (read_ptr_lo),Y
.C:364f  85 1D       STA total_objects_copy
.C:3651  8D 5C 71    STA total_objects_in_room
; If there are no objects, return
.C:3654  D0 03       BNE objects_to_copy
.C:3656  4C 0F 37    JMP exit
;----------------------------------
;Copy the compressed data offsets for each object
objects_to_copy:
.C:3659  85 1B       STA object_counter
.C:365b  A0 18       LDY #$18
.C:365d  A2 02       LDX #$02
;Copy compressed data offsets
copy_compressed_data_offsets:
.C:365f  B1 15       LDA (read_ptr_lo),Y
.C:3661  9D 91 72    STA compressed_object_data_offsets,X
.C:3664  C8          INY
.C:3665  E8          INX
.C:3666  B1 15       LDA (read_ptr_lo),Y
.C:3668  9D 91 72    STA compressed_object_data_offsets,X
.C:366b  C8          INY
.C:366c  E8          INX
.C:366d  C6 1B       DEC object_counter
.C:366f  D0 EE       BNE copy_compressed_data_offsets
;----------------------------------
.C:3671  A5 1D       LDA total_objects_copy
.C:3673  85 1B       STA object_counter
.C:3675  A5 1E       LDA $1E
.C:3677  85 1C       STA $1C
.C:3679  A2 02       LDX #$02
copy_object_offsets:
;Copy the object's offset in the room resource
.C:367b  B1 15       LDA (read_ptr_lo),Y
.C:367d  9D C9 72    STA room_object_offsets_lo,X
.C:3680  C8          INY
.C:3681  E8          INX
.C:3682  B1 15       LDA (read_ptr_lo),Y
.C:3684  9D C9 72    STA room_object_offsets_lo,X
.C:3687  C8          INY
.C:3688  E8          INX
.C:3689  C6 1B       DEC object_counter
.C:368b  D0 EE       BNE copy_object_offsets
;----------------------------------
.C:368d  A9 01       LDA #$01
.C:368f  85 1B       STA object_counter
load_object_data:
;Convert object index to .X index by multiplying by 2
.C:3691  A5 1B       LDA object_counter
.C:3693  0A          ASL A
.C:3694  AA          TAX
;Get the object offset
.C:3695  BD C9 72    LDA room_object_offsets_lo,X
.C:3698  85 15       STA read_ptr_lo
.C:369a  BD CA 72    LDA room_object_offsets_hi,X
.C:369d  85 16       STA read_ptr_hi
;Add the base address to point to the object's data in the room resource
.C:369f  18          CLC
.C:36a0  A5 15       LDA read_ptr_lo
.C:36a2  65 C3       ADC room_block_ptr_lo_copy
.C:36a4  85 15       STA read_ptr_lo
.C:36a6  A5 16       LDA read_ptr_hi
.C:36a8  65 C4       ADC room_block_ptr_hi_copy
.C:36aa  85 16       STA read_ptr_hi
;Copy object attributes
.C:36ac  A6 1B       LDX object_counter
;Copy the object's index hi/lo
.C:36ae  A0 05       LDY #$05
.C:36b0  B1 15       LDA (read_ptr_lo),Y
.C:36b2  9D 21 72    STA room_object_index_hi,X
.C:36b5  A0 04       LDY #$04
.C:36b7  B1 15       LDA (read_ptr_lo),Y
.C:36b9  9D 3D 72    STA room_object_index_lo,X
;Copy object's width
.C:36bc  A0 08       LDY #$08
.C:36be  B1 15       LDA (read_ptr_lo),Y
.C:36c0  9D 95 71    STA object_width,X
;Copy object's X left coordinate
.C:36c3  A0 06       LDY #$06
.C:36c5  B1 15       LDA (read_ptr_lo),Y
.C:36c7  9D 5D 71    STA object_x_start,X
;Set object's "parent object possible" flag based on bit 7 of offset #07
.C:36ca  A0 07       LDY #$07
.C:36cc  B1 15       LDA (read_ptr_lo),Y
.C:36ce  10 05       BPL set_00
.C:36d0  A9 80       LDA #$80
.C:36d2  4C D7 36    JMP set_result
set_00:
.C:36d5  A9 00       LDA #$00
set_result:
.C:36d7  9D 75 72    STA parent_object_possible,X
;Copy object's Y top coordinate from bits 6-0 of offset #07
.C:36da  B1 15       LDA (read_ptr_lo),Y
.C:36dc  29 7F       AND #$7F
.C:36de  9D 79 71    STA object_y_start,X
;Copy object's "parent object" index
.C:36e1  A0 09       LDY #$09
.C:36e3  B1 15       LDA (read_ptr_lo),Y
.C:36e5  9D 59 72    STA parent_object,X
;Copy object's X destination coordinate
.C:36e8  A0 0A       LDY #$0A
.C:36ea  B1 15       LDA (read_ptr_lo),Y
.C:36ec  9D CD 71    STA object_x_destination,X
;Offset #0B encodes the preposition index in bits 7-5
.C:36ef  A0 0B       LDY #$0B
.C:36f1  B1 15       LDA (read_ptr_lo),Y
;Copy object's Y destination coordinate (bits 4-0)
.C:36f3  29 1F       AND #$1F
.C:36f5  9D E9 71    STA object_y_destination,X
;Copy object's height and destination active flag from offset #0C
.C:36f8  A0 0C       LDY #$0C
.C:36fa  B1 15       LDA (read_ptr_lo),Y
.C:36fc  48          PHA
.C:36fd  29 07       AND #$07
.C:36ff  9D 05 72    STA object_destination_active,X
.C:3702  68          PLA
.C:3703  4A          LSR A
.C:3704  4A          LSR A
.C:3705  4A          LSR A
.C:3706  9D B1 71    STA object_height,X
;Continue with next object
.C:3709  E6 1B       INC object_counter
.C:370b  C6 1D       DEC total_objects_copy
.C:370d  D0 82       BNE load_object_data
exit:
.C:370f  60          RTS
;===========================================
; Reads a rooms graphics data (specifically, tile definitions and mask bit patterns)
; 
; See the room format description for details
;===========================================
room_data_lo = $C3
room_data_hi = $C4
copy_counter_lo = $15
copy_counter_hi = $16
write_ptr_lo = $19
write_ptr_hi = $1A
raw_data_size_lo = $1D
raw_data_size_hi = $1E
read_ptr_lo = $27
read_ptr_hi = $28
decomp_src_ptr = $27
memory_range_lo = $4F
memory_range_hi = $50
room_width_unused = $fd91
room_height_unused = $fd92

read_room_graphics:
;Copy room's width and height
.C:3710  AD 39 71    LDA room_width
.C:3713  8D 91 FD    STA room_width_unused
.C:3716  AD 3A 71    LDA room_height
.C:3719  8D 92 FD    STA room_height_unused
;------------------------------------------------------
; Get room resource base address
.C:371c  AE 49 71    LDX current_room
.C:371f  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:3722  85 C3       STA room_data_lo
.C:3724  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:3727  85 C4       STA room_data_hi
;------------------------------------------------------
;map_in_io
.C:3729  A0 25       LDY #$25
.C:372b  84 01       STY processor_port_register
;------------------------------------------------------
;Copy and set room's BKG colors
.C:372d  A2 03       LDX #$03
bkg_color_set_loop:
.C:372f  BD 3B 71    LDA room_bkg_colors,X
.C:3732  9D 21 D0    STA vic_bkg_color0_register,X
.C:3735  CA          DEX
.C:3736  D0 F7       BNE bkg_color_set_loop
;------------------------------------------------------
.C:3738  AD 3B 71    LDA room_bkg_color_0	
.C:373b  85 8F       STA room_bkg_color_copy_0
;map_out_io
.C:373d  A0 24       LDY #$24
.C:373f  84 01       STY processor_port_register
;------------------------------------------------------
;Setup copy counter for a total of #0800 bytes
.C:3741  A9 00       LDA #$00
.C:3743  85 15       STA copy_counter_lo
.C:3745  A9 08       LDA #$08
.C:3747  85 16       STA copy_counter_hi
;------------------------------------------------------
;Set up pointer to compressed dot-data (the tile definitions)
.C:3749  18          CLC
.C:374a  A5 C3       LDA room_data_lo
.C:374c  6D 3F 71    ADC <room_tile_definitions_offset
.C:374f  85 27       STA <decomp_src_ptr
.C:3751  A5 C4       LDA room_data_hi
.C:3753  6D 40 71    ADC >room_tile_definitions_offset
.C:3756  85 28       STA >decomp_src_ptr
;------------------------------------------------------
;Set destination of decompression to D800
.C:3758  A9 00       LDA #$00
.C:375a  85 19       STA write_ptr_lo
.C:375c  A9 D8       LDA #$D8
.C:375e  85 1A       STA write_ptr_hi
.C:3760  20 04 01    JSR decomp_dict4_init
;------------------------------------------------------
; Decompress dot-data
;------------------------------------------------------
.C:3763  A0 00       LDY #$00
loop_1:
;Decompress a byte
.C:3765  20 22 01    JSR decomp_stream_next
;Write byte into dest_ptr
.C:3768  91 19       STA (write_ptr_lo),Y
;Update dest_ptr
.C:376a  E6 19       INC write_ptr_lo
.C:376c  D0 02       BNE update_counters
.C:376e  E6 1A       INC write_ptr_hi
;Update copy counters
update_counters:
.C:3770  A5 15       LDA copy_counter_lo
.C:3772  D0 02       BNE decrement_lo_counter
.C:3774  C6 16       DEC copy_counter_hi
decrement_lo_counter:
.C:3776  C6 15       DEC copy_counter_lo
;If bytes are pending, loop
.C:3778  A5 15       LDA copy_counter_lo
.C:377a  05 16       ORA copy_counter_hi
.C:377c  D0 E7       BNE loop_1
;------------------------------------------------------
;Release previous mask bit patterns resource, if any
.C:377e  AE 7A 7B    LDX mask_bit_patterns_rsrc_lo
.C:3781  AC 78 7B    LDY mask_bit_patterns_rsrc_hi
.C:3784  F0 03       BEQ setup_mask_data_load
.C:3786  20 03 55    JSR release_resource
;--------------------
;Point to the offset for the mask data
setup_mask_data_load:
.C:3789  18          CLC
.C:378a  A5 C3       LDA room_data_lo
.C:378c  6D 47 71    ADC <room_mask_indexes_offset
.C:378f  85 27       STA read_ptr_lo
.C:3791  A5 C4       LDA room_data_hi
.C:3793  6D 48 71    ADC >room_mask_indexes_offset
.C:3796  85 28       STA read_ptr_hi
;--------------------
;Read 16-bit data size from read_ptr into raw_data_size
.C:3798  A0 00       LDY #$00
.C:379a  B1 27       LDA (read_ptr_lo),Y
.C:379c  85 1D       STA raw_data_size_lo
.C:379e  C8          INY
.C:379f  B1 27       LDA (read_ptr_lo),Y
.C:37a1  85 1E       STA raw_data_size_hi
; Add 4 to the data size to account for the resource header, store result into copy_counter
.C:37a3  18          CLC
.C:37a4  A5 1D       LDA raw_data_size_lo
.C:37a6  69 04       ADC #$04
.C:37a8  85 15       STA copy_counter_lo
.C:37aa  A5 1E       LDA raw_data_size_hi
.C:37ac  69 00       ADC #$00
.C:37ae  85 16       STA copy_counter_hi
;--------------------
;Allocate a memory block for the data
.C:37b0  A6 15       LDX copy_counter_lo
.C:37b2  A4 16       LDY copy_counter_hi
.C:37b4  20 E4 54    JSR alloc_data
;--------------------
;Setup block metadata (size, type #04, index #01)
 C:37b7  86 4F       STX memory_range_lo
.C:37b9  84 50       STY memory_range_hi
.C:37bb  A9 04       LDA #$04
.C:37bd  8D 77 56    STA resource_type
.C:37c0  A9 01       LDA #$01
.C:37c2  8D 76 56    STA resource_index
.C:37c5  20 04 56    JSR setup_block_metadata
;--------------------
;Save this block as the mask bit patterns for the room
.C:37c8  A6 4F       LDX memory_range_lo
.C:37ca  A4 50       LDY memory_range_hi
.C:37cc  8E 7A 7B    STX mask_bit_patterns_rsrc_lo
.C:37cf  8C 78 7B    STY mask_bit_patterns_rsrc_hi
;--------------------
;Setup write pointer to the new block 
.C:37d2  86 19       STX write_ptr_lo
.C:37d4  84 1A       STY write_ptr_hi
;Skip block header
.C:37d6  18          CLC
.C:37d7  A5 19       LDA write_ptr_lo
.C:37d9  69 04       ADC #$04
.C:37db  85 19       STA write_ptr_lo
.C:37dd  A5 1A       LDA write_ptr_hi
.C:37df  69 00       ADC #$00
.C:37e1  85 1A       STA write_ptr_hi
;--------------------
;Setup decompressed data counter to the size read
.C:37e3  A5 1D       LDA raw_data_size_lo
.C:37e5  85 15       STA copy_counter_lo
.C:37e7  A5 1E       LDA raw_data_size_hi
.C:37e9  85 16       STA copy_counter_hi
;--------------------
;Load room resource base address
.C:37eb  AE 49 71    LDX current_room
.C:37ee  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:37f1  85 C3       STA room_data_lo
.C:37f3  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:37f6  85 C4       STA room_data_hi
;--------------------
;Add room_mask_indexes_offset to set the read pointer to the start of room_mask_indexes
.C:37f8  18          CLC
.C:37f9  A5 C3       LDA room_data_lo
.C:37fb  6D 47 71    ADC <room_mask_indexes_offset
.C:37fe  85 27       STA read_ptr_lo
.C:3800  A5 C4       LDA room_data_hi
.C:3802  6D 48 71    ADC >room_mask_indexes_offset
.C:3805  85 28       STA read_ptr_hi
;--------------------
;Add #02 to read pointer to skip the data size
.C:3807  18          CLC
.C:3808  A5 27       LDA read_ptr_lo
.C:380a  69 02       ADC #$02
.C:380c  85 27       STA <decomp_src_ptr
.C:380e  A5 28       LDA read_ptr_hi
.C:3810  69 00       ADC #$00
.C:3812  85 28       STA >decomp_src_ptr
;--------------------
;Setup the compression by initializing the symbol dictionary
.C:3814  20 04 01    JSR decomp_dict4_init
.C:3817  A0 00       LDY #$00
;------------------------------------------------------
; Decompress room_mask_indexes data
;------------------------------------------------------
loop_2:
;Decompress a byte
.C:3819  20 22 01    JSR decomp_stream_next
;Write byte into dest_ptr
.C:381c  91 19       STA (write_ptr_lo),Y
;Update dest_ptr
.C:381e  E6 19       INC write_ptr_lo
.C:3820  D0 02       BNE update_counters_2
.C:3822  E6 1A       INC write_ptr_hi
;Update copy counters
update_counters_2:
.C:3824  A5 15       LDA copy_counter_lo
.C:3826  D0 02       BNE decrement_lo_counter2
.C:3828  C6 16       DEC copy_counter_hi
decrement_lo_counter2:
.C:382a  C6 15       DEC copy_counter_lo
.C:382c  A5 15       LDA copy_counter_lo
.C:382e  05 16       ORA copy_counter_hi
;If bytes are pending, loop
.C:3830  D0 E7       BNE loop_2
.C:3832  60          RTS
;===========================================
; Loads a room resource
;
; This is intended for loading a room to then get a subresource from it (such as a sound).
; The use case where a room is loaded because the player entered it is handled in load_room instead.
;
; Arguments:	.X	room resource index
;===========================================
room_data_lo = $387b
room_data_hi = $387c
room_index = $387d

load_room_resource:
;If the room is already loaded in memory, skip the loading from storage
.C:3833  BD F3 77    LDA room_rsrc_ptrs_hi,X
;Bug here - if the branch is taken, .Y will not contain the correct room index
.C:3836  D0 33       BNE set_room_age_to_1
;Set up disk load parameters
.C:3838  8E 76 56    STX resource_index
.C:383b  8E 7D 38    STX room_index
.C:383e  20 BD 3A    JSR prepare_disk_load_for_room
;Set read offset to #00
.C:3841  A9 00       LDA #$00
.C:3843  8D 78 56    STA read_offset
;Set sector index to #00
.C:3846  A9 00       LDA #$00
.C:3848  8D 79 56    STA sector_chain_index
;Set resource type to #03 (room)
.C:384b  A9 03       LDA #$03
.C:384d  8D 77 56    STA resource_type
;Load room resource from storage - returns data pointer in .X/.Y
.C:3850  20 41 55    JSR load_resource
.C:3853  8E 7B 38    STX room_data_lo
.C:3856  8C 7C 38    STY room_data_hi
;Save resource address
.C:3859  AC 7D 38    LDY room_index
.C:385c  AD 7B 38    LDA room_data_lo
.C:385f  99 2A 78    STA room_rsrc_ptrs_lo,Y
.C:3862  AD 7C 38    LDA room_data_hi
.C:3865  99 F3 77    STA room_rsrc_ptrs_hi,Y
;---------------------------
; Update the room's memory age for the LRU algorithm
;---------------------------
.C:3868  AC 76 56    LDY resource_index
set_room_age_to_1:
;Set room age to 1, keep bit 7 (locked/unlocked status) unchanged
.C:386b  B9 BC 77    LDA room_memory_attrs,Y		
.C:386e  10 05       BPL room_unlocked
room_locked:
;It's locked, set age to 1
.C:3870  A9 81       LDA #$81
.C:3872  4C 77 38    JMP set_memory_attribute
room_unlocked:
;It's unlocked, set age count to 1
.C:3875  A9 01       LDA #$01
set_memory_attribute:
;Write back new attribute
.C:3877  99 BC 77    STA room_memory_attrs,Y
.C:387a  60          RTS
;===========================================
; Load all costumes in a room
;
; Arguments:	current_room
;
; For every costume currently in a room, loads the costume and assigns an actor.
;===========================================
unused = $3880
load_actors_in_room:
.C:3881  8D 80 38    STA unused		;Unused variable
.C:3884  A2 00       LDX #$00
check_character_in_room:
;Is an actor assigned for the costume? If not, continue
.C:3886  BD 57 FE    LDA actor_for_costume,X
.C:3889  10 17       BPL next_character
;Is the character in the current room?
.C:388b  BD FC FE    LDA room_for_character,X
.C:388e  CD 49 71    CMP current_room
.C:3891  F0 03       BEQ actor_in_current_room
;If not, continue
.C:3893  4C A2 38    JMP next_character
actor_in_current_room:
;Load costume resource
.C:3896  20 A8 38    JSR load_costume
;Assign an available actor to the costume and initialize it
.C:3899  AE 76 56    LDX resource_index
.C:389c  20 11 39    JSR assign_available_actor
.C:389f  AE 76 56    LDX resource_index
next_character:
.C:38a2  E8          INX
.C:38a3  E0 19       CPX #$19
.C:38a5  D0 DF       BNE check_character_in_room
.C:38a7  60          RTS
;===========================================
; Loads a costume resource
;
; Arguments:	.X	costume resource index
;===========================================
temp_1 = $17
temp_2 = $18
temp_costume_index = $15

load_costume:
;Save resource index
.C:38a8  8E 76 56    STX resource_index
;If the costume is already loaded in memory, return
.C:38ab  BD 61 78    LDA costume_rsrc_ptrs_hi,X
.C:38ae  F0 01       BEQ costume_not_in_memory
.C:38b0  60          RTS
costume_not_in_memory:
;Save costume index
.C:38b1  86 15       STX temp_costume_index
;Get room parent resource for costume
.C:38b3  BD A6 74    LDA room_for_costume,X
;Prepare disk load for the room resource
.C:38b6  AA          TAX
.C:38b7  20 BD 3A    JSR prepare_disk_load_for_room
;Recover costume index
.C:38ba  A5 15       LDA temp_costume_index
.C:38bc  0A          ASL A
.C:38bd  AA          TAX
;Read the costume offset in the room resource
.C:38be  BD BF 74    LDA costume_offset_in_sector,X
.C:38c1  8D 78 56    STA read_offset
;Read the sector index for the costume
.C:38c4  BD C0 74    LDA costume_sector_index,X
.C:38c7  8D 79 56    STA sector_chain_index
;Set resource type as #02 (costume)
.C:38ca  A9 02       LDA #$02
.C:38cc  8D 77 56    STA resource_type
;Load resource data - returns data pointer in .X/.Y
.C:38cf  20 41 55    JSR load_resource
.C:38d2  86 17       STX temp_1
.C:38d4  84 18       STY temp_2
;Save resource address
.C:38d6  AC 76 56    LDY resource_index
.C:38d9  A5 17       LDA temp_1
.C:38db  99 7A 78    STA costume_rsrc_ptrs_lo,Y
.C:38de  A5 18       LDA temp_2
.C:38e0  99 61 78    STA costume_rsrc_ptrs_hi,Y
.C:38e3  60          RTS
;===========================================
; Release a costume
; 
; Arguments:		.X		costume index
;===========================================
release_costume:
;Set actor index into .Y
.C:38e4  BD 57 FE    LDA actor_for_costume,X
.C:38e7  A8          TAY
;Save the actor's position into the costume position
.C:38e8  B9 41 FD    LDA position_x_for_actor,Y
.C:38eb  9D 2E FF    STA costume_x_destination,X
.C:38ee  B9 3D FD    LDA position_y_for_actor,Y
.C:38f1  9D 15 FF    STA costume_y_destination,X
;Set actor as not visible
.C:38f4  A9 00       LDA #$00
.C:38f6  99 6F FD    STA visibility_in_scene_for_actor,Y
;Set mouth state to #00 (closed)
.C:38f9  99 9D FE    STA mouth_state_for_actor,Y
;Clear actor assigned to this costume, clear actor in use
.C:38fc  A9 FF       LDA #$FF
.C:38fe  9D 57 FE    STA actor_for_costume,X
.C:3901  99 53 FE    STA costume_for_actor,Y
;Convert actor's direction to an animation set and save it
.C:3904  B9 EB FD    LDA path_direction_for_actor,Y
.C:3907  20 DF 3B    JSR convert_actor_direction_to_animation_set
.C:390a  9D 47 FF    STA animation_set_for_costume,X
;Assign sprites to all actors
.C:390d  20 D3 3E    JSR assign_sprites_to_actors
.C:3910  60          RTS
;===========================================
; Finds an available actor and assigns it to the costume, initializing it
;
; Arguments:	current_room
;				.X				costume to assign
;
;===========================================
assign_available_actor:
.C:3911  AD 49 71    LDA current_room
.C:3914  D0 01       BNE entry
.C:3916  60          RTS
;Find an unused actor
entry:
;Use .Y as actor index, .X (input argument) as costume index
.C:3917  A0 00       LDY #$00
check_if_actor_in_use:
;Is the actor in use? If so, continue with the next one
.C:3919  B9 53 FE    LDA costume_for_actor,Y
.C:391c  10 04       BPL next_actor
;Actor available - assign it and initialize it
.C:391e  20 27 39    JSR initialize_actor_for_costume
.C:3921  60          RTS
next_actor:
.C:3922  C8          INY
.C:3923  C0 04       CPY #$04
.C:3925  D0 F2       BNE check_if_actor_in_use
;Fall through? Potential bug
;===========================================
; Assign and initialize an actor for a costume
;
; Arguments: 	.X	costume index
;				.Y	actor index
;===========================================
initialize_actor_for_costume:
;Set the costume for this actor
.C:3927  8A          TXA
.C:3928  99 53 FE    STA costume_for_actor,Y
;Set current actor
.C:392b  84 D8       STY actor
;Set the actor for the costume
.C:392d  98          TYA
.C:392e  9D 57 FE    STA actor_for_costume,X
;Set the costume in action
.C:3931  8E 30 FC    STX active_costume
;Set up arguments for the walkbox coordinates adjustment
.C:3934  BD 2E FF    LDA costume_x_destination,X
.C:3937  8D 72 FE    STA box_check_x
.C:393a  BD 15 FF    LDA costume_y_destination,X
.C:393d  8D 73 FE    STA box_check_y
.C:3940  AD 49 71    LDA current_room
.C:3943  8D 74 FE    STA walkbox_room
;Adjust coordinates as needed
.C:3946  20 9B 1A    JSR adjust_coords_by_walkbox
;Restore costume and actor indexes into .X and .Y
.C:3949  AE 30 FC    LDX active_costume
.C:394c  A4 D8       LDY actor
;Copy the adjusted coordinates accordingly
.C:394e  AD 72 FE    LDA box_check_x
.C:3951  9D 2E FF    STA costume_x_destination,X
.C:3954  99 41 FD    STA position_x_for_actor,Y
.C:3957  99 D9 FD    STA destination_x_for_actor,Y
.C:395a  99 25 FD    STA active_waypoint_x_for_actor,Y
.C:395d  AD 73 FE    LDA box_check_y
.C:3960  9D 15 FF    STA costume_y_destination,X
.C:3963  99 3D FD    STA position_y_for_actor,Y
.C:3966  99 DD FD    STA destination_y_for_actor,Y
.C:3969  99 2D FD    STA active_waypoint_y_for_actor,Y
;Set mouth state to #00 (closed)
.C:396c  A9 00       LDA #$00
.C:396e  99 9D FE    STA mouth_state_for_actor,Y
;Load costume (again? this seems redundant)
.C:3971  20 A8 38    JSR load_costume
;Clear previous resource pointer for the active costume
.C:3974  AE 30 FC    LDX active_costume
.C:3977  A9 00       LDA #$00
.C:3979  9D AC 78    STA rsrc_ptr_for_active_costume_lo,X
.C:397c  A9 00       LDA #$00
.C:397e  9D 93 78    STA rsrc_ptr_for_active_costume_hi,X
;Setup the costume's graphics metadata
.C:3981  20 70 24    JSR setup_costume_for_actor
;Initialize the animation sets
.C:3984  A4 D8       LDY actor
.C:3986  A9 FF       LDA #$FF
.C:3988  99 02 FD    STA current_animation_set_for_actor,Y
.C:398b  99 06 FD    STA desired_animation_set_for_actor,Y
;---------------------------------------------------------
; Initialize all actor limbs
;---------------------------------------------------------
;Compute the actor_limb index (actor * 8 + limb_index) 
.C:398e  A5 D8       LDA actor
.C:3990  0A          ASL A
.C:3991  0A          ASL A
.C:3992  0A          ASL A
;Use .Y as actor_limb index
;Use .X as limb counter, starting at #07, going downwareds
.C:3993  A8          TAY
.C:3994  A2 07       LDX #$07
init_limb_cell:
;Init the current and desired limb base cells to #FF
.C:3996  A9 FF       LDA #$FF
.C:3998  99 82 FC    STA actor_limb_current_base_cell,Y
.C:399b  99 A2 FC    STA actor_limb_desired_base_cell,Y
.C:399e  C8          INY
.C:399f  CA          DEX
.C:39a0  10 F4       BPL init_limb_cell
;---------------------------------------------------------
;Restore costume and actor indexes into .X and .Y
.C:39a2  A4 D8       LDY actor
.C:39a4  AE 30 FC    LDX active_costume
;Initialize motion state to stopped (#02)
.C:39a7  A9 02       LDA #$02
.C:39a9  99 68 FD    STA motion_state_for_actor,Y
;Initialize desired argument for actor_limb
.C:39ac  A9 00       LDA #$00
.C:39ae  99 E2 FC    STA actor_limb_desired_argument,Y
;Initialize animation counter
.C:39b1  A9 01       LDA #$01
.C:39b3  99 93 FD    STA animation_counter_for_actor,Y
;Initialize the layer depth
.C:39b6  A9 FF       LDA #$FF
.C:39b8  99 75 FE    STA box_search_depth_for_actor,Y
;Mark that this actor needs a path update
.C:39bb  A9 01       LDA #$01
.C:39bd  99 E1 FD    STA path_update_needed_for_actor,Y
;Set the closest box as the current box and destination box
.C:39c0  AD AC FD    LDA closest_box_index
.C:39c3  99 CD FD    STA current_box_for_actor,Y
;Save this box as the last box for the actor
.C:39c6  99 D1 FD    STA last_box_for_actor,Y
.C:39c9  99 D5 FD    STA destination_box_for_actor,Y
;Get the boundary boxes for this room
.C:39cc  A6 D8       LDX actor
.C:39ce  20 B1 2D    JSR get_walkboxes_for_costume
;Update the current box for this actor (different entry point of the routine)
.C:39d1  20 0A 2D    JSR actor_not_inside_current_box
;Copy the animation set for this costume
.C:39d4  AE 30 FC    LDX active_costume
.C:39d7  BD 47 FF    LDA animation_set_for_costume,X
.C:39da  8D E9 FD    STA desired_animation_set
;Initialize animation argument
.C:39dd  A9 01       LDA #$01
.C:39df  8D E8 FD    STA animation_argument
;Setup the animation set
.C:39e2  20 20 27    JSR apply_animation_set
.C:39e5  60          RTS
;===========================================
; Load a sound resource
;
; Arguments:		.A		sound resource index
;===========================================
temp_1 = $19
temp_2 = $1A
temp_y = $3bdc

load_sound:
;Save .Y in a local variable
.C:39e6  8C DC 3B    STY temp_y
;Save resource index in .A
.C:39e9  8D 76 56    STA resource_index		
;Check if sound is already in memory by looking at the sound resource pointer table
.C:39ec  AA          TAX
.C:39ed  BD C5 78    LDA sound_rsrc_ptrs_hi,X
.C:39f0  F0 01       BEQ sound_not_in_memory
;If sound is in memory, return
.C:39f2  60          RTS
sound_not_in_memory:
;Save resource index in .X into temp_1
.C:39f3  86 19       STX temp_1
;Get the parent room for the sound
.C:39f5  BD D1 76    LDA room_for_sound,X	
.C:39f8  AA          TAX
;Setup the room loading
.C:39f9  20 BD 3A    JSR prepare_disk_load_for_room
;Get the resource index again, multiply by 2 to get the offset into the sector tables
.C:39fc  A5 19       LDA temp_1
.C:39fe  0A          ASL A
.C:39ff  AA          TAX
;Get the sector offset and sector index for this sound
.C:3a00  BD 17 77    LDA sound_offset_in_sector,X		
.C:3a03  8D 78 56    STA read_offset
.C:3a06  BD 18 77    LDA sound_sector_index,X	
.C:3a09  8D 79 56    STA sector_chain_index
;Set resource type as #06 (sound)
.C:3a0c  A9 06       LDA #$06
.C:3a0e  8D 77 56    STA resource_type
;Load room data - returns data pointer in .X/.Y
.C:3a11  20 41 55    JSR load_resource
.C:3a14  86 19       STX temp_1
.C:3a16  84 1A       STY temp_2
.C:3a18  AC 76 56    LDY resource_index		
;Store data pointer for the sound resource
.C:3a1b  A5 19       LDA temp_1
.C:3a1d  99 0B 79    STA sound_rsrc_ptrs_lo,Y
.C:3a20  A5 1A       LDA temp_2
.C:3a22  99 C5 78    STA sound_rsrc_ptrs_hi,Y
;Restore .Y from a local variable
.C:3a25  AC DC 3B    LDY temp_y
.C:3a28  60          RTS
;===========================================
; Load a script resource
;
; Arguments:		.A		script resource index
;
; If the script index has its bit 7 set, the script is local.
; Otherwise, the script is global.
;
; Local and global script locations (sector offset, sector index) are stored in separate tables.
;===========================================
temp_1 = $19
temp_2 = $1A
temp_y = $3bdc

load_script:
;Save .Y in a local variable
.C:3a29  8C DC 3B    STY temp_y
;.A = resource index
.C:3a2c  8D 76 56    STA resource_index
;Check if resource is in memory by looking at the resource pointer table
.C:3a2f  AA          TAX
.C:3a30  BD 97 79    LDA script_rsrc_ptrs_hi,X
.C:3a33  F0 01       BEQ script_not_in_memory
.C:3a35  60          RTS
script_not_in_memory:
;Save resource index in .X into temp_1
.C:3a36  86 19       STX temp_1
;Get the parent room for the script
.C:3a38  BD F1 74    LDA room_for_script,X
.C:3a3b  AA          TAX
;Setup the room loading
.C:3a3c  20 BD 3A    JSR prepare_disk_load_for_room
;Get the resource index again, multiply by 2 to get the offset into the sector tables
;Bit 7 of script index will go to carry
.C:3a3f  A5 19       LDA temp_1
.C:3a41  0A          ASL A
.C:3a42  AA          TAX
;Check carry - if clear, it's a global script
.C:3a43  90 0F       BCC global_script
;Room script - fetch offset and sector index 
.C:3a45  BD 91 76    LDA room_script_offset_in_sector,X
.C:3a48  8D 78 56    STA read_offset
.C:3a4b  BD 92 76    LDA room_script_sector_index,X
.C:3a4e  8D 79 56    STA sector_chain_index
.C:3a51  4C 60 3A    JMP load_script_from_disk
global_script:
;Global script
.C:3a54  BD 91 75    LDA global_script_read_offsets,X
.C:3a57  8D 78 56    STA read_offset
.C:3a5a  BD 92 75    LDA global_script_sector_index,X
.C:3a5d  8D 79 56    STA sector_chain_index
load_script_from_disk:
;Set resource type = #05 - script
.C:3a60  A9 05       LDA #$05
.C:3a62  8D 77 56    STA resource_type
;Load room data - returns data pointer in .X/.Y
.C:3a65  20 41 55    JSR load_resource
.C:3a68  86 19       STX temp_1
.C:3a6a  84 1A       STY temp_2
;Fetch resource index
.C:3a6c  AC 76 56    LDY resource_index
;Store data pointer for the script resource
.C:3a6f  A5 19       LDA temp_1
.C:3a71  99 37 7A    STA script_rsrc_ptrs_lo,Y		
.C:3a74  A5 1A       LDA temp_2
.C:3a76  99 97 79    STA script_rsrc_ptrs_hi,Y		
;Restore .Y from a local variable
.C:3a79  AC DC 3B    LDY temp_y
.C:3a7c  60          RTS
;===========================================
; Execute the room entry script, if present
;===========================================
execute_room_entry_script:
;Is there an entry script for the room?
.C:3a7d  AD 58 71    LDA <room_entry_script
.C:3a80  0D 59 71    ORA >room_entry_script
.C:3a83  D0 01       BNE entry_script_present
;If not, exit
.C:3a85  60          RTS
entry_script_present:
;Set script type to room script
.C:3a86  A9 01       LDA #$01
.C:3a88  8D 19 71    STA script_type_for_script_slot
;Load the script in the first slot
.C:3a8b  AD 58 71    LDA <room_entry_script
.C:3a8e  8D C9 70    STA script_offsets_lo
.C:3a91  AD 59 71    LDA >room_entry_script
.C:3a94  8D B9 70    STA script_offsets_hi
;Launch the script
.C:3a97  A2 00       LDX #$00
.C:3a99  20 D0 5E    JSR launch_script
.C:3a9c  60          RTS
;===========================================
; Execute the room exit script, if present
;===========================================
execute_room_exit_script:
;Is there an exit script for the room?
.C:3a9d  AD 56 71    LDA <room_exit_script
.C:3aa0  0D 57 71    ORA >room_exit_script
.C:3aa3  D0 01       BNE exit_script_present
;If not, exit
.C:3aa5  60          RTS
exit_script_present:
;Set script type to room script
.C:3aa6  A9 01       LDA #$01
.C:3aa8  8D 19 71    STA script_type_for_script_slot
;Load the script in the first slot
.C:3aab  AD 56 71    LDA <room_exit_script
.C:3aae  8D C9 70    STA script_offsets_lo
.C:3ab1  AD 57 71    LDA >room_exit_script
.C:3ab4  8D B9 70    STA script_offsets_hi
;Launch the script
.C:3ab7  A2 00       LDX #$00
.C:3ab9  20 D0 5E    JSR launch_script
.C:3abc  60          RTS
;===========================================
; Prepare load of a room data from disk
;
; On exit, it will setup a new sector chain, leaving it ready for calling "load_resource"
;
; Arguments: .X	- room index
;===========================================
temp_sector = $1d
temp_track = $1e
temp_index = $3bdd

prepare_disk_load_for_room:
.C:3abd  BD 01 74    LDA disk_side_for_room,X
.C:3ac0  CD 9C FE    CMP desired_disk_id		
.C:3ac3  F0 09       BEQ disk_id_correct
.C:3ac5  8E DD 3B    STX temp_index
.C:3ac8  20 EB 3A    JSR check_disk_side		
.C:3acb  AE DD 3B    LDX temp_index
disk_id_correct:
;.X = room index - Multiply by 2 to get the offset into the track/sector array
.C:3ace  8A          TXA
.C:3acf  0A          ASL A
.C:3ad0  AA          TAX
;This zero-check is irrelevant as execution will continue regardless in dummy_label
.C:3ad1  BD 38 74    LDA disk_track_sector_for_room,X
.C:3ad4  1D 39 74    ORA disk_track_sector_for_room+1,X
.C:3ad7  D0 00       BNE dummy_label
dummy_label:
.C:3ad9  BD 38 74    LDA disk_track_sector_for_room,X
.C:3adc  85 1D       STA temp_sector
.C:3ade  BD 39 74    LDA disk_track_sector_for_room+1,X
.C:3ae1  85 1E       STA temp_track
;.X = sector, .Y = track
.C:3ae3  A6 1D       LDX temp_sector
.C:3ae5  A4 1E       LDY temp_track
.C:3ae7  20 D3 44    JSR disk_init_chain
.C:3aea  60          RTS
;===========================================
;Arguments: desired disk side ID on .A
;===========================================
check_disk_side:
.C:3aeb  8D 65 3B    STA $3B65		;3B65 is the disk side number inlined in the message printed "Put in side # and push joystick button."
									;As the value is stored directly in the string, this means that disk side 1 has the character code for "1" (#31)
									; and side 2 uses #32 ("2")
.C:3aee  8D 9C FE    STA desired_disk_id		
;Pause game
.C:3af1  20 D1 18    JSR pause_game
read_disk_id:
;Read the disk ID, which is the very first byte on the disk
;This is byte 0 in track 1, sector 0
.C:3af4  A2 00       LDX #$00
.C:3af6  A0 01       LDY #$01
.C:3af8  20 EE 44    JSR disk_init_chain_and_read
.C:3afb  20 8E 45    JSR disk_stream_next_byte
;Check if it's the desired Disk ID
.C:3afe  CD 9C FE    CMP desired_disk_id		
.C:3b01  D0 04       BNE disk_id_not_equal
;It's the desired one, unpause game and return
.C:3b03  20 DF 18    JSR unpause_game
.C:3b06  60          RTS
;----------------
disk_id_not_equal:
;Print message asking to insert the specific disk side
.C:3b07  A9 59       LDA #$59
.C:3b09  85 DA       STA $DA
.C:3b0b  A9 3B       LDA #$3B
.C:3b0d  85 DB       STA $DB
.C:3b0f  20 15 3B    JSR print_message_wait_for_button
;Check the disk ID again
.C:3b12  4C F4 3A    JMP read_disk_id
;===========================================
; Print a message on the message bar,
; then wait for a joystick button press.
;
;	Arguments:	message		pointer to the message to be printed
;
; Note: message must be a zero-terminated string
;===========================================
message = $da
print_message_wait_for_button:
;map_in_io
.C:3b15  A0 25       LDY #$25
.C:3b17  84 01       STY processor_port_register
;If raster setup is needed, don't change screen and video settings
.C:3b19  A5 96       LDA raster_setup_needed
.C:3b1b  F0 12       BEQ clear_msg_bar_text_2
;Disable blank screen (set bit 4)
.C:3b1d  AD 11 D0    LDA vic_screen_control_register_1
.C:3b20  09 10       ORA #$10						
.C:3b22  8D 11 D0    STA vic_screen_control_register_1
.C:161a  A9 3E       LDA #$3E
.C:161c  A0 09       LDY #$09
;Load value in .A for F800/CC00 VIC memory layout (dot-data/video matrix)
;Load value in .Y for normal text mode
.C:3b25  A9 3E       LDA #$3E		
.C:3b27  A0 09       LDY #$09		
.C:3b29  8D 18 D0    STA vic_memory_control_register
.C:3b2c  8C 16 D0    STY vic_screen_control2_reg
clear_msg_bar_text_2:
.C:3b2f  20 57 28    JSR clear_msg_bar_text
;Copy game paused message to top bar
.C:3b32  A0 00       LDY #$00
copy_pause_msg_next_char:
.C:3b34  B1 DA       LDA (message),Y
.C:3b36  F0 06       BEQ wait_for_button_press	;Have we found the end-of-string? (#00)
.C:3b38  99 00 CC    STA msg_bar_text_base,Y
.C:3b3b  C8          INY
.C:3b3c  D0 F6       BNE copy_pause_msg_next_char
wait_for_button_press:
.C:3b3e  20 A6 21    JSR joy_latch
.C:3b41  29 10       AND #$10		;Check joy #1 fire button pressed?
.C:3b43  D0 F9       BNE wait_for_button_press
;Clear the top bar msg
.C:3b45  20 57 28    JSR clear_msg_bar_text
;If raster setup is needed, don't turn the screen off
.C:3b48  A5 96       LDA raster_setup_needed
.C:3b4a  F0 08       BEQ exit
;Enable blank screen (clear bit 4)
.C:3b4c  AD 11 D0    LDA vic_screen_control_register_1
.C:3b4f  29 EF       AND #$EF					
.C:3b51  8D 11 D0    STA vic_screen_control_register_1
exit:
;map_out_io
.C:3b54  A0 24       LDY #$24
.C:3b56  84 01       STY processor_port_register
.C:3b58  60          RTS
;===========================================
insert_disk_side_msg:
.C:3b59  ;"Put in side # and push joystick button."
50 75 74 20 69 6E 20 73 69 64 
65 20 23 20 61 6E 64 20 70 75 
73 68 20 6A 6F 79 73 74 69 63 
6B 20 62 75 74 74 6F 6E 2E 00

disk_error_msg:
.C:3b81  ;"Disk Error, push button to continue."
44 69 73 6B 20 45 72 72 6F 72 
2C 20 70 75 73 68 20 62 75 74 
74 6F 6E 20 74 6F 20 63 6F 6E 
74 69 6E 75 65 2E 00 

game_paused_msg:
3ba6 ; "Game paused, press SPACE to continue.  "
47 61 6D 65 20 70 61 75 73 65 
64 2C 20 70 72 65 73 73 20 53 
50 41 43 45 20 74 6F 20 63 6F 
6E 74 69 6E 75 65 2E 20 20 00

;===========================================
; Clear all actors visibility in the scene
;===========================================
clear_actors_visibility_in_scene:
.C:3bce  A9 00       LDA #$00
.C:3bd0  A2 03       LDX #$03
clear_visibility:
.C:3bd2  9D 6F FD    STA visibility_in_scene_for_actor,X
.C:3bd5  CA          DEX
.C:3bd6  10 FA       BPL clear_visibility
;Assign sprites to all actors
.C:3bd8  20 D3 3E    JSR assign_sprites_to_actors
.C:3bdb  60          RTS
;===========================================
; Converts an actor's direction bitmask (00/01/80/81) to a costume's standing animation set (04/05/06/07)
;
; The costume animation sets are limited to the standing range of values.
; They are consumed by scripts to determine the direction a costume is facing.
; 
; Arguments:	.A	direction bitmask
; Returns:		.A	costume animation set
;===========================================
convert_actor_direction_to_animation_set:
check_00:
.C:3bdf  C9 00       CMP #$00
.C:3be1  D0 05       BNE check_01
.C:3be3  A9 05       LDA #$05
.C:3be5  4C FC 3B    JMP exit
check_01:
.C:3be8  C9 01       CMP #$01
.C:3bea  D0 05       BNE check_81
.C:3bec  A9 04       LDA #$04
.C:3bee  4C FC 3B    JMP exit
check_81:
.C:3bf1  C9 81       CMP #$81
.C:3bf3  D0 05       BNE default
.C:3bf5  A9 07       LDA #$07
.C:3bf7  4C FC 3B    JMP exit
default_80:
.C:3bfa  A9 06       LDA #$06
exit:
.C:3bfc  60          RTS
;===========================================
; Returns:	.A		#02	if an actor is found
;					#00 if not
;			.X		index of actor found
;===========================================
find_actor_enclosing_cursor:

;Use .X as actor index, start at #03, go downwards
.C:3bfd  A2 03       LDX #$03
check_actor_boundaries:
;Is the actor in use? If not, continue
.C:3bff  BD 53 FE    LDA costume_for_actor,X
.C:3c02  30 34       BMI next_actor
;-----------------------------------
;Check if the cursor's X coordinate falls within the actor's X range
.C:3c04  BD 41 FD    LDA position_x_for_actor,X
.C:3c07  CD 80 FE    CMP cursor_x_pixel_quarter_absolute
.C:3c0a  F0 02       BEQ check_right_edge
.C:3c0c  B0 2A       BCS next_actor
check_right_edge:
.C:3c0e  18          CLC
.C:3c0f  69 03       ADC #$03
.C:3c11  CD 80 FE    CMP cursor_x_pixel_quarter_absolute
.C:3c14  90 22       BCC next_actor
;-----------------------------------
;The X coordinate is in range, now check the Y coordinate
.C:3c16  BD 3D FD    LDA position_y_for_actor,X
.C:3c19  CD 7F FE    CMP cursor_y_pixel_half_off_by_8
.C:3c1c  90 1A       BCC next_actor
;Subtract one row
.C:3c1e  38          SEC
.C:3c1f  E9 28       SBC #$28		
;If: actor's Y position - height < 0, cap it to #01
.C:3c21  10 02       BPL compare_height
.C:3c23  A9 01       LDA #$01
;-----------------------------------
compare_height:
.C:3c25  CD 7F FE    CMP cursor_y_pixel_half_off_by_8
.C:3c28  F0 02       BEQ cursor_within_actor_box
.C:3c2a  B0 0C       BCS next_actor
;-----------------------------------
cursor_within_actor_box:
;The cursor is inside the actor's box
;Get character for actor
.C:3c2c  BD 53 FE    LDA costume_for_actor,X
;Is it the current kid?
;If so, continue with next actor
.C:3c2f  CD 67 FF    CMP current_kid
.C:3c32  F0 04       BEQ next_actor
;It's not the kid, so we found a different actor
;Set the character index in .X, return #02
.C:3c34  AA          TAX
.C:3c35  A9 02       LDA #$02
.C:3c37  60          RTS
;-----------------------------------
next_actor:
.C:3c38  CA          DEX
.C:3c39  10 C4       BPL check_actor_boundaries
;-----------------------------------
;Set character index to #00
.C:3c3b  A2 00       LDX #$00
.C:3c3d  60          RTS
;===========================================
; Get an object resource for the current cursor position
;
; If there's an object under the cursor, it will return the object resource
;
; Returns:		.X		#00	if there isn't an object under the cursor
;
;		If there's an object under the cursor:
; 				.A		object_index_hi
;				.X		object_index_lo
;===========================================
candidate_object = $3ea0
current_parent_possible = $15

get_object_enclosing_cursor:
;Are there any objects in this room? If not, exit now
.C:3c3e  AE 5C 71    LDX total_objects_in_room
.C:3c41  D0 01       BNE entry
.C:3c43  60          RTS
entry:
;Use .X as object room index, start at #01, go upwards
.C:3c44  A2 01       LDX #$01
boundary_check_loop:
;Is the object immutable?
.C:3c46  BD 21 72    LDA room_object_index_hi,X
.C:3c49  F0 03       BEQ obj_is_mutable
;If so, set it as a candidate
.C:3c4b  4C 58 3C    JMP set_object_as_candidate
obj_is_mutable:
;Object is mutable (or can be in a parent object) - we have to check if it's actually in the room right now
.C:3c4e  BC 3D 72    LDY room_object_index_lo,X
;Has the object been removed from the room? (Bit 5 set?)
.C:3c51  B9 01 73    LDA object_attributes,Y
.C:3c54  29 20       AND #$20
;If so, ignore it and continue
.C:3c56  D0 2F       BNE move_to_next_object
set_object_as_candidate:
.C:3c58  8E A0 3E    STX candidate_object
check_object_parent:
;Check if the object can have a parent object and, if so, if it's inside the parent object right now
.C:3c5b  BD 75 72    LDA parent_object_possible,X
.C:3c5e  85 15       STA current_parent_possible
.C:3c60  BD 59 72    LDA parent_object,X
.C:3c63  D0 03       BNE parent_object_possible
;Otherwise, skip straight to the boundary checks
.C:3c65  4C 81 3C    JMP check_boundary
parent_object_possible:
.C:3c68  A8          TAY
.C:3c69  B9 3D 72    LDA room_object_index_lo,Y
.C:3c6c  AA          TAX
;Check the object attributes and see if the object is in the parent obj
.C:3c6d  BD 01 73    LDA object_attributes,X
.C:3c70  29 80       AND #$80
.C:3c72  C5 15       CMP current_parent_possible
;If not, continue
.C:3c74  D0 05       BNE continue_from_candidate
;Otherwise, swap the object with its parent and repeat the boundary check
.C:3c76  98          TYA
.C:3c77  AA          TAX
.C:3c78  4C 5B 3C    JMP check_object_parent
continue_from_candidate:
.C:3c7b  AE A0 3E    LDX candidate_object
.C:3c7e  4C 87 3C    JMP move_to_next_object
check_boundary:
.C:3c81  AE A0 3E    LDX candidate_object
.C:3c84  4C E8 3C    JMP check_cursor_contained_within_object
move_to_next_object:
.C:3c87  E8          INX
.C:3c88  EC 5C 71    CPX total_objects_in_room
.C:3c8b  90 B9       BCC boundary_check_loop
.C:3c8d  F0 B7       BEQ boundary_check_loop
;No object found - return #00
.C:3c8f  A2 00       LDX #$00
.C:3c91  60          RTS
;===========================================
; Draw all the objects in a room
;
; If an object is not present (removed or in a parent object), it will skip it
;===========================================
candidate_object = $3ea0
current_parent_possible = $15
room_resource = $c3

draw_objects_in_room:
;Are there any objects in this room? If not, exit now
.C:3c92  AE 5C 71    LDX total_objects_in_room
.C:3c95  D0 01       BNE entry
.C:3c97  60          RTS
entry:
;Load the total objects for the room from the room resource (redundant code)
.C:3c98  AE 49 71    LDX current_room
.C:3c9b  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:3c9e  85 C3       STA <room_resource
.C:3ca0  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:3ca3  85 C4       STA >room_resource
.C:3ca5  AE 5C 71    LDX total_objects_in_room
decompress_object_gfx_loop:
;Is the object immutable? If so, it's already drawn in the room scene - skip it
.C:3ca8  BD 21 72    LDA room_object_index_hi,X
.C:3cab  D0 37       BNE next_object_decompress
;Check if the object is in a parent object - if so, skip it (it's a redundant check, as the same thing is checked below)
.C:3cad  BC 3D 72    LDY room_object_index_lo,X
.C:3cb0  B9 01 73    LDA object_attributes,Y
.C:3cb3  10 2F       BPL move_to_next_object
.C:3cb5  8E A0 3E    STX candidate_object
check_object_parent:
;Is there a parent object?
.C:3cb8  BD 75 72    LDA parent_object_possible,X
.C:3cbb  85 15       STA current_parent_possible
.C:3cbd  BD 59 72    LDA parent_object,X
.C:3cc0  D0 03       BNE parent_object_possible
;If not, go straight to decompress the object graphics
.C:3cc2  4C DE 3C    JMP decompress
parent_object_possible:
;There _might_ be a parent object - check if that's the current case
.C:3cc5  A8          TAY
.C:3cc6  B9 3D 72    LDA room_object_index_lo,Y
.C:3cc9  AA          TAX
;Check the object attributes and see if the object is in the parent obj
.C:3cca  BD 01 73    LDA object_attributes,X
.C:3ccd  29 80       AND #$80
.C:3ccf  C5 15       CMP current_parent_possible
;If it is, skip it
.C:3cd1  D0 05       BNE continue_from_candidate
;Otherwise, swap it with the parent and repeat the check
.C:3cd3  98          TYA
.C:3cd4  AA          TAX
.C:3cd5  4C B8 3C    JMP check_object_parent
continue_from_candidate:
.C:3cd8  AE A0 3E    LDX candidate_object
.C:3cdb  4C E4 3C    JMP move_to_next_object
decompress:
.C:3cde  AE A0 3E    LDX candidate_object
.C:3ce1  4C 27 3D    JMP draw_visible_part_of_object
move_to_next_object:
.C:3ce4  CA          DEX
.C:3ce5  D0 C1       BNE decompress_object_gfx_loop
.C:3ce7  60          RTS
;===========================================
; Check if the cursor is inside an object's boundaries
; 
; Returns:	if it's inside,		.A		object_index_hi
;								.X		object_index_lo
;			if it's not, it will jump back to move_to_next_object (in get_object_enclosing_cursor)
;===========================================
cursor_y = $15
cursor_x = $17
check_cursor_contained_within_object:
;Compute cursor Y
.C:3ce8  AD 7F FE    LDA cursor_y_pixel_half_off_by_8
.C:3ceb  4A          LSR A
.C:3cec  4A          LSR A
.C:3ced  85 15       STA cursor_y
;Compute cursor X
.C:3cef  AD 80 FE    LDA cursor_x_pixel_quarter_absolute
.C:3cf2  85 17       STA cursor_x
;-------------------------------------------
; Check if the cursor's X position is contained
; within the object's X coordinates (start/end)
;-------------------------------------------
;Check cursor X position vs. object X start
.C:3cf4  BD 5D 71    LDA object_x_start,X
.C:3cf7  C5 17       CMP cursor_x
;Are they equal? Check if there's width overlap
.C:3cf9  F0 02       BEQ check_cursor_contained_in_width
;Cursor X < Object X start? - if so, next object
.C:3cfb  B0 27       BCS next_obj
check_cursor_contained_in_width:
;Add object height to object's X start to compute object's X end
.C:3cfd  18          CLC
.C:3cfe  7D 95 71    ADC object_width,X
;Check cursor X position vs. object's X end
.C:3d01  C5 17       CMP cursor_x
;Cursor X > Object X end? - if so, next object
.C:3d03  90 1F       BCC next_obj
;Are they equal? Next object
.C:3d05  F0 1D       BEQ next_obj
;Cursor X is fully contained between the object's X start/end coordinates
;-------------------------------------------
; Check if the cursor's Y position is contained
; within the object's Y coordinates (start/end)
;-------------------------------------------
;Check cursor Y position vs. object Y start
.C:3d07  BD 79 71    LDA object_y_start,X
.C:3d0a  C5 15       CMP cursor_y
;Are they equal? Check if there's height overlap
.C:3d0c  F0 02       BEQ check_cursor_contained_in_height
;Cursor Y < Object Y start? - if so, next object
.C:3d0e  B0 14       BCS next_obj
check_cursor_contained_in_height:
;Add object height to object's Y start to compute object's Y end
.C:3d10  18          CLC
.C:3d11  7D B1 71    ADC object_height,X
;Check cursor Y position vs. object's Y end
.C:3d14  C5 15       CMP cursor_y
;Cursor Y > Object Y end? - if so, next object
.C:3d16  90 0C       BCC next_obj
;Are they equal? Next object
.C:3d18  F0 0A       BEQ next_obj
;-------------------------------------------
;Cursor is fully contained within the object's limits
.C:3d1a  BD 21 72    LDA room_object_index_hi,X
.C:3d1d  48          PHA
.C:3d1e  BD 3D 72    LDA room_object_index_lo,X
.C:3d21  AA          TAX
.C:3d22  68          PLA
.C:3d23  60          RTS
;-------------------------------------------
next_obj:
;The cursor coordinates are not contained within the object's limits
;So continue with the next object (jump back to get_object_enclosing_cursor)
.C:3d24  4C 87 3C    JMP move_to_next_object
;===========================================
; Draw the visible part of an object
;
; This routine will take into consideration the current scroll direction,
; if any, and calculate which columns of the object are visible.
; If there are no visible columns, it will exit.
; Otherwise, it will decompress the object's visible columns.
;
;===========================================
decomp_src_ptr = $27

draw_visible_part_of_object:
.C:3d27  A5 4E       LDA screen_scroll_flag
.C:3d29  D0 1E       BNE check_positive
;------------------------------------------
; Scroll right (#00)
;------------------------------------------
;Is the object X start <= room_scene_right_edge?
;If not, exit
.C:3d2b  BD 5D 71    LDA object_x_start,X
.C:3d2e  CD 65 06    CMP room_scene_right_edge
.C:3d31  F0 02       BEQ x_start_le_right_thr
.C:3d33  B0 11       BCS exit_2
x_start_le_right_thr:
;Add the width to get object X end in .A
.C:3d35  18          CLC
.C:3d36  7D 95 71    ADC object_width,X
;Is the object X end > room_scene_right_edge?
;If not, exit
.C:3d39  CD 65 06    CMP room_scene_right_edge
.C:3d3c  90 08       BCC exit_2
.C:3d3e  F0 06       BEQ exit_2
.C:3d40  20 87 3D    JSR decompress_object_gfx
.C:3d43  4C E4 3C    JMP next_object_decompress
exit_2:
.C:3d46  4C 84 3D    JMP exit
;------------------------------------------
check_positive:
.C:3d49  10 1E       BPL no_scroll
;------------------------------------------
; Scroll left (#FF)
;------------------------------------------
;Is the object X start <= room_scene_left_edge?
;If not, exit
.C:3d4b  BD 5D 71    LDA object_x_start,X
.C:3d4e  CD 64 06    CMP room_scene_left_edge
.C:3d51  F0 02       BEQ x_start_le_left_thr
.C:3d53  B0 11       BCS exit_3
x_start_le_left_thr:
;Add the width to get object X end in .A
.C:3d55  18          CLC
.C:3d56  7D 95 71    ADC object_width,X
;Is the object X end > room_scene_left_edge?
;If not, exit
.C:3d59  CD 64 06    CMP room_scene_left_edge
.C:3d5c  90 08       BCC exit_3
.C:3d5e  F0 06       BEQ exit_3
.C:3d60  20 87 3D    JSR decompress_object_gfx
.C:3d63  4C E4 3C    JMP next_object_decompress
exit_3:
.C:3d66  4C 84 3D    JMP exit
;------------------------------------------
; No scroll
;------------------------------------------
no_scroll:
;Is the object X start <= room_scene_right_edge?
;If not, exit
.C:3d69  BD 5D 71    LDA object_x_start,X
.C:3d6c  CD 65 06    CMP room_scene_right_edge
.C:3d6f  F0 02       BEQ x_start_le_right_thr_2
.C:3d71  B0 11       BCS exit
x_start_le_right_thr_2:
;Add the width to get object X end in .A
.C:3d73  18          CLC
.C:3d74  7D 95 71    ADC object_width,X
;Is the object X end > room_scene_right_edge?
;If not, exit
.C:3d77  CD 64 06    CMP room_scene_left_edge
.C:3d7a  90 08       BCC exit
.C:3d7c  F0 06       BEQ exit
.C:3d7e  20 87 3D    JSR decompress_object_gfx
.C:3d81  4C E4 3C    JMP next_object_decompress
exit:
.C:3d84  4C E4 3C    JMP next_object_decompress
;===========================================
; Decompress an object's graphic layers
;
; Arguments:	
;		room_resource	pointer to room resource
;		.X				object index in room
;		room_scene_left_edge
;		room_scene_right_edge
;		screen_scroll_flag
;===========================================
left_trim = $3e99
right_trim = $3e9a
total_columns = $3e9b
obj_left_edge = $3e9c
obj_top_row = $3e9d
obj_width = $3e9e
total_rows = $3e9f
decompress_candidate = $3ea0
destination_ptr = $19
screen_row_offset = $1b
room_resource = $c3

decompress_object_gfx:
;Load the necessary object dimensions
.C:3d87  BD 5D 71    LDA object_x_start,X
.C:3d8a  8D 9C 3E    STA obj_left_edge
.C:3d8d  BD 79 71    LDA object_y_start,X
.C:3d90  8D 9D 3E    STA obj_top_row
.C:3d93  BD 95 71    LDA object_width,X
.C:3d96  8D 9E 3E    STA obj_width
.C:3d99  BD B1 71    LDA object_height,X
.C:3d9c  8D 9F 3E    STA total_rows
;------------------------------------------
;Get the offset to the object's compressed graphic data
.C:3d9f  8A          TXA
.C:3da0  0A          ASL A
.C:3da1  A8          TAY
.C:3da2  18          CLC
.C:3da3  A5 C3       LDA <room_resource
.C:3da5  79 91 72    ADC compressed_object_data_offsets,Y
.C:3da8  85 27       STA <decomp_src_ptr
.C:3daa  A5 C4       LDA >room_resource
.C:3dac  79 92 72    ADC compressed_object_data_offsets+1,Y
.C:3daf  85 28       STA >decomp_src_ptr
;------------------------------------------
;Check how much to trim is needed on the left side by comparing 
; the left edge of the room's view with the left edge of the object
.C:3db1  AD 64 06    LDA room_scene_left_edge
.C:3db4  38          SEC
.C:3db5  ED 9C 3E    SBC obj_left_edge
;room_scene_left_edge >= obj_left_edge?
;If so, left_trim = room_scene_left_edge - obj_left_edge
.C:3db8  B0 02       BCS set_left_trim
;left edge < obj_left_edge - nothing to trim on the left side
;Set left trim to #00
.C:3dba  A9 00       LDA #$00
set_left_trim:
.C:3dbc  8D 99 3E    STA left_trim
;------------------------------------------
;Compute object's right edge in .A by doing: obj_left_edge + obj_width - 1
.C:3dbf  AD 9E 3E    LDA obj_width
.C:3dc2  38          SEC
.C:3dc3  E9 01       SBC #$01
.C:3dc5  18          CLC
.C:3dc6  6D 9C 3E    ADC obj_left_edge
;Check how much to trim on the right side by comparing 
; the right edge of the room's view with the right edge of the object
.C:3dc9  38          SEC
.C:3dca  ED 65 06    SBC room_scene_right_edge
;obj_right_edge >= room_scene_right_edge ?
;If so, right_trim = obj_right_edge - room_scene_right_edge
.C:3dcd  B0 02       BCS set_right_trim
;obj_right_edge < room_scene_right_edge - nothing to trim on the left side
;Set right trim to #00
.C:3dcf  A9 00       LDA #$00
set_right_trim:
.C:3dd1  8D 9A 3E    STA right_trim
;------------------------------------------
;Compute how many actual object columns we need to draw
; by subtracting left and right trim from the object's width
.C:3dd4  AD 9E 3E    LDA obj_width
.C:3dd7  38          SEC
.C:3dd8  ED 99 3E    SBC left_trim
.C:3ddb  38          SEC
.C:3ddc  ED 9A 3E    SBC right_trim
.C:3ddf  8D 9B 3E    STA total_columns
;------------------------------------------
.C:3de2  A5 4E       LDA screen_scroll_flag
.C:3de4  D0 15       BNE check_scroll_left
;------------------------------------------
; Screen scrolling right (#00)
;------------------------------------------
;left_trim = left_trim + total_columns - 1
.C:3de6  AD 9B 3E    LDA total_columns
.C:3de9  38          SEC
.C:3dea  E9 01       SBC #$01
.C:3dec  18          CLC
.C:3ded  6D 99 3E    ADC left_trim
.C:3df0  8D 99 3E    STA left_trim
;total_columns = 1
.C:3df3  A9 01       LDA #$01
.C:3df5  8D 9B 3E    STA total_columns
.C:3df8  4C 0F 3E    JMP trim_determined
;------------------------------------------
check_scroll_left:
.C:3dfb  10 12       BPL trim_determined
;------------------------------------------
; Screen scrolling left (#FF)
;------------------------------------------
;right_trim = right_trim + total_columns - 1
.C:3dfd  AD 9B 3E    LDA total_columns
.C:3e00  38          SEC
.C:3e01  E9 01       SBC #$01
.C:3e03  18          CLC
.C:3e04  6D 9A 3E    ADC right_trim
.C:3e07  8D 9A 3E    STA right_trim
;total_columns = 1
.C:3e0a  A9 01       LDA #$01
.C:3e0c  8D 9B 3E    STA total_columns
;------------------------------------------
trim_determined:
;Compute the screen row offset for the object's top row
.C:3e0f  AC 9D 3E    LDY obj_top_row
.C:3e12  B9 A1 3E    LDA screen_row_offsets_hi,Y
.C:3e15  85 1C       STA >screen_row_offset
.C:3e17  B9 BA 3E    LDA screen_row_offsets_lo,Y
.C:3e1a  85 1B       STA <screen_row_offset
;------------------------------------------
;Compute the starting column for the object
; by doing: obj_left_edge - room_scene_left_edge + left_trim
.C:3e1c  AD 9C 3E    LDA obj_left_edge
.C:3e1f  38          SEC
.C:3e20  ED 64 06    SBC room_scene_left_edge
.C:3e23  18          CLC
.C:3e24  6D 99 3E    ADC left_trim
;Add the starting column to the offset
.C:3e27  18          CLC
.C:3e28  65 1B       ADC <screen_row_offset
.C:3e2a  85 1B       STA <screen_row_offset
.C:3e2c  90 02       BCC decompress
.C:3e2e  E6 1C       INC >screen_row_offset
;-----------------------------------------
decompress:
;Add offset to frame_buffer_base
.C:3e30  20 04 01    JSR decomp_dict4_init
.C:3e33  18          CLC
.C:3e34  A5 1B       LDA <screen_row_offset
.C:3e36  65 24       ADC <frame_buffer_base
.C:3e38  85 19       STA <destination_ptr
.C:3e3a  A5 1C       LDA >screen_row_offset
.C:3e3c  65 25       ADC >frame_buffer_base
.C:3e3e  85 1A       STA >destination_ptr
.C:3e40  20 67 3E    JSR decompress_graphic_trimmed
;-----------------------------------------
;Add offset to base $6D89 (color layer)
.C:3e43  18          CLC
.C:3e44  A5 1B       LDA <screen_row_offset
.C:3e46  69 89       ADC #$89
.C:3e48  85 19       STA <destination_ptr
.C:3e4a  A5 1C       LDA >screen_row_offset
.C:3e4c  69 6D       ADC #$6D
.C:3e4e  85 1A       STA >destination_ptr
.C:3e50  20 67 3E    JSR decompress_graphic_trimmed
;-----------------------------------------
;Add offset to base $6AE1 (mask layer)
.C:3e53  18          CLC
.C:3e54  A5 1B       LDA <screen_row_offset
.C:3e56  69 E1       ADC #$E1
.C:3e58  85 19       STA <destination_ptr
.C:3e5a  A5 1C       LDA >screen_row_offset
.C:3e5c  69 6A       ADC #$6A
.C:3e5e  85 1A       STA >destination_ptr
.C:3e60  20 67 3E    JSR decompress_graphic_trimmed
;-----------------------------------------
;Restore object index into .X
.C:3e63  AE A0 3E    LDX decompress_candidate
.C:3e66  60          RTS
;===========================================
; Decompress trimmed graphic data
;
; Arguments:	
;		destination_ptr		pointer to destination
;		total_columns		total columns 
;		total_rows			total rows
;		left_trim			how many columns to trim on the left side
;		right_trim			how many columns to trim on the right side
;===========================================
row_counter = $15
destination_ptr = $19
decomp_skip_rem = $2e
left_trim = $3e99
right_trim = $3e9a
total_columns = $3e9b
total_rows = $3e9f

decompress_graphic_trimmed:
.C:3e67  AD 9F 3E    LDA total_rows
.C:3e6a  85 15       STA row_counter
;----------------------------------------
skip_left_trim:
;Skip the previous part as needed
.C:3e6c  AD 99 3E    LDA left_trim
.C:3e6f  85 2E       STA decomp_skip_rem
.C:3e71  20 8F 01    JSR decomp_skip_8
;----------------------------------------
;Decompress the desired part, using total_columns as size
.C:3e74  A0 00       LDY #$00
decompress_next:
.C:3e76  20 22 01    JSR decomp_stream_next
.C:3e79  91 19       STA (destination_ptr),Y
.C:3e7b  C8          INY
.C:3e7c  CC 9B 3E    CPY total_columns
.C:3e7f  D0 F5       BNE decompress_next
;----------------------------------------
;Add offset for next row (#28 = 40 columns)
.C:3e81  A5 19       LDA <destination_ptr
.C:3e83  18          CLC
.C:3e84  69 28       ADC #$28
.C:3e86  85 19       STA <destination_ptr
.C:3e88  90 02       BCC skip_right_trim
.C:3e8a  E6 1A       INC >destination_ptr
;----------------------------------------
skip_right_trim:
;Skip the post part as needed
.C:3e8c  AD 9A 3E    LDA right_trim
.C:3e8f  85 2E       STA decomp_skip_rem
.C:3e91  20 8F 01    JSR decomp_skip_8
;----------------------------------------
;Continue with next row
.C:3e94  C6 15       DEC row_counter
.C:3e96  D0 D4       BNE skip_left_trim
.C:3e98  60          RTS
;===========================================
;25 elements in total
;These are the offsets for each successive character row
;So row 0 has offset 0000, row 1 has 0028, and so on until row 25 with offset 03C0
screen_row_offsets_hi = $3ea

screen_row_offsets_hi:
3EA1:
00 00 00 00 00 00 00 
01 01 01 01 01 01 02
02 02 02 02 02 02 03
03 03 03 03 03

screen_row_offsets_lo = $3eba
screen_row_offsets_lo:
3EBA:
00 28 50 78 A0 C8 F0
18 40 68 90 B8 E0 08
30 58 80 A8 D0 F8 20
48 70 98 C0
;===========================================
; Assign sprites to actors
;
; This routine will assign sprites to actors, depending on their visibility.
;
; Invisible actors will get their sprites unassigned.
; Visible actors will get a sprite assigned.
; Any existing actor/sprite association will be updated accordingly.
;
; Sprite relative indexes will be assigned based on their costumes vertical positions.
; The costume higher on the screen (the one with the _lower_ Y coordinate)
; will have the lower sprite index assigned.
; The carnivore plant is a special case, and will always have the first sprite index.	
;===========================================
current_sprite = $19
unassigned_sprite_index = $17
sprite_in_use = $cb72	;#00 = not in use, #01 = in use
actor_index_for_sprite = $cb76
sprite_index_copy = $404c
sprites_in_use_count = $cb7a

assign_sprites_to_actors:
;Use .X as actor index
.C:3ed3  A2 00       LDX #$00
check_sprite_assigned_to_invisible_actor:
;Is the actor visible in scene? If so, skip it
.C:3ed5  BD 6F FD    LDA visibility_in_scene_for_actor,X
.C:3ed8  D0 42       BNE next_actor_1
;Is there a sprite assigned for this actor? If not, skip it
.C:3eda  BC 32 FC    LDY actor_sprite_index,X
.C:3edd  C0 FF       CPY #$FF
.C:3edf  F0 3B       BEQ next_actor_1
;----------------------------------------------------------------
;There's an actor that has a sprite assigned but it's not visible
;So we'll clear the sprite assigned in _both_ sprite buffers
;----------------------------------------------------------------
;Use .Y as the sprite index, .X as actor index
;Decrease the sprites in use count
.C:3ee1  CE 7A CB    DEC sprites_in_use_count
;Mark the sprite as no longer in use
.C:3ee4  A9 00       LDA #$00
.C:3ee6  99 72 CB    STA sprite_in_use,Y
;Set the actor's sprite base address
.C:3ee9  8C 4C 40    STY sprite_index_copy
.C:3eec  20 56 24    JSR set_actor_sprite_base_address
;Clear sprite data
.C:3eef  AC 4C 40    LDY sprite_index_copy
.C:3ef2  20 EC 22    JSR clear_sprite_visible_rows
;Copy a vertical slice of the sprite data (the top third)
.C:3ef5  20 A8 23    JSR copy_vertical_third_of_sprite_data
;Toggle sprite buffer and repeat the clearing logic
.C:3ef8  A9 01       LDA #$01
.C:3efa  4D 14 FD    EOR sprite_buffer
.C:3efd  8D 14 FD    STA sprite_buffer
.C:3f00  AC 4C 40    LDY sprite_index_copy
.C:3f03  20 56 24    JSR set_actor_sprite_base_address
.C:3f06  AC 4C 40    LDY sprite_index_copy
.C:3f09  20 EC 22    JSR clear_sprite_visible_rows
.C:3f0c  20 A8 23    JSR copy_vertical_third_of_sprite_data
;Toggle sprite buffer again to revert to the original one
.C:3f0f  A9 01       LDA #$01
.C:3f11  4D 14 FD    EOR sprite_buffer
.C:3f14  8D 14 FD    STA sprite_buffer
;Unassign sprite for this actor
.C:3f17  A9 FF       LDA #$FF
.C:3f19  9D 32 FC    STA actor_sprite_index,X
next_actor_1:
;Move to next actor
.C:3f1c  E8          INX
;Any actors remaining? If not, continue
.C:3f1d  E0 04       CPX #$04
.C:3f1f  D0 B4       BNE check_sprite_assigned_to_invisible_actor
;----------------------------------------------------------------
;Use .X as actor index
.C:3f21  A2 00       LDX #$00
assign_sprite_to_visible_actor:
;Is the actor visible in scene? If not, skip it
.C:3f23  BD 6F FD    LDA visibility_in_scene_for_actor,X
.C:3f26  F0 44       BEQ next_actor_2
;Is there a sprite assigned for this actor? If so, refresh the sprite-actor association
.C:3f28  BD 32 FC    LDA actor_sprite_index,X
.C:3f2b  C9 FF       CMP #$FF
.C:3f2d  D0 36       BNE refresh_actor_sprite_index
;There's a visible actor with a sprite assigned
;Validate that the count of sprites in use is <= 4
.C:3f2f  AC 7A CB    LDY sprites_in_use_count
.C:3f32  C0 04       CPY #$04
.C:3f34  90 0E       BCC assign_available_sprite
;----------------------------------------------------------------
;We ran out of sprites to use - hang execution
;----------------------------------------------------------------
.C:3f36  A9 0B       LDA #$0B
.C:3f38  85 DC       STA $DC
;map_in_io
.C:3f3a  A0 25       LDY #$25
.C:3f3c  84 01       STY processor_port_register
infinite_loop:
.C:3f3e  8D 20 D0    STA vic_border_color_register
.C:3f41  4C 3E 3F    JMP infinite_loop
;----------------------------------------------------------------
; There's a visible actor without a sprite assigned - assign an available sprite
;----------------------------------------------------------------
assign_available_sprite:
;Use .Y as sprite index (keep using .X as actor index)
.C:3f44  A0 00       LDY #$00
check_if_sprite_is_available:
;If sprite is in use, skip to the next sprite
.C:3f46  B9 72 CB    LDA sprite_in_use,Y
.C:3f49  D0 12       BNE next_sprite
;Sprite is available, set sprite as in use
.C:3f4b  A9 01       LDA #$01
.C:3f4d  99 72 CB    STA sprite_in_use,Y
;Set the actor's sprite index
.C:3f50  98          TYA
.C:3f51  9D 32 FC    STA actor_sprite_index,X
;Set the actor's index for the sprite
.C:3f54  8A          TXA
.C:3f55  99 76 CB    STA actor_index_for_sprite,Y
;Increment the sprites in use count
.C:3f58  EE 7A CB    INC sprites_in_use_count
;We found an available sprite, so set .Y to #03 to break the loop
.C:3f5b  A0 03       LDY #$03
next_sprite:
;Move to next sprite
.C:3f5d  C8          INY
;Any sprites remaining? If not, continue checking
.C:3f5e  C0 04       CPY #$04
.C:3f60  D0 E4       BNE check_if_sprite_is_available
.C:3f62  4C 6C 3F    JMP next_actor_2
;----------------------------------------------------------------
; There's a visible actor with a sprite assigned - refresh the sprite/actor association
;----------------------------------------------------------------
refresh_actor_sprite_index:
;We found a visible actor with an already assigned sprite
;Load the sprite index for this actor into .Y
.C:3f65  BC 32 FC    LDY actor_sprite_index,X
;Copy the actor index into .A
.C:3f68  8A          TXA
;Set the actor index for this sprite
.C:3f69  99 76 CB    STA actor_index_for_sprite,Y
;----------------------------------------------------------------
next_actor_2:
;Move to next actor
.C:3f6c  E8          INX
;Any actors remaining? If not, continue
.C:3f6d  E0 04       CPX #$04
.C:3f6f  D0 B2       BNE assign_sprite_to_visible_actor
;----------------------------------------------------------------
; Clear unused sprite associations
;----------------------------------------------------------------
;Copy the sprites in use counter 
.C:3f71  AD 7A CB    LDA sprites_in_use_count
.C:3f74  85 19       STA current_sprite
;Use .Y as sprite index
.C:3f76  A0 00       LDY #$00
.C:3f78  A9 FF       LDA #$FF
clear_sprite_assignment:
;Is the sprite in use? If so, skip it
.C:3f7a  BE 72 CB    LDX sprite_in_use,Y
.C:3f7d  D0 06       BNE next_sprite_2
;Otherwise, clear actor assignment for this sprite (set to #FF)
.C:3f7f  99 76 CB    STA actor_index_for_sprite,Y
;And clear the relative sprite index
.C:3f82  99 78 FD    STA relative_sprite_index,Y
next_sprite_2:
;Move to next sprite
.C:3f85  C8          INY
;Any sprites remaining? If not, continue checking
.C:3f86  C0 04       CPY #$04
.C:3f88  D0 F0       BNE clear_sprite_assignment
;----------------------------------------------------------------
; For each sprite in use, find the highest actor position
;----------------------------------------------------------------
candidate_sprite = $1d
candidate_actor = $1e
candidate_position_y = $1b

;Move to the next sprite index
.C:3f8a  C6 19       DEC current_sprite
;Have we exhausted the sprites in use? If so, break
.C:3f8c  A5 19       LDA current_sprite
.C:3f8e  10 03       BPL find_highest_actor_position
.C:3f90  4C D6 3F    JMP assign_relative_sprites_to_actors
find_highest_actor_position:
;Use .X as sprite index
.C:3f93  A2 00       LDX #$00
;Initialize candidate vertical position to #FF
.C:3f95  A9 FF       LDA #$FF
.C:3f97  85 1B       STA candidate_position_y
check_actor_against_candidate:
;Is there an actor assigned for this sprite? If not, skip to the next actor
.C:3f99  BD 76 CB    LDA actor_index_for_sprite,X
.C:3f9c  C9 FF       CMP #$FF
.C:3f9e  F0 1C       BEQ next_actor_3
;There's an actor assigned - get the costume for this actor
.C:3fa0  A8          TAY
.C:3fa1  B9 53 FE    LDA costume_for_actor,Y
;Is it the plant?
.C:3fa4  C9 13       CMP #$13
.C:3fa6  F0 06       BEQ actor_is_plant
;It's not the plant, get its vertical position
.C:3fa8  B9 3D FD    LDA position_y_for_actor,Y
.C:3fab  4C B0 3F    JMP compare_position_y
actor_is_plant:
;The actor is the plant, use #00 as its vertical position
.C:3fae  A9 00       LDA #$00
compare_position_y:
;Is the current actor's position <= candidate_position_y? If not, continue with the next actor
.C:3fb0  C5 1B       CMP candidate_position_y
.C:3fb2  F0 02       BEQ actor_y_le_candidate
.C:3fb4  B0 06       BCS next_actor_3
actor_y_le_candidate:
;current actor's position <= candidate_position_y
;Save the position, sprite and actor indexes as new candidates
.C:3fb6  85 1B       STA candidate_position_y
.C:3fb8  86 1D       STX candidate_sprite
.C:3fba  84 1E       STY candidate_actor
next_actor_3:
;Move to next actor
.C:3fbc  E8          INX
.C:3fbd  E0 04       CPX #$04
.C:3fbf  D0 D8       BNE check_actor_against_candidate
;----------------------------------------------------------------
; We compared the actor's Y positions against each other
; and selected the higher one in Y position (lower in value) as the candidate actor, sprite and position
;----------------------------------------------------------------
;Clear the actor assignment for the candidate sprite
.C:3fc1  A6 1D       LDX candidate_sprite
.C:3fc3  A9 FF       LDA #$FF
.C:3fc5  9D 76 CB    STA actor_index_for_sprite,X
;Get the sprite index for the candidate actor
.C:3fc8  A6 1E       LDX candidate_actor
.C:3fca  BC 32 FC    LDY actor_sprite_index,X
;Copy the current sprite as sprite for the relative index
.C:3fcd  A5 19       LDA current_sprite
.C:3fcf  99 78 FD    STA relative_sprite_index,Y
;Move to the next sprite and iterate again if there are still sprites pending
.C:3fd2  C6 19       DEC current_sprite
.C:3fd4  10 BD       BPL find_highest_actor_position
;----------------------------------------------------------------
; Finally, assign relative sprite indexes for all actors
;----------------------------------------------------------------
assign_relative_sprites_to_actors:
;Use .X as sprite index
.C:3fd6  A2 00       LDX #$00
;Set the first unassigned sprite index
.C:3fd8  AD 7A CB    LDA sprites_in_use_count
.C:3fdb  85 17       STA unassigned_sprite_index
assign_relative_sprite:
;Is there a relative sprite index assigned?
.C:3fdd  BD 78 FD    LDA relative_sprite_index,X
.C:3fe0  C9 FF       CMP #$FF
.C:3fe2  D0 0A       BNE relative_index_already_set
;There isn't - set the current unassigned sprite index as the relative sprite for this actor
.C:3fe4  A5 17       LDA unassigned_sprite_index
.C:3fe6  9D 7C FD    STA relative_sprite_for_actor,X
;Increment the unassigned sprite index
.C:3fe9  E6 17       INC unassigned_sprite_index
.C:3feb  4C F1 3F    JMP next_sprite_3
relative_index_already_set:
;There's a relative sprite index assigned - set it for the actor
.C:3fee  9D 7C FD    STA relative_sprite_for_actor,X
next_sprite_3:
;Move to the next sprite
.C:3ff1  E8          INX
;Are there sprites pending? If so, continue
.C:3ff2  E0 04       CPX #$04
.C:3ff4  D0 E7       BNE assign_relative_sprite
.C:3ff6  60          RTS
;===========================================
; Determines if an actor is visible in the room scene
;
; Arguments:	active_costume
; Returns:	visibility_in_scene_for_actor	#00 if not visible, #01 if visible
;===========================================
update_actor_visibility_in_scene:
;Is there an assigned actor for the active costume?
.C:3ff7  AE 30 FC    LDX active_costume
.C:3ffa  BD 57 FE    LDA actor_for_costume,X
.C:3ffd  10 05       BPL check_actor_position
;If not, the actor is not visible - return #00
.C:3fff  A9 00       LDA #$00
.C:4001  4C 48 40    JMP set_visibility
;---------------------------------------------
check_actor_position:
;Check the actor's position vs. the room's visible left edge by doing a subtraction
.C:4004  A6 D8       LDX actor
.C:4006  BD 41 FD    LDA position_x_for_actor,X
.C:4009  38          SEC
.C:400a  ED 64 06    SBC room_scene_left_edge
;Subtraction < #FE? If not, check if it's fully to the left
.C:400d  C9 FE       CMP #$FE
.C:400f  90 10       BCC check_fully_to_the_left
;Carry set - so subtraction == FF exactly
;This means that the actor is just one column to the left of the left edge
;In other words, it's partially visible?
;Check the previous visibility for this actor
.C:4011  BD 6F FD    LDA visibility_in_scene_for_actor,X
.C:4014  D0 0B       BNE check_fully_to_the_left
;---------------------------------------------
;Set animation counter to #03
.C:4016  A9 03       LDA #$03
.C:4018  9D 93 FD    STA animation_counter_for_actor,X
;Set the actor as visible
.C:401b  A9 01       LDA #$01
.C:401d  9D 6F FD    STA visibility_in_scene_for_actor,X
.C:4020  60          RTS
;---------------------------------------------
check_fully_to_the_left:
;Subtraction < #00? - If so, and as we have already covered the special case of #FF, 
; the actor is completely to the left of the room's left edge
;So it's not visible at all
.C:4021  C9 00       CMP #$00
.C:4023  90 21       BCC return_not_visible
;Compare the subtraction vs. #27, which is the room scene's visible width
;If it's exactly #27, the actor is in range
.C:4025  C9 27       CMP #$27
.C:4027  F0 02       BEQ actor_in_range
check_fully_to_the_right:
;Subtraction >= #27? If so, the actor is fully to the right of the right edge and, so, not visible
.C:4029  B0 16       BCS return_not_visible_2
actor_in_range:
;If we came after the previous BCS instruction, the actor is in the visible range - the BNE will be taken and will be set to visible
.C:402b  D0 0F       BNE return_visible
;If we came from CMP #27 + BEQ, the BNE won't be taken, the actor is partially visible as it's on the right edge
;Check the previous visibility for this actor
.C:402d  BD 6F FD    LDA visibility_in_scene_for_actor,X
;If it was visible, keep it as it is
.C:4030  D0 07       BNE set_visibility_2
;It wasn't visible, so make it visible and reset the animation counter
.C:4032  A9 03       LDA #$03
.C:4034  9D 93 FD    STA animation_counter_for_actor,X
;Set it as visible
.C:4037  A9 01       LDA #$01
set_visibility_2:
.C:4039  4C 48 40    JMP set_visibility
return_visible:
.C:403c  A9 01       LDA #$01
.C:403e  4C 48 40    JMP set_visibility
return_not_visible_2:
.C:4041  A9 00       LDA #$00
.C:4043  4C 48 40    JMP set_visibility
return_not_visible:
.C:4046  A9 00       LDA #$00
set_visibility:
.C:4048  9D 6F FD    STA visibility_in_scene_for_actor,X
.C:404b  60          RTS
;===========================================
; Draw a room scene
;
; Arguments:		current_room
;
; This routine will render the whole visible area of a room scene.
; If needed, the routine will perform scroll (by one column only).
; The update will also include the mask layer, which is not visible.
;===========================================
tile_matrix_ptr = $17
color_layer_ptr = $19
mask_layer_ptr = $1b

draw_room_scene:
.C:404d  AE 49 71    LDX current_room
;Does the current room resource pointer match the one for "current_room"?
;If yes, continue
.C:4050  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:4053  CD 5A 71    CMP <current_room_rsrc
.C:4056  D0 1B       BNE room_scene_data_not_in_memory
.C:4058  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:405b  CD 5B 71    CMP >current_room_rsrc
.C:405e  D0 13       BNE room_scene_data_not_in_memory
;Does the current room layers resource pointer match the one for "current_room?"?
;If yes, continue checking if there's scroll
.C:4060  AD 79 7B    LDA room_layers_rsrc_lo
.C:4063  CD 98 FE    CMP <current_room_layers_rsrc
.C:4066  D0 0B       BNE room_scene_data_not_in_memory
.C:4068  AD 77 7B    LDA room_layers_rsrc_hi
.C:406b  CD 99 FE    CMP >current_room_layers_rsrc
.C:406e  D0 03       BNE room_scene_data_not_in_memory
.C:4070  4C 82 40    JMP check_scroll_right
;---------------------------------------------
;Otherwise, setup the room scene
room_scene_data_not_in_memory:
.C:4073  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:4076  8D 5A 71    STA <current_room_rsrc
.C:4079  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:407c  8D 5B 71    STA >current_room_rsrc
.C:407f  20 12 43    JSR setup_room_scene_rsrc
;---------------------------------------------
check_scroll_right:
;Is the camera's target position = actual position + 1?
;Or, equivalently, target - 1 = actual?
;If not, continue
.C:4082  AE 66 06    LDX camera_desired_position
.C:4085  CA          DEX
.C:4086  EC 67 06    CPX camera_current_position
.C:4089  D0 37       BNE check_scroll_left
;---------------------------------------------
; Scroll right needed
;---------------------------------------------
;Set scroll flag to "scroll right" (#00)
.C:408b  A9 00       LDA #$00
.C:408d  85 4E       STA screen_scroll_flag
.C:408f  20 5E 42    JSR scroll_scene_right
;------------------------------
;Set tile_matrix_ptr = frame_buffer_base + #27 (the last column)
.C:4092  18          CLC
.C:4093  A5 24       LDA <frame_buffer_base
.C:4095  69 27       ADC #$27
.C:4097  85 17       STA <tile_matrix_ptr
.C:4099  A5 25       LDA >frame_buffer_base
.C:409b  69 00       ADC #$00
.C:409d  85 18       STA >tile_matrix_ptr
;------------------------------
;Set color_layer_ptr = last column of color layer
.C:409f  18          CLC
.C:40a0  A9 89       LDA #$89
.C:40a2  69 27       ADC #$27
.C:40a4  85 19       STA <color_layer_ptr
.C:40a6  A9 6D       LDA #$6D
.C:40a8  69 00       ADC #$00
.C:40aa  85 1A       STA >color_layer_ptr
;------------------------------
;Set mask_layer_ptr = last column of mask layer
.C:40ac  18          CLC
.C:40ad  A9 E1       LDA #$E1
.C:40af  69 27       ADC #$27
.C:40b1  85 1B       STA <mask_layer_ptr
.C:40b3  A9 6A       LDA #$6A
.C:40b5  69 00       ADC #$00
.C:40b7  85 1C       STA >mask_layer_ptr
;------------------------------
.C:40b9  AD 64 06    LDA room_scene_left_edge
.C:40bc  18          CLC
.C:40bd  69 27       ADC #$27
.C:40bf  4C 18 41    JMP decompress_visible_columns
;---------------------------------------------
check_scroll_left:
;Is the camera's target position = actual position - 1?
;Or, equivalently, target + 1 = actual?
;If not, continue
.C:40c2  AE 66 06    LDX camera_desired_position
.C:40c5  E8          INX
.C:40c6  EC 67 06    CPX camera_current_position
.C:40c9  D0 29       BNE no_scroll
;---------------------------------------------
; Scroll left needed
;---------------------------------------------
;Set scroll flag to "scroll left" (#FF)
.C:40cb  A9 FF       LDA #$FF
.C:40cd  85 4E       STA screen_scroll_flag
.C:40cf  A9 00       LDA #$00
.C:40d1  85 4F       STA $4F
.C:40d3  20 FE 41    JSR scroll_scene_left
;------------------------------
;Set tile_matrix_ptr = frame_buffer_base
.C:40d6  A5 24       LDA <frame_buffer_base
.C:40d8  85 17       STA <tile_matrix_ptr
.C:40da  A5 25       LDA >frame_buffer_base
.C:40dc  85 18       STA >tile_matrix_ptr
;------------------------------
;Set color_layer_ptr = start of color layer
.C:40de  A9 89       LDA #$89
.C:40e0  85 19       STA <color_layer_ptr
.C:40e2  A9 6D       LDA #$6D
.C:40e4  85 1A       STA >color_layer_ptr
;------------------------------
;Set mask_layer_ptr = start of mask layer
.C:40e6  A9 E1       LDA #$E1
.C:40e8  85 1B       STA <mask_layer_ptr
.C:40ea  A9 6A       LDA #$6A
.C:40ec  85 1C       STA >mask_layer_ptr
;------------------------------
.C:40ee  AD 64 06    LDA room_scene_left_edge
.C:40f1  4C 18 41    JMP decompress_visible_columns
;---------------------------------------------
; No scroll 
; 
; This happens only when we enter a room.
; In this scenario, we have to decompress the whole visible room.
;---------------------------------------------
no_scroll:
;Set scroll flag to "room scene render new" (#01)
.C:40f4  A9 01       LDA #$01
.C:40f6  85 4E       STA screen_scroll_flag
;Set region decompression to whole room (#01)
.C:40f8  A9 01       LDA DECOMPRESS_WHOLE_ROOM
.C:40fa  8D FD 41    STA decompression_region_mode
;------------------------------
;Set tile_matrix_ptr = frame_buffer_base
.C:40fd  A5 24       LDA <frame_buffer_base
.C:40ff  85 17       STA <tile_matrix_ptr
.C:4101  A5 25       LDA >frame_buffer_base
.C:4103  85 18       STA >tile_matrix_ptr
;------------------------------
;Set color_layer_ptr = start of color layer
.C:4105  A9 89       LDA #$89
.C:4107  85 19       STA <color_layer_ptr
.C:4109  A9 6D       LDA #$6D
.C:410b  85 1A       STA >color_layer_ptr
;------------------------------
;Set mask_layer_ptr = start of mask layer
.C:410d  A9 E1       LDA #$E1
.C:410f  85 1B       STA <mask_layer_ptr
.C:4111  A9 6A       LDA #$6A
.C:4113  85 1C       STA >mask_layer_ptr
.C:4115  AD 64 06    LDA room_scene_left_edge
;------------------------------
decompressed_data_ptr = $15
decomp_src_ptr = $27
value_to_repeat = $2b
inlined_run_length_dict_base = $419f

decompress_visible_columns:
;Use .Y as the column index (start at the left edge)
.C:4118  A8          TAY
;---------------------------------------------
; Decompress video matrix data
;---------------------------------------------
;Set tile_matrix_ptr as decompression destination
.C:4119  A5 17       LDA <tile_matrix_ptr
.C:411b  85 15       STA <decompressed_data_ptr
.C:411d  A5 18       LDA >tile_matrix_ptr
.C:411f  85 16       STA >decompressed_data_ptr
;Setup symbol dictionary for room_tile_matrix_offset
.C:4121  A9 4A       LDA #<symbol_dictionary_for_tile_matrix
.C:4123  8D 9F 41    STA <inlined_run_length_dict_base
.C:4126  A9 71       LDA #>symbol_dictionary_for_tile_matrix
.C:4128  8D A0 41    STA >inlined_run_length_dict_base
;Load the decompression input pointer for this column
.C:412b  B1 64       LDA (tile_matrix_compressed_lo),Y
.C:412d  85 27       STA <decomp_src_ptr
.C:412f  B1 66       LDA (tile_matrix_compressed_hi),Y
.C:4131  85 28       STA >decomp_src_ptr
;Load the symbol to repeat for this column
.C:4133  B1 6A       LDA (tile_matrix_value_to_repeat),Y
.C:4135  85 2B       STA value_to_repeat
;Load the mode_counter for this column
.C:4137  B1 68       LDA (tile_matrix_mode_counter),Y
.C:4139  20 8B 41    JSR decompress_room_gfx
;---------------------------------------------
; Decompress color layer data
;---------------------------------------------
;Set color_layer_ptr as decompression destination
.C:413c  A5 19       LDA <color_layer_ptr
.C:413e  85 15       STA <decompressed_data_ptr
.C:4140  A5 1A       LDA >color_layer_ptr
.C:4142  85 16       STA >decompressed_data_ptr
;Setup symbol dictionary for room_color_layer_offset
.C:4144  A9 4E       LDA #<symbol_dictionary_for_color_layer
.C:4146  8D 9F 41    STA <inlined_run_length_dict_base
.C:4149  A9 71       LDA #>symbol_dictionary_for_color_layer
.C:414b  8D A0 41    STA >inlined_run_length_dict_base
;Load the decompression input pointer for this column
.C:414e  B1 6C       LDA (color_layer_compressed_lo),Y
.C:4150  85 27       STA <decomp_src_ptr
.C:4152  B1 6E       LDA (color_layer_compressed_hi),Y
.C:4154  85 28       STA >decomp_src_ptr
;Load the symbol to repeat for this column
.C:4156  B1 72       LDA (color_layer_value_to_repeat),Y
.C:4158  85 2B       STA value_to_repeat
;Load the mode_counter for this column
.C:415a  B1 70       LDA (color_layer_mode_counter),Y
.C:415c  20 8B 41    JSR decompress_room_gfx
;---------------------------------------------
; Decompress mask layer data
;---------------------------------------------
;Set mask_layer_ptr as decompression destination
.C:415f  A5 1B       LDA <mask_layer_ptr
.C:4161  85 15       STA <decompressed_data_ptr
.C:4163  A5 1C       LDA >mask_layer_ptr
.C:4165  85 16       STA >decompressed_data_ptr
;Setup symbol dictionary for room_mask_layer_offset
.C:4167  A9 52       LDA #<symbol_dictionary_for_mask_layer
.C:4169  8D 9F 41    STA <inlined_run_length_dict_base
.C:416c  A9 71       LDA #>symbol_dictionary_for_mask_layer
.C:416e  8D A0 41    STA >inlined_run_length_dict_base
;Load the decompression input pointer for this column
.C:4171  B1 74       LDA (mask_layer_compressed_lo),Y
.C:4173  85 27       STA <decomp_src_ptr
.C:4175  B1 76       LDA (mask_layer_compressed_hi),Y
.C:4177  85 28       STA >decomp_src_ptr
;Load the symbol to repeat for this column
.C:4179  B1 7A       LDA (mask_layer_value_to_repeat),Y
.C:417b  85 2B       STA value_to_repeat
;Load the mode_counter for this column
.C:417d  B1 78       LDA (mask_layer_mode_counter),Y
.C:417f  20 8B 41    JSR decompress_room_gfx
;---------------------------------------------
;Set decompression region mode to one column (#00) from now on
; as in the future, if we scroll, we only need to decompress a single column
.C:4182  A9 00       LDA DECOMPRESS_ONE_COL
.C:4184  8D FD 41    STA decompression_region_mode
;Draw all visible objects
.C:4187  20 92 3C    JSR draw_objects_in_room
.C:418a  60          RTS
;===========================================
; Decompress room graphics
;
; Arguments:	
;	.A		operation mode
;			Bit 7 set - run-length-mode
;				Bits 6-0 are the repetition counter
;				The value to be repeated has to be previously setup by the caller.
;
;			Bit 7 clear - direct mode
;				Byte value is the direct mode counter
;
;	decompression_region_mode
;				#00		decompress one column
;				#01		decompress the whole visible room (#28 columns)
;===========================================
decomp_emit_mode = $29
decomp_emit_rem = $2a
DIRECT_MODE = #$00
RUN_MODE = #$FF
DECOMPRESS_ONE_COL = #$00
DECOMPRESS_WHOLE_ROOM = #$01

decompress_room_gfx:
;Set initial mode and parameters
.C:418b  10 09       BPL direct_mode
;------------------------------------------------
;Bit 7 set - run-length mode, bits 6-0 are the repeat counter
;------------------------------------------------
.C:418d  29 7F       AND #$7F
.C:418f  85 2A       STA decomp_emit_rem
.C:4191  A9 FF       LDA RUN_MODE
.C:4193  4C 9A 41    JMP set_initial_repeat_mode
;------------------------------------------------
;Bit 7 clear - direct mode, byte in .A is the repeat counter
;------------------------------------------------
direct_mode:
.C:4196  85 2A       STA decomp_emit_rem
.C:4198  A9 00       LDA DIRECT_MODE
;------------------------------------------------
set_initial_repeat_mode:
.C:419a  85 29       STA decomp_emit_mode
;Setup symbol dictionary
.C:419c  A2 03       LDX #$03
dict_setup_loop:
inlined_run_length_dict_base = $419f
.C:419e  BD FF FF    LDA $FFFF,X	;Inlined
.C:41a1  9D 00 01    STA decomp_dict4,X
.C:41a4  CA          DEX
.C:41a5  10 F7       BPL dict_setup_loop
;------------------------------------------------
;Decompress according to mode
.C:41a7  AD FD 41    LDA decompression_region_mode
.C:41aa  F0 03       BEQ decompress_room_gfx_column
.C:41ac  4C D4 41    JMP decompress_room_gfx_full
;===========================================
; Decompress a room's graphic column
;
; Each byte in a column is separated out #28 bytes from its successor,
; as there are exactly #28 visible columns in a row.
; There's a total of #10 bytes in a column.
;
; Arguments:
;		dest_ptr		Pointer to destination
;===========================================
dest_ptr = $15
decompressed_data_counter = $61
temp_x = $41f9
temp_y = $41fb
ROW_LENGTH = #$28

decompress_room_gfx_column:
.C:41af  8E F9 41    STX temp_x
.C:41b2  8C FB 41    STY temp_y
;Decompress exactly #10 vertical elements of a column
.C:41b5  A9 10       LDA #$10
.C:41b7  85 61       STA decompressed_data_counter
;Use .Y as destination index
.C:41b9  A0 00       LDY #$00
;--------------------------------------------------
next_byte:
;Decompress a byte and store it in the destination
.C:41bb  20 22 01    JSR decomp_stream_next
.C:41be  91 15       STA (dest_ptr),Y
;Point to the next element downwards in the column
;That is, add row length to index
.C:41c0  98          TYA
.C:41c1  18          CLC
.C:41c2  69 28       ADC ROW_LENGTH
.C:41c4  A8          TAY
;If the addition caused a carry, increase >dest_ptr to keep things in accord
.C:41c5  90 02       BCC counter_update
.C:41c7  E6 16       INC >dest_ptr
counter_update:
.C:41c9  C6 61       DEC decompressed_data_counter
.C:41cb  10 EE       BPL next_byte
;--------------------------------------------------
.C:41cd  AE F9 41    LDX temp_x
.C:41d0  AC FB 41    LDY temp_y
.C:41d3  60          RTS
;===========================================
; Decompress a full room's visible scene (#28 columns)
;
; This will simply decompress all visible columns 
; using decompress_room_gfx_column.
; 
;===========================================
dest_ptr = $15
column_ptr = $17
temp_y = $41fc

decompress_room_gfx_full:
.C:41d4  8C FC 41    STY temp_y
;Save the initial dest_ptr as the first column_ptr
.C:41d7  A5 15       LDA <dest_ptr
.C:41d9  85 17       STA <column_ptr
.C:41db  A5 16       LDA >dest_ptr
.C:41dd  85 18       STA >column_ptr
;Do the column decompression a total of #28 times (#27-#00)
.C:41df  A0 27       LDY #$27
decompress_column:
.C:41e1  20 AF 41    JSR decompress_room_gfx_column
;Move column pointer to the next position (do a 16-bit addition of #01)
;This will be the next column to the right
.C:41e4  E6 17       INC <column_ptr
.C:41e6  D0 02       BNE set_next_column
.C:41e8  E6 18       INC >column_ptr
set_next_column:
;Set the new column pointer as the new destination pointer
.C:41ea  A5 17       LDA <column_ptr
.C:41ec  85 15       STA <dest_ptr
.C:41ee  A5 18       LDA >column_ptr
.C:41f0  85 16       STA >dest_ptr
;Check if there are columns pending, repeat
.C:41f2  88          DEY
.C:41f3  10 EC       BPL decompress_column
.C:41f5  AC FC 41    LDY temp_y
.C:41f8  60          RTS
;===========================================
; Scroll room scene left (one column)
;
; Arguments:	frame_buffer	the current frame_buffer index
;
; This routine will copy the whole room scene graphics
; data one column to the left.
;
; It will use the current frame buffer as destionation, 
; and the alternate frame buffer as source,
; to avoid any display artifacts while doing the copy.
;
; In the special case in which the environment lights are off
; and the flashlight is on, the source and destination frame buffers
; are the same.
;
; It will copy video matrix data, color data and
; the mask layer data to keep everything in sync.
;
;===========================================
source = $17
dest = $19

scroll_scene_left:
;Which frame buffer are we using?
.C:41fe  A5 23       LDA frame_buffer
.C:4200  C9 01       CMP #$01
.C:4202  D0 0B       BNE frame_buffer_2
;-------------------------------
;Frame buffer #1 (CC28 base address) - use the other frame buffer (C828) as source address
frame_buffer_1:
.C:4204  A9 28       LDA #$28
.C:4206  85 17       STA <source
.C:4208  A9 C8       LDA #$C8
.C:420a  85 18       STA >source
.C:420c  4C 17 42    JMP frame_buffer_set
;-------------------------------
;Frame buffer #2 (C828 base address) - use the other frame buffer (CC28) as source address
frame_buffer_2:
.C:420f  A9 28       LDA #$28
.C:4211  85 17       STA <source
.C:4213  A9 CC       LDA #$CC
.C:4215  85 18       STA >source
;-------------------------------
frame_buffer_set:
;Set the current frame buffer as destination
.C:4217  A5 24       LDA <frame_buffer_base
.C:4219  85 19       STA <dest
.C:421b  A5 25       LDA >frame_buffer_base
.C:421d  85 1A       STA >dest
;Are the lights off and the flashlight on?
;If not, continue
.C:421f  AD AB FE    LDA lights_status
.C:4222  C9 01       CMP #$01
.C:4224  D0 08       BNE move_one_column_left
;Flashlight is the only source of light
;So we'll copy from and to the same frame buffer instead of using two different ones
.C:4226  A5 24       LDA <frame_buffer_base
.C:4228  85 17       STA <source
.C:422a  A5 25       LDA >frame_buffer_base
.C:422c  85 18       STA >source
move_one_column_left:
;Add 1 to the dest pointer to point to column #1
.C:422e  E6 19       INC <dest
.C:4230  D0 02       BNE do_scroll_copy
.C:4232  E6 1A       INC >dest
do_scroll_copy:
;Do the scroll copy
.C:4234  20 BE 42    JSR scroll_left_copy
;Now copy the color data (6D89-6AE0)
;Set dest to 6D8A to point to column #1
.C:4237  A9 89       LDA #$89
.C:4239  85 17       STA <source
.C:423b  A9 6D       LDA #$6D
.C:423d  85 18       STA >source
.C:423f  A9 8A       LDA #$8A
.C:4241  85 19       STA <dest
.C:4243  A9 6D       LDA #$6D
.C:4245  85 1A       STA >dest
.C:4247  20 BE 42    JSR scroll_left_copy
;Now copy the mask layer (6AE1-7030)
;Set dest to 6AE2 to point to column #1
.C:424a  A9 E1       LDA #$E1
.C:424c  85 17       STA <source
.C:424e  A9 6A       LDA #$6A
.C:4250  85 18       STA >source
.C:4252  A9 E2       LDA #$E2
.C:4254  85 19       STA <dest
.C:4256  A9 6A       LDA #$6A
.C:4258  85 1A       STA >dest
.C:425a  20 BE 42    JSR scroll_left_copy
.C:425d  60          RTS
;===========================================
; Scroll room scene right (one column)
;
; Arguments:	frame_buffer	the current frame_buffer index
;
; This routine will copy the whole room scene graphics
; data one column to the right.
;
; It will use the current frame buffer as destionation, 
; and the alternate frame buffer as source,
; to avoid any display artifacts while doing the copy.
;
; In the special case in which the environment lights are off
; and the flashlight is on, the source and destination frame buffers
; are the same.
;
; It will copy video matrix data, color data and
; the mask layer data to keep everything in sync.
;
;===========================================
source = $17
dest = $19

scroll_scene_right:
;Which frame buffer are we using?
.C:425e  A5 23       LDA frame_buffer
.C:4260  C9 01       CMP #$01
.C:4262  D0 0B       BNE frame_buffer_2
;-------------------------------
;Frame buffer #1 (CC28 base address) - use the other frame buffer (C828) as source address
frame_buffer_1:
.C:4264  A9 28       LDA #$28
.C:4266  85 17       STA <source
.C:4268  A9 C8       LDA #$C8
.C:426a  85 18       STA >source
.C:426c  4C 77 42    JMP frame_buffer_set
;-------------------------------
;Frame buffer #2 (C828 base address) - use the other frame buffer (CC28) as source address
frame_buffer_2:
.C:426f  A9 28       LDA #$28
.C:4271  85 17       STA <source
.C:4273  A9 CC       LDA #$CC
.C:4275  85 18       STA >source
;-------------------------------
frame_buffer_set:
;Set the current frame buffer as destination
.C:4277  A5 24       LDA <frame_buffer_base
.C:4279  85 19       STA <dest
.C:427b  A5 25       LDA >frame_buffer_base
.C:427d  85 1A       STA >dest
;Are the lights off and the flashlight on?
;If not, continue
.C:427f  AD AB FE    LDA lights_status
.C:4282  C9 01       CMP #$01
.C:4284  D0 08       BNE move_one_column_right
;Flashlight is the only source of light
;So we'll copy from and to the same frame buffer instead of using two different ones
.C:4286  A5 24       LDA <frame_buffer_base
.C:4288  85 17       STA <source
.C:428a  A5 25       LDA >frame_buffer_base
.C:428c  85 18       STA >source
move_one_column_right:
;Add 1 to the source pointer to point to column #1
.C:428e  E6 17       INC <source
.C:4290  D0 02       BNE do_scroll_copy
.C:4292  E6 18       INC >source
do_scroll_copy:
;Do the scroll copy
.C:4294  20 E7 42    JSR scroll_right_copy
;Now copy the color data (6D89-6AE0)
;Set source to 6D8A to point to column #1
.C:4297  A9 8A       LDA #$8A
.C:4299  85 17       STA <source
.C:429b  A9 6D       LDA #$6D
.C:429d  85 18       STA >source
.C:429f  A9 89       LDA #$89
.C:42a1  85 19       STA <dest
.C:42a3  A9 6D       LDA #$6D
.C:42a5  85 1A       STA >dest
.C:42a7  20 E7 42    JSR scroll_right_copy
;Now copy the mask layer (6AE1-7030)
;Set source to 6AE2 to point to column #1
.C:42aa  A9 E2       LDA #$E2
.C:42ac  85 17       STA <source
.C:42ae  A9 6A       LDA #$6A
.C:42b0  85 18       STA >source
.C:42b2  A9 E1       LDA #$E1
.C:42b4  85 19       STA <dest
.C:42b6  A9 6A       LDA #$6A
.C:42b8  85 1A       STA >dest
.C:42ba  20 E7 42    JSR scroll_right_copy
.C:42bd  60          RTS
;===========================================
; Copy room scene graphics when scrolling left.
;
; Arguments:	source		pointer to row #0 column #26
;				dest		pointer to row #0 column #27
;===========================================
source = $17
dest = $19

scroll_left_copy:
;Use .X as row counter 
.C:42be  A2 10       LDX #$10
next_row:
;Use .Y as column counter - start from the right column, move left
.C:42c0  A0 26       LDY #$26
next_column:
;Copy byte from source column to destination column
.C:42c2  B1 17       LDA (source),Y
.C:42c4  91 19       STA (dest),Y
;Move to next column
.C:42c6  88          DEY
;Did we copy the last column? If not, continue
.C:42c7  10 F9       BPL next_column
;---------------------------------
;Move source pointer to the next row
.C:42c9  18          CLC
.C:42ca  A5 17       LDA <source
.C:42cc  69 28       ADC #$28
.C:42ce  85 17       STA <source
.C:42d0  A5 18       LDA >source
.C:42d2  69 00       ADC #$00
.C:42d4  85 18       STA >source
;---------------------------------
;Move dest pointer to the next row
.C:42d6  18          CLC
.C:42d7  A5 19       LDA <dest
.C:42d9  69 28       ADC #$28
.C:42db  85 19       STA <dest
.C:42dd  A5 1A       LDA >dest
.C:42df  69 00       ADC #$00
.C:42e1  85 1A       STA >dest
;---------------------------------
;If there are rows pending, continue
.C:42e3  CA          DEX
.C:42e4  10 DA       BPL next_row
.C:42e6  60          RTS
;===========================================
; Copy room scene graphics when scrolling right.
;
; Arguments:	source		pointer to row #0 column #1
;				dest		pointer to row #0 column #0
;===========================================
source = $17
dest = $19

scroll_right_copy:
;Use .X as row counter
.C:42e7  A2 10       LDX #$10
next_row:
;Use .Y as column counter - start from the left column, move right
.C:42e9  A0 00       LDY #$00
next_column:
;Copy byte from source column to destination column
.C:42eb  B1 17       LDA (source),Y
.C:42ed  91 19       STA (dest),Y
;Move to next column
.C:42ef  C8          INY
;Did we copy the last column? If not, continue
.C:42f0  C0 28       CPY #$28
.C:42f2  D0 F7       BNE next_column
;---------------------------------
;Move source pointer to the next row
.C:42f4  18          CLC
.C:42f5  A5 17       LDA <source
.C:42f7  69 28       ADC #$28
.C:42f9  85 17       STA <source
.C:42fb  A5 18       LDA >source
.C:42fd  69 00       ADC #$00
.C:42ff  85 18       STA >source
;---------------------------------
;Move dest pointer to the next row
.C:4301  18          CLC
.C:4302  A5 19       LDA <dest
.C:4304  69 28       ADC #$28
.C:4306  85 19       STA <dest
.C:4308  A5 1A       LDA >dest
.C:430a  69 00       ADC #$00
.C:430c  85 1A       STA >dest
;---------------------------------
;If there are rows pending, continue
.C:430e  CA          DEX
.C:430f  10 D8       BPL next_row
.C:4311  60          RTS
;===========================================
; Setup room scene data
;
; This routine will allocate and populate a "room scene" resource (resource type #04, index #00).
; The resource will contain pointers to room scene layers for each column.
; There are 3 layers represented:
;
;		-the video matrix layer (which dot-character or tile to display)
;		-the color layer (how to color tile pixels)
;		-the mask layer (unknown purpose yet)
;
; These layers are stored compressed in the room resource. 
; To speed up the rendering process, some of the information needed to decompress them
; is pre-calculated and cached. This room scene resource is the cache itself.
;
; For each room column, the pointer to the exact start of the column's compressed data is stored,
; along with the initial decompression parameters. 

; This allows rendering individual columns quickly, which is useful when scrolling, as all existing
; columns (but one) are copied from one frame buffer to another in their new position. The final new column
; is rendered directly, and having the room scene resource facilitates this.
;
; As a consequence of this, there is no need to pre-render the whole room scene in memory. 
; Only visible columns are rendered. This saves a lot of memory for wider rooms.
;
; As there are three layers, three sets of compression metadata are precomputed and stored.
;
; Note: as there is only one room active (rendered) at any point in time, there's only one "room scene" resource.
; 
;===========================================
room_data_ptr = $44b9

;Note: the same auxiliary zero-page addresses are reused with different purposes
;I used different labels for them liberally to make the code easier to understand
compressed_data_lo_ptr = $17
compressed_data_hi_ptr = $19
mode_counter_ptr = $1b
symbol_to_repeat_ptr = $1d
compressed_data = $27
word_lo = $15
word_hi = $16
room_byte_0 = $7139
block_ptr = $4f
block_size = $15
product_12 = $15
product_8 = $15
product_4 = $17
room_width_16bit = $15
room_data_ptr = $17
rsrc_ptr_local = $17

setup_room_scene_rsrc:
;Is there a resource in memory right now?
.C:4312  AE 79 7B    LDX room_layers_rsrc_lo
.C:4315  AC 77 7B    LDY room_layers_rsrc_hi
;If so, release it - otherwise continue
.C:4318  F0 03       BEQ calculate_rsrc_size
.C:431a  20 03 55    JSR release_resource
;-------------------------------------
; We need to allocate memory for the new type 4 A resource
; The space needed is: the room's total number of columns * 12
; (plus 4 bytes for the resource header)
;
; Each row requires 12 16-bit addresses (for a total of 24 bytes),
; divided in 3 groups.
;
;-------------------------------------

;-------------------------------------
; Calculate the 4x product
;-------------------------------------
;The starting value is 8 bits wide, but the multiplication result might need more than 8 bits.
;So we'll use a 16-bit result.
;
;As a little reminder, shifting left will shift the most significant bit (bit 7) into the carry
;
;Carry	Byte bits
;----------------
;  x	76543210
;					<- shift left once
;  7	6543210-
;
; If we now do a left rotation of the carry into the hi-byte of the 16-bit result,
; we store the original bit 7 as bit 0 of the hi-byte. The result looks like this:
;
; Result-hi		Result-lo
; xxxxxxx7		6543210x
;
; Thus achieving a "16-bit wide" multiplication by 2
;
;-------------------------------------
; Calculate the 4x product
;-------------------------------------
; Do a double 16-bit multiplication by 2 of the room's width, store result in product_8
calculate_rsrc_size:
.C:431d  A9 00       LDA #$00
.C:431f  85 16       STA >product_8
.C:4321  AD 39 71    LDA room_width
.C:4324  0A          ASL A
.C:4325  26 16       ROL >product_8
.C:4327  0A          ASL A
.C:4328  26 16       ROL >product_8
.C:432a  85 15       STA <product_8
;Copy product_8 to product_4
.C:432c  85 17       STA <product_4
.C:432e  A5 16       LDA >product_8
.C:4330  85 18       STA >product_4
;-------------------------------------
; Calculate the 8x product
;-------------------------------------
;Multiply product_8 by 2 to effectively get the 8x product
.C:4332  06 15       ASL <product_8
.C:4334  26 16       ROL >product_8
;-------------------------------------
; Calculate the 12x product
;-------------------------------------
;Add the 2 products together: 
;   product_8 + product_4 = 
; = 8 * value + 4 * value = 
; = (8 + 4) * value = 
; = 12 * value
.C:4336  18          CLC
.C:4337  A5 15       LDA <product_8
.C:4339  65 17       ADC <product_4
.C:433b  85 15       STA <product_12
.C:433d  A5 16       LDA >product_8
.C:433f  65 18       ADC >product_4
.C:4341  85 16       STA >product_12
;-------------------------------------
; Add 4 bytes for header - the result is the block size needed
.C:4343  18          CLC
.C:4344  A5 15       LDA <product_12
.C:4346  69 04       ADC #$04
.C:4348  85 15       STA <block_size
.C:434a  A5 16       LDA >product_12
.C:434c  69 00       ADC #$00
.C:434e  85 16       STA >block_size
;-------------------------------------
; Allocate a block of the needed size
.C:4350  A6 15       LDX <block_size
.C:4352  A4 16       LDY >block_size
.C:4354  20 E4 54    JSR alloc_data
;Save the block address in block_ptr
.C:4357  86 4F       STX <block_ptr
.C:4359  84 50       STY >block_ptr
;-------------------------------------
;Setup the resource metadata (room layers resource is always type #04, index #00)
.C:435b  A9 04       LDA #$04
.C:435d  8D 77 56    STA resource_type
.C:4360  A9 00       LDA #$00
.C:4362  8D 76 56    STA resource_index
.C:4365  20 04 56    JSR setup_block_metadata
;-------------------------------------
;Copy the resource pointer to room_layers_rsrc
.C:4368  A6 4F       LDX <block_ptr
.C:436a  A4 50       LDY >block_ptr
.C:436c  8E 79 7B    STX room_layers_rsrc_lo
.C:436f  8C 77 7B    STY room_layers_rsrc_hi
;Also copy it to current_room_layers_rsrc
;This is used later to check if the type4 resource has changed and needs to be released
.C:4372  8E 98 FE    STX <current_room_layers_rsrc
.C:4375  8C 99 FE    STY >current_room_layers_rsrc
;Finally, copy the resource pointer to rsrc_ptr_local
.C:4378  86 17       STX <rsrc_ptr_local
.C:437a  84 18       STY >rsrc_ptr_local
;-------------------------------------
;Move rsrc_ptr_local to skip the resource header (4 bytes)
.C:437c  18          CLC
.C:437d  A5 17       LDA <rsrc_ptr_local
.C:437f  69 04       ADC #$04
.C:4381  85 17       STA <rsrc_ptr_local
.C:4383  A5 18       LDA >rsrc_ptr_local
.C:4385  69 00       ADC #$00
.C:4387  85 18       STA >rsrc_ptr_local
;-------------------------------------
;Copy the room width into a 16-bit value
.C:4389  AD 39 71    LDA room_width
.C:438c  85 15       STA <room_width_16bit
.C:438e  A9 00       LDA #$00
.C:4390  85 16       STA >room_width_16bit
;---------------------------------------------------
; Calculate start address of each pointer byte list
;---------------------------------------------------
;
; As mentioned before, there are 3 sets of compressed data associated with a room (tile layer, color layer, mask layer).
;
; For any kind of compressed data, apart from the destination buffer, 4 bytes are needed to start a decompression:
;
;		-a pointer to the source data - src_lo and src_hi (2 bytes)
;		-an initial mode counter (1 byte)
;		-an initial value to repeat (1 byte)
;
; These can be summarized, for a single layer, as:
;
;		src_lo
;		src_hi
;		decomp_emit_rem
;		value_to_repeat
;
; These 4 values can be thought of as the initial state for the decompression state machine.
; By precomputing and saving the initial state for each room's column, the decompression can be started on arbitrary columns,
; instead of having to decompress the whole room at once. Thus saving some memory while allowing a relatively fast horizontal scroll.
; 
; The tradeoff is that each column's initial state has to be stored somewhere.
; That place is the "type 4A" resource of a room.
; It's simply a list of initial states, for each layer, for each column.
; 3 layers * 4 bytes per initial state = 12 values to store
; 12 values to store * 2 bytes per pointer for each value = 24 pointer bytes in total (or #18 in hexadecimal)
; Each column thus needs 24 pointer bytes.
;
; This would be the full list of 24 pointer bytes for a single column:
;
;	tile_layer_src_lo_ptr_lo
;	tile_layer_src_lo_ptr_hi
;	tile_layer_src_hi_ptr_lo
;	tile_layer_src_hi_ptr_hi
;	tile_layer_mode_counter_ptr_lo
;	tile_layer_mode_counter_ptr_hi
;	tile_layer_value_to_repeat_ptr_lo
;	tile_layer_value_to_repeat_ptr_hi
;	color_layer_src_lo_ptr_lo
;	color_layer_src_lo_ptr_hi
;	color_layer_src_hi_ptr_lo
;	color_layer_src_hi_ptr_hi
;	color_layer_mode_counter_ptr_lo
;	color_layer_mode_counter_ptr_hi
;	color_layer_value_to_repeat_ptr_lo
;	color_layer_value_to_repeat_ptr_hi
;	mask_layer_src_lo_ptr_lo
;	mask_layer_src_lo_ptr_hi
;	mask_layer_src_hi_ptr_lo
;	mask_layer_src_hi_ptr_hi
;	mask_layer_mode_counter_ptr_lo
;	mask_layer_mode_counter_ptr_hi
;	mask_layer_value_to_repeat_ptr_lo
;	mask_layer_value_to_repeat_ptr_hi

; The 24 bytes for each column are not stored consecutively in memory. 
; Instead, all values for the first pointer, for all columns, are stored consecutively first,
; then the second, and so on.
;
; This means:
; 
;	tile_layer_src_lo_ptr_lo_col_0
;	tile_layer_src_lo_ptr_hi_col_0
;	tile_layer_src_lo_ptr_lo_col_1
;	tile_layer_src_lo_ptr_hi_col_1
;		...
;	tile_layer_src_lo_ptr_lo_col_n
;	tile_layer_src_lo_ptr_hi_col_n
;	tile_layer_src_hi_ptr_lo_col_0
;	tile_layer_src_hi_ptr_hi_col_0
;	tile_layer_src_hi_ptr_lo_col_1
;	tile_layer_src_hi_ptr_hi_col_1
;		...
;	tile_layer_src_hi_ptr_lo_col_n
;	tile_layer_src_hi_ptr_hi_col_n
;
;	...and so on
;
; So there are 12 lists, one for each pointer byte. The lists themselves _are_ stored one after the other.
; To calculate where each of the 12 lists start, we simply need to add the number of columns to the previous base address.
;---------------------------------------------------
;Use .Y as pointer counter, start at #00, move upwards by 2
.C:4392  A0 00       LDY #$00
compute_pointer_list_start:
;Write the current address into the resource 4A as the base address for the current pointer list
precomputed_pointer_array_16bit = $0064
.C:4394  A5 17       LDA <rsrc_ptr_local
.C:4396  99 64 00    STA precomputed_pointer_array_16bit,Y
.C:4399  99 BB 44    STA $44BB,Y
.C:439c  A5 18       LDA >rsrc_ptr_local
.C:439e  99 65 00    STA precomputed_pointer_array_16bit + 1,Y
.C:43a1  99 BC 44    STA $44BC,Y
;Add room width to rsrc_ptr_local to point to the start of the next pointer list
.C:43a4  18          CLC
.C:43a5  A5 17       LDA <rsrc_ptr_local
.C:43a7  65 15       ADC <room_width_16bit
.C:43a9  85 17       STA <rsrc_ptr_local
.C:43ab  A5 18       LDA >rsrc_ptr_local
.C:43ad  65 16       ADC >room_width_16bit
.C:43af  85 18       STA >rsrc_ptr_local
;Increment .Y by 2 to move to the next pointer element
.C:43b1  C8          INY
.C:43b2  C8          INY
;Do we still have pointers to compute? If so, continue
.C:43b3  C0 18       CPY #$18		
.C:43b5  D0 DD       BNE compute_pointer_list_start
;---------------------------------------------------
;Now that we know where each of the 12 pointer lists start,
;simulate a decompression of each layer to precompute each of the 12 pointers, for every column
;---------------------------------------------------
;Get a pointer to the room's resource (room_data_ptr)
.C:43b7  AE 49 71    LDX current_room
.C:43ba  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:43bd  8D B9 44    STA <room_data_ptr
.C:43c0  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:43c3  8D BA 44    STA >room_data_ptr
;---------------------------------------------------
;Pre-compute column pointers to the tile matrix layer 
;---------------------------------------------------
precomputed_pointer_array = $64
;Point to the start of the compressed data for the tile layer
.C:43c6  18          CLC
.C:43c7  AD B9 44    LDA <room_data_ptr
.C:43ca  6D 41 71    ADC <room_tile_matrix_offset
.C:43cd  85 27       STA <compressed_data
.C:43cf  AD BA 44    LDA >room_data_ptr
.C:43d2  6D 42 71    ADC >room_tile_matrix_offset
.C:43d5  85 28       STA >compressed_data
;Set up the initial 8 column pointers for the tile layer precomputed data
.C:43d7  A5 64       LDA precomputed_pointer_array
.C:43d9  85 17       STA <compressed_data_lo_ptr
.C:43db  A5 65       LDA precomputed_pointer_array + 1
.C:43dd  85 18       STA >compressed_data_lo_ptr
.C:43df  A5 66       LDA precomputed_pointer_array + 2
.C:43e1  85 19       STA <compressed_data_hi_ptr
.C:43e3  A5 67       LDA precomputed_pointer_array + 3
.C:43e5  85 1A       STA >compressed_data_hi_ptr
.C:43e7  A5 68       LDA precomputed_pointer_array + 4
.C:43e9  85 1B       STA <mode_counter_ptr
.C:43eb  A5 69       LDA precomputed_pointer_array + 5
.C:43ed  85 1C       STA >mode_counter_ptr
.C:43ef  A5 6A       LDA precomputed_pointer_array + 6
.C:43f1  85 1D       STA <symbol_to_repeat_ptr
.C:43f3  A5 6B       LDA precomputed_pointer_array + 7
.C:43f5  85 1E       STA >symbol_to_repeat_ptr
.C:43f7  20 63 44    JSR precompute_column_decompression_states
;---------------------------------------------------
;Pre-compute column pointers to the color layer 
;---------------------------------------------------
;Point to the start of the compressed data for the color layer
.C:43fa  18          CLC
.C:43fb  AD B9 44    LDA <room_data_ptr
.C:43fe  6D 43 71    ADC <room_color_layer_offset
.C:4401  85 27       STA <compressed_data
.C:4403  AD BA 44    LDA >room_data_ptr
.C:4406  6D 44 71    ADC >room_color_layer_offset
.C:4409  85 28       STA >compressed_data
;Set up the initial 8 column pointers for the color layer precomputed data
.C:440b  A5 6C       LDA precomputed_pointer_array + 8
.C:440d  85 17       STA <compressed_data_lo_ptr
.C:440f  A5 6D       LDA precomputed_pointer_array + 9
.C:4411  85 18       STA >compressed_data_lo_ptr
.C:4413  A5 6E       LDA precomputed_pointer_array + 10
.C:4415  85 19       STA <compressed_data_hi_ptr
.C:4417  A5 6F       LDA precomputed_pointer_array + 11
.C:4419  85 1A       STA >compressed_data_hi_ptr
.C:441b  A5 70       LDA precomputed_pointer_array + 12
.C:441d  85 1B       STA <mode_counter_ptr
.C:441f  A5 71       LDA precomputed_pointer_array + 13
.C:4421  85 1C       STA >mode_counter_ptr
.C:4423  A5 72       LDA precomputed_pointer_array + 14
.C:4425  85 1D       STA <symbol_to_repeat_ptr
.C:4427  A5 73       LDA precomputed_pointer_array + 15
.C:4429  85 1E       STA >symbol_to_repeat_ptr
.C:442b  20 63 44    JSR precompute_column_decompression_states
;---------------------------------------------------
;Pre-compute column pointers to the mask layer 
;---------------------------------------------------
;Point to the start of the compressed data for the mask layer
.C:442e  18          CLC
.C:442f  AD B9 44    LDA <room_data_ptr
.C:4432  6D 45 71    ADC <room_mask_layer_offset
.C:4435  85 27       STA <compressed_data
.C:4437  AD BA 44    LDA >room_data_ptr
.C:443a  6D 46 71    ADC >room_mask_layer_offset
.C:443d  85 28       STA >compressed_data
;Set up the initial 8 column pointers for the mask layer precomputed data
.C:443f  A5 74       LDA precomputed_pointer_array + 16
.C:4441  85 17       STA <compressed_data_lo_ptr
.C:4443  A5 75       LDA precomputed_pointer_array + 17
.C:4445  85 18       STA >compressed_data_lo_ptr
.C:4447  A5 76       LDA precomputed_pointer_array + 18
.C:4449  85 19       STA <compressed_data_hi_ptr
.C:444b  A5 77       LDA precomputed_pointer_array + 19
.C:444d  85 1A       STA >compressed_data_hi_ptr
.C:444f  A5 78       LDA precomputed_pointer_array + 20
.C:4451  85 1B       STA <mode_counter_ptr
.C:4453  A5 79       LDA precomputed_pointer_array + 21
.C:4455  85 1C       STA >mode_counter_ptr
.C:4457  A5 7A       LDA precomputed_pointer_array + 22
.C:4459  85 1D       STA <symbol_to_repeat_ptr
.C:445b  A5 7B       LDA precomputed_pointer_array + 23
.C:445d  85 1E       STA >symbol_to_repeat_ptr
.C:445f  20 63 44    JSR precompute_column_decompression_states
.C:4462  60          RTS
;===========================================
; Precompute room scene column pointers
;
; This resource holds information for each room's column.
; Each column's data is compressed. To decompress the data,
; some information is needed, such as:
;
;	-the symbol dictionary
;	-the start address of the compressed data
;	-an initial decompression mode counter
;	-an initial symbol to repeat
;
; These values are stored in the room scene resource to expedite
; column decompression when needed.
;===========================================
temp_x = $41f9
room_byte_0 = $7139

compressed_data_lo_ptr = $17
compressed_data_hi_ptr = $19
mode_counter_ptr = $1b
symbol_to_repeat_ptr = $1d

compressed_data = $27
decomp_emit_mode = $29
decomp_emit_rem = $2a
decomp_run_symbol = $2b

precompute_column_decompression_states:
;Sanity check
.C:4463  20 9B 44    JSR verify_memory_equality
;compressed_data points to the compression dictionary - read it and set it up
.C:4466  20 04 01    JSR decomp_dict4_init
;After the call, it will move past the dictionary and point straight to the compressed data
;-------------------------------------------
; Use .Y as column counter, start from #00, move upwards
.C:4469  A0 00       LDY #$00
save_state:
;Get the address where the compressed data starts (past the symbol dictionary)
;Store the address into compressed_data_lo/hi
.C:446b  A5 27       LDA <compressed_data
.C:446d  91 17       STA (compressed_data_lo_ptr),Y
.C:446f  A5 28       LDA >compressed_data
.C:4471  91 19       STA (compressed_data_hi_ptr),Y
;Are we in run mode or direct mode?
.C:4473  A5 29       LDA decomp_emit_mode
.C:4475  10 07       BPL run_mode
;-------------------------------------------
;Direct mode - set bit 7 of the mode counter
;This converts the mode to a dictionary run??
.C:4477  A9 80       LDA #$80
.C:4479  05 2A       ORA decomp_emit_rem
.C:447b  4C 80 44    JMP save_mode_counter
;-------------------------------------------
;Run mode - use the counter as is
run_mode:
.C:447e  A5 2A       LDA decomp_emit_rem
;-------------------------------------------
save_mode_counter:
;Save the mode counter
.C:4480  91 1B       STA (mode_counter_ptr),Y
;Save the symbol to be repeated
.C:4482  A5 2B       LDA decomp_run_symbol
.C:4484  91 1D       STA (symbol_to_repeat_ptr),Y
;-------------------------------------------
;At this point, we have saved the initial state of decompression for this column
;-------------------------------------------
; Move to the next column
; Skip #10 compressed bytes (the height of a room column)
;-------------------------------------------
; Use .X as decompressed byte counter, start from #10, move downwards
.C:4486  A2 10       LDX #$10
decompress_next:
;Save .X
.C:4488  8E F9 41    STX temp_x
;Read a decompressed byte (it will be ignored and discarded)
.C:448b  20 22 01    JSR decomp_stream_next
;Restore .X
.C:448e  AE F9 41    LDX temp_x
;Is the count pending? If so, continue
.C:4491  CA          DEX
.C:4492  10 F4       BPL decompress_next
;-------------------------------------------
;Have we reached the last column? If so, exit - otherwise, continue
.C:4494  C8          INY
.C:4495  CC 39 71    CPY room_byte_0
.C:4498  D0 D1       BNE save_state
.C:449a  60          RTS
;===========================================
; This routine verifies that the 24 bytes stored
; in the memory range $0064-007B are identical to 
; the ones stored in $44BB-44D3.
;
; I have no idea why this is done (or even why
; the bytes are duplicated in the first place).
;
; Arguments:	none
; Returns:		nothing - will hang up execution if 
;					the validation fails
;===========================================
verify_memory_equality:
;Use .Y as the byte index, start from #00, go upwards
.C:449b  A0 00       LDY #$00
equality_check:
;Check equality - if bytes don't match, hang up execution
.C:449d  B9 64 00    LDA $0064,Y
.C:44a0  D9 BB 44    CMP $44BB,Y
.C:44a3  F0 0E       BEQ next
;-------------------------------------------------
;Hang execution
.C:44a5  A9 01       LDA #$01
.C:44a7  85 DC       STA $DC
;map_in_io
.C:44a9  A0 25       LDY #$25
.C:44ab  84 01       STY processor_port_register
hangup_loop:
.C:44ad  8D 20 D0    STA vic_border_color_register
.C:44b0  4C AD 44    JMP hangup_loop
;-------------------------------------------------
next:
;Move to next byte
.C:44b3  C8          INY
;Any bytes pending? If so, continue - otherwise, exit
.C:44b4  C0 18       CPY #$18
.C:44b6  D0 E5       BNE equality_check
.C:44b8  60          RTS
;===========================================
; Prepares disk r/w sector arguments for a sector chain
;
;	Arguments:	.X	sector
;				.Y	track
;
; Will reset last_sector/track_loaded,
; set sector_chain_index to #00 and read_offset to #00
;===========================================
start_sector = $4633
start_track = $4634

disk_init_chain:
.C:44d3  8E 33 46    STX start_sector
.C:44d6  8C 34 46    STY start_track
.C:44d9  A9 00       LDA #$00
.C:44db  8D 37 46    STA last_sector_loaded
.C:44de  A9 00       LDA #$00
.C:44e0  8D 38 46    STA last_track_loaded
.C:44e3  A9 00       LDA #$00
.C:44e5  8D 3A 46    STA read_offset
.C:44e8  A9 00       LDA #$00
.C:44ea  8D 3B 46    STA sector_chain_index
.C:44ed  60          RTS
;===========================================
; disk_init_chain_and_read
;
;	Input args:	.X, .Y	sector/track to read
;
; Will reset last_sector/track_loaded and 463A/463B
;===========================================
disk_init_chain_and_read:
.C:44ee  20 D3 44    JSR disk_init_chain
.C:44f1  AE 3A 46    LDX read_offset
.C:44f4  AC 3B 46    LDY sector_chain_index
;===========================================
; disk_seek_read
;
;	Input args:	.X	read_offset	- byte offset to start reading from (within a sector's data)
;				.Y	sector_chain_index	(the index of the desired sector in a chain)
;				
;
; Will reset last_sector/track_loaded and 463A/463B
;===========================================
start_sector = $4633
start_track = $4634
current_sector = $4635
current_track = $4636
read_offset = $463A
sector_chain_index = $463B

disk_seek_read:
.C:44f7  8E 3A 46    STX read_offset
.C:44fa  8C 3B 46    STY sector_chain_index
.C:44fd  AD 33 46    LDA start_sector
.C:4500  8D 35 46    STA current_sector
.C:4503  AD 34 46    LDA start_track
.C:4506  8D 36 46    STA current_track

;Did we want the very first sector of a sector chain? 
.C:4509  AD 3B 46    LDA sector_chain_index
.C:450c  F0 07       BEQ sector_chain_index_reached
;Keep advancing until we reach the desired index
.C:450e  AA          TAX
next_sector_in_chain:
.C:450f  20 AE 45    JSR disk_next_sector_phys
.C:4512  CA          DEX
.C:4513  D0 FA       BNE next_sector
;Set the read offset
sector_chain_index_reached:
.C:4515  AD 3A 46    LDA read_offset
.C:4518  8D 39 46    STA sector_memory_read_offset
;Read sector
.C:451b  20 EB 45    JSR disk_read_sector_into_buffer
.C:451e  60          RTS
;===========================================
; Copies bytes from the loaded sector buffer to the destination pointer
;
; Input args:	.X	destination address lo
;				.Y	destination address hi
;				disk_copy_count_lo/hi	total number of bytes to copy
;				sector_memory_read_offset - byte offset to start reading from
;						(this will be used by disk_stream_next_byte)
;===========================================
;Inline destination pointer from .X/.Y
write_ptr_lo = $4529
write_ptr_hi = $452A
disk_copy_count_lo = $463C
disk_copy_count_hi = $463D

disk_stream_copy:
.C:451f  8E 29 45    STX write_ptr_lo	
.C:4522  8C 2A 45    STY write_ptr_hi
read_loop:
.C:4525  20 8E 45    JSR disk_stream_next_byte
.C:4528  8D FF FF    STA $FFFF	;Address inlined (dest_ptr)
;Increment destination pointer
.C:452b  EE 29 45    INC write_ptr_lo
.C:452e  D0 03       BNE decrement_counters
.C:4530  EE 2A 45    INC write_ptr_hi
decrement_counters:
.C:4533  AD 3C 46    LDA disk_copy_count_lo
.C:4536  D0 03       BNE decrement_counter_lo
.C:4538  CE 3D 46    DEC disk_copy_count_hi
decrement_counter_lo:
.C:453b  CE 3C 46    DEC disk_copy_count_lo
;Do we still have bytes to read?
.C:453e  AD 3C 46    LDA disk_copy_count_lo
.C:4541  0D 3D 46    ORA disk_copy_count_hi
.C:4544  D0 DF       BNE read_loop
.C:4546  60          RTS
;===========================================
; Write a sector from memory
;
; Arguments:	.X/.Y	- src_ptr lo/hi
;				$4633	- track
;				$4634	 - sector
;===========================================
src_ptr_lo = $4631
src_ptr_hi = $4632

disk_write_linear:
.C:4547  8E 31 46    STX src_ptr_lo
.C:454a  8C 32 46    STY src_ptr_hi
.C:454d  AD 33 46    LDA sector_desired
.C:4550  8D 35 46    STA sector_to_read
.C:4553  AD 34 46    LDA track_desired
.C:4556  8D 36 46    STA track_to_read
.C:4559  AD 3C 46    LDA disk_copy_count_lo
.C:455c  F0 03       BEQ try_write
.C:455e  EE 3D 46    INC disk_copy_count_hi
try_write:
;map_in_io
.C:4561  A0 25       LDY #$25
.C:4563  84 01       STY processor_port_register
.C:4565  AE 36 46    LDX track_to_read
.C:4568  AC 35 46    LDY sector_to_read
.C:456b  20 41 46    JSR disk_write_sector
.C:456e  90 0E       BCC $457E
;Print disk_error_msg
.C:4570  A9 81       LDA #$81
.C:4572  85 DA       STA $DA
.C:4574  A9 3B       LDA #$3B
.C:4576  85 DB       STA $DB
.C:4578  20 15 3B    JSR print_message_wait_for_button
.C:457b  4C 61 45    JMP try_write
;map_out_io
.C:457e  A0 24       LDY #$24
.C:4580  84 01       STY processor_port_register
.C:4582  20 AE 45    JSR disk_next_sector_phys
.C:4585  EE 32 46    INC src_ptr_hi
.C:4588  CE 3D 46    DEC disk_copy_count_hi
.C:458b  D0 D4       BNE try_write
.C:458d  60          RTS
;===========================================
; Reads the next byte from the disk buffer
;
; Handles a page boundary cross automatically,; by loading the next valid sector.
;
; Arguments:	sector_memory_read_offset		offset into memory page (and thus sector)
;
; Returns:		.A				value read
;				sector_memory_read_offset will be incremented by one on return
;===========================================
sector_memory_read_offset = $4639

disk_stream_next_byte:
;Save .Y
.C:458e  8C AD 45    STY y_copy		
;Honor the offset into the buffer
.C:4591  AC 39 46    LDY sector_memory_read_offset		
;Load value in offset (to be returned in .A on exit)
.C:4594  B9 00 03    LDA $0300,Y	
;Save .A
.C:4597  48          PHA
;Increase offset and check if it's zero (which means a page boundary cross)
.C:4598  EE 39 46    INC sector_memory_read_offset		
;If it's nonzero, exit now
.C:459b  D0 0B       BNE exit				
;If it's zero, we just crossed a page (which match perfectly with sectors)
; so we need to continue in the next consecutive sector
;Load the next valid sector into memory
.C:459d  20 AE 45    JSR disk_next_sector_phys
.C:45a0  20 EB 45    JSR disk_read_sector_into_buffer
;Reset read offset
.C:45a3  A9 00       LDA #$00		
.C:45a5  8D 39 46    STA sector_memory_read_offset
exit:
;Restore .Y and .A
.C:45a8  AC AD 45    LDY y_copy		
.C:45ab  68          PLA
.C:45ac  60          RTS
y_copy:
.C:45ad  00         
;===========================================
; Computes the next valid track/sector numbers
;
; The idea is to return the next valid sector, which should be the next sector of the same track.
; As tracks have a limited number of sectors, and they depend on the track number,
; if the next sector is outside the valid range, then "wrap".
; That is, return the next _track_, sector 0.
;
;
; Arguments:	current_track, current_sector  - from which to compute the next one
; Return values: current_track, current_sector - hold the next valid track/sector
;===========================================
current_track = $4636
current_sector = $4635
disk_next_sector_phys:
;Increase sector by 1
.C:45ae  EE 35 46    INC current_sector
;Check that it doesn't exceed the sectors per track limit for this track
.C:45b1  AD 35 46    LDA current_sector
.C:45b4  AC 36 46    LDY current_track
.C:45b7  D9 C7 45    CMP max_sector_index_by_track,Y
;If it's lower than or equal, it's in range, exit
.C:45ba  90 0A       BCC compute_next_valid_sector_exit
.C:45bc  F0 08       BEQ compute_next_valid_sector_exit
;It's off range, so the "next" valid sector is in the next track, sector 0
.C:45be  A9 00       LDA #$00
.C:45c0  8D 35 46    STA current_sector
.C:45c3  EE 36 46    INC current_track
compute_next_valid_sector_exit:
.C:45c6  60          RTS
;===========================================
max_sector_index_by_track:
.C:45c7  
00 
14 14 14 14 14 14 14 14 14 14 
14 14 14 14 14 14 14 12 12 12 
12 12 12 12 11 11 11 11 11 11 
10 10 10 10 10 
;===========================================
;Read a sector into $0300-03FF
;
; If there's a read error, it will print an error message
; and retry the read (indefinitely).
;
; On success, it will store the track and sector in last_track_loaded and last_sector_loaded.
;
; Arguments: 	.X track
;				.Y sector
;===========================================
y_copy = $462F
x_copy = $4630
write_ptr_lo = $4631
write_ptr_hi = $4632
sector_to_read = $4635
track_to_read = $4636
last_sector_loaded = $4637
last_track_loaded = $4638
SECTOR_BUFFER_LO = #$00
SECTOR_BUFFER_HI = #$03

disk_read_sector_into_buffer:
;Save .X and .Y
.C:45eb  8E 30 46	 STX x_copy
.C:45ee  8C 2F 46    STY y_copy
;Set destination buffer as $0300
.C:45f1  A9 00       LDA SECTOR_BUFFER_LO
.C:45f3  8D 31 46    STA write_ptr_lo
.C:45f6  A9 03       LDA SECTOR_BUFFER_HI
.C:45f8  8D 32 46    STA write_ptr_hi
attempt_read_sector:
;map_in_io
.C:45fb  A0 25       LDY #$25
.C:45fd  84 01       STY processor_port_register
;Read the sector after preparing all attributes and enabling I/O
.C:45ff  AE 36 46    LDX track_to_read
.C:4602  AC 35 46    LDY sector_to_read
.C:4605  20 6E 46    JSR disk_read_sector
;map_out_io
.C:4608  A0 24       LDY #$24
.C:460a  84 01       STY processor_port_register
;If carry is clear, read succeeded
.C:460c  90 0E       BCC read_succeeded
;Read failed
;Print disk_error_msg
.C:460e  A9 81       LDA #$81
.C:4610  85 DA       STA $DA
.C:4612  A9 3B       LDA #$3B
.C:4614  85 DB       STA $DB
.C:4616  20 15 3B    JSR print_message_wait_for_button
;Attempt to read again
.C:4619  4C FB 45    JMP attempt_read_sector
read_succeeded:
.C:461c  AD 35 46    LDA sector_to_read
.C:461f  8D 37 46    STA last_sector_loaded
.C:4622  AD 36 46    LDA track_to_read
.C:4625  8D 38 46    STA last_track_loaded
;Restore .X and .Y
.C:4628  AE 30 46    LDX x_copy
.C:462b  AC 2F 46    LDY y_copy
.C:462e  60          RTS
;===========================================
; Write sector 
;
;		Arguments: .X track
;					.Y sector
;					$4631/$4632 - src_ptr
;===========================================
command_track = $4753
command_sector = $4754
src_ptr_lo = $4631
src_ptr_hi = $4632
inlined_src_ptr_lo = $465E
inlined_src_ptr_hi = $465F

disk_write_sector:
.C:4641  8E 53 47    STX command_track
.C:4644  8C 54 47    STY command_sector
;Overwrite inlined src_ptr
.C:4647  AD 31 46    LDA src_ptr_lo
.C:464a  8D 5E 46    STA inlined_src_ptr_lo
.C:464d  AD 32 46    LDA src_ptr_hi
.C:4650  8D 5F 46    STA inlined_src_ptr_hi
.C:4653  A9 40       LDA #$40					;#40 = write sector
.C:4655  20 C2 46    JSR send_command_to_drive
.C:4658  20 DC 46    JSR sync_with_drive
.C:465b  A2 00       LDX #$00
send_next_byte:
;Important: base pointer is inlined here
.C:465d  BD 00 40    LDA $4000,X				;The destination base pointer will be set upon routine entry ($4631/32)
.C:4660  20 23 47    JSR send_byte_over_serial
.C:4663  E8          INX
.C:4664  D0 F7       BNE send_next_byte
.C:4666  18          CLC
.C:4667  60          RTS
;===========================================
disk_reset:
.C:4668  A9 20       LDA #$20					;#20 = reset drive
.C:466a  20 C2 46    JSR send_command_to_drive
.C:466d  60          RTS
;===========================================
; Read sector
;
; Reads a disk sector into the buffer pointed to by dest_ptr.
;
; Arguments: 	.X track
;				.Y sector
;				$4631/$4632 - dest_ptr
;
; On success, the carry is clear.
; On failure, carry is set.
;
; Special sequences are used to mark errors, the end of data,
; and a sync request. These sequences are started by the same value (#01).
;
; To differentiate a real #01 byte from the end-of-data sequence,
; it has to be "escaped" by preceding it with another #01.
;
; Note: if an unrecognized special sequence is received,
; the code will hang in an infinite loop.
;===========================================
READ_COMMAND = #$30
GREEN_COLOR = #$05
SPECIAL_SEQUENCE_BEGINNING = #$01
ESCAPED_BYTE = #$01
END_OF_DATA_MARKER = #$81
ERROR_MARKER = #$11
SYNC_MARKER = #$21

write_ptr_lo = $4631
write_ptr_hi = $4632

inlined_write_ptr_lo = $46AB		;This pointer is inlined in the routine's code
inlined_write_ptr_hi = $46AC

disk_read_sector:
;Set track and sector
.C:466e  8E 53 47    STX command_track
.C:4671  8C 54 47    STY command_sector
;Set inlined dest_ptr
.C:4674  AD 31 46    LDA write_ptr_lo
.C:4677  8D AB 46    STA inlined_write_ptr_lo
.C:467a  AD 32 46    LDA write_ptr_hi
.C:467d  8D AC 46    STA inlined_write_ptr_hi
;Set operation
.C:4680  A9 30       LDA READ_COMMAND
;Send command
.C:4682  20 C2 46    JSR send_command_to_drive
;Sync with the drive
.C:4685  20 DC 46    JSR sync_with_drive
;Use .X as offset into the data buffer
.C:4688  A2 00       LDX #$00
next_byte:
;Receive a byte
.C:468a  20 F3 46    JSR recv_byte_from_serial
;Check if it's a special sequence beginning
.C:468d  C9 01       CMP SPECIAL_SEQUENCE_BEGINNING
;If not, store it directly in the buffer
.C:468f  D0 19       BNE store_in_buffer
;It's a special sequence, check which one by reading the next byte
special_sequence:
.C:4691  20 F3 46    JSR recv_byte_from_serial
;It's an escaped byte, store it directly in buffer
.C:4694  C9 01       CMP ESCAPED_BYTE
.C:4696  F0 12       BEQ store_in_buffer
;Is it an end-of-data marker?
.C:4698  C9 81       CMP END_OF_DATA_MARKER
.C:469a  F0 1C       BEQ command_success
;Is it an error?
.C:469c  C9 11       CMP ERROR_MARKER
.C:469e  F0 16       BEQ command_error
;Is it a sync indication?
.C:46a0  C9 21       CMP SYNC_MARKER
;If not, we don't recognize the command - hang execution
.C:46a2  D0 16       BNE hang_loop
;Sync needed - do it and keep reading
.C:46a4  20 DC 46    JSR sync_with_drive
.C:46a7  4C 8A 46    JMP next_byte
store_in_buffer:
;Store byte in destination pointer
.C:46aa  9D FF FF    STA $FFFF,X			;IMPORTANT: the destination pointer is inlined here
;Update offset - did we cross a page, relative to the pointer? If not, continue with next_byte
.C:46ad  E8          INX
.C:46ae  D0 03       BNE $46B3
;We did cross a page relative to the pointer - move dest pointer hi
.C:46b0  EE AC 46    INC inlined_write_ptr_hi
.C:46b3  4C 8A 46    JMP next_byte
command_error:
.C:46b6  38          SEC
.C:46b7  60          RTS
command_success:
.C:46b8  18          CLC
.C:46b9  60          RTS
hang_loop:
;Set screen border color to green
.C:46ba  A9 05       LDA GREEN_COLOR
.C:46bc  8D 20 D0    STA vic_border_color_register
;Loop forever
.C:46bf  4C BA 46    JMP hang_loop
;===========================================
; Send command to disk drive
;
; A command has a code byte (indicating the operation),
; a track number and a sector number.
;
; Arguments: .A				operation
;			command_track	track number
;			command_sector 	sector number
;===========================================
command_track = $4753
command_sector = $4754

send_command_to_drive:
.C:46c2  48          PHA
;Set ATN OUT and DATA OUT (bits 3 and 5), synchronize with drive
.C:46c3  A9 24       LDA #$24					
.C:46c5  8D 00 DD    STA cia2_port_a_data_register
.C:46c8  20 DC 46    JSR sync_with_drive
;Send command bytes (track, sector, operation)
.C:46cb  AD 53 47    LDA command_track
.C:46ce  20 23 47    JSR send_byte_over_serial
.C:46d1  AD 54 47    LDA command_sector
.C:46d4  20 23 47    JSR send_byte_over_serial
.C:46d7  68          PLA
.C:46d8  20 23 47    JSR send_byte_over_serial
.C:46db  60          RTS
;===========================================
; Synchronize with the disk drive before starting
; serial bus transmissions.
;
; Waits until CLOCK IN is clear in the serial bus,
; then sets ATN OUT.
;===========================================
busy_wait_1_cnt = #$28
busy_wait_2_cnt = #$06
CLOCK_IN_set = #$40
ATN_OUT_set = #$0C ;#0C = 00001100 - TXD, ATN OUT set

sync_with_drive:
.C:46dc  A0 28       LDY busy_wait_1_cnt
;Busy wait
sync_wait_1:
.C:46de  88          DEY
.C:46df  D0 FD       BNE sync_wait_1
;Wait for CLOCK IN to clear
.C:46e1  A9 40       LDA CLOCK_IN_set			
wait_for_CLOCK_IN_clear:
.C:46e3  2C 00 DD    BIT cia2_port_a_data_register
.C:46e6  F0 FB       BEQ wait_for_CLOCK_IN_clear
;Set ATN OUT
.C:46e8  A9 0C       LDA ATN_OUT_set			
.C:46ea  8D 00 DD    STA cia2_port_a_data_register
;Busy wait
.C:46ed  A0 06       LDY busy_wait_2_cnt
sync_wait_2:
.C:46ef  88          DEY
.C:46f0  D0 FD       BNE sync_wait_2
.C:46f2  60          RTS
;===========================================
; Receive byte from serial port
;
; Reads a whole byte into a helper variable (serial_byte).

; Returns byte read in .A
;===========================================
serial_byte = $4752
recv_byte_from_serial:
.C:46f3  20 03 47    JSR recv_bit_pair_from_serial
.C:46f6  20 03 47    JSR recv_bit_pair_from_serial
.C:46f9  20 03 47    JSR recv_bit_pair_from_serial
.C:46fc  20 03 47    JSR recv_bit_pair_from_serial
.C:46ff  AD 52 47    LDA serial_byte
.C:4702  60          RTS
;===========================================
; Receives 2 bits over the serial bus
;
; Uses an input/output helper variable (serial_byte).
; Will rotate 2 read bits LEFT into the helper,
; so successive calls will keep reading more bits into it (from MSB to LSB).
;===========================================
serial_byte = $4752

CLOCKOUT_set = #$1C		;Note: ATNOUT is set
CLOCKOUT_clear = #$0C	;Note: ATNOUT is set

; Of the serial bus signals, CLOCK OUT is used for acknowledging a bit received.
; DATA IN is used to indicate the value of the bit transmitted.
; CLOCK OUT is bit 4, DATA IN is bit 7.
; To signal acknowledgement, CLOCK OUT needs to be flipped from its previous state.

recv_bit_pair_from_serial:
;Save bitmask with CLOCK OUT set and ATN OUT set into .Y
.C:4703  A0 1C       LDY CLOCKOUT_ATNOUT_set		
;Read DATA IN (technically, we read 8 signals including DATA IN)
.C:4705  AD 00 DD    LDA cia2_port_a_data_register		
;Set CLOCK OUT and ATN OUT
.C:4708  8C 00 DD    STY cia2_port_a_data_register
;Rotate bit of DATA IN into serial_byte
.C:470b  2A          ROL A				;Rotate DATA IN to carry
.C:470c  2E 52 47    ROL serial_byte	;Rotate carry into serial_byte
;Busy wait
.C:470f  98          TYA
.C:4710  48          PHA
.C:4711  98          TYA
.C:4712  68          PLA
.C:4713  98          TYA
;Repeat same logic as before, but with CLOCK OUT clear
;Save bitmask with CLOCK OUT clear and ATN OUT set into .Y
.C:4714  A0 0C       LDY CLOCKOUT_clear		
;Read DATA IN
.C:4716  AD 00 DD    LDA cia2_port_a_data_register		
;Clear CLOCK OUT
.C:4719  8C 00 DD    STY cia2_port_a_data_register
;Rotate DATA IN into serial_byte
.C:471c  2A          ROL A				;Rotate DATA IN to carry
.C:471d  2E 52 47    ROL serial_byte	;Rotate carry into serial_byte
;Busy wait
.C:4720  98          TYA
.C:4721  A8          TAY
.C:4722  60          RTS
;===========================================
; Sends byte over serial port
;
; Sends a whole byte over the serial port.
; Arguments: .A byte to be sent
;===========================================
serial_byte = $4752

send_byte_over_serial:
.C:4723  8D 52 47    STA serial_byte
.C:4726  20 33 47    JSR send_bit_pair_over_serial
.C:4729  20 33 47    JSR send_bit_pair_over_serial
.C:472c  20 33 47    JSR send_bit_pair_over_serial
.C:472f  20 33 47    JSR send_bit_pair_over_serial
.C:4732  60          RTS
;===========================================
; Sends 2 bits over the serial bus
;
; Uses an input/output helper variable (serial_byte).
; Will rotate 2 bits LEFT from the helper into the carry,
; so successive calls will keep sending more bits into it (from MSB to LSB).
;===========================================
serial_byte = $4752

; Of the serial bus signals, CLOCK OUT is used for acknowledging a bit transmission.
; DATA OUT is used to indicate the value of the bit transmitted.
; CLOCK OUT is bit 4, DATA OUT is bit 5.
; To signal acknowledgement, CLOCK OUT needs to be flipped from its previous state.

send_bit_pair_over_serial:
;Select the correct bitmask for bit transmission, based on the bit rotated from the input variable into the carry
;If the bit is clear, use the bitmask with DATA OUT clear
;If the bit is set, use the bitmask with DATA OUT set
;In both cases, CLOCK OUT is set to 1
.C:4733  A0 1C       LDY #$1C			;00011100	- DATA OUT = 0, CLOCK OUT = 1
.C:4735  2E 52 47    ROL serial_byte
.C:4738  90 02       BCC set_signals_on_bus_1
.C:473a  A0 3C       LDY #$3C			;00111100   - DATA OUT = 1, CLOCK OUT = 1
set_signals_on_bus_1:
.C:473c  8C 00 DD    STY cia2_port_a_data_register
; Busy wait
.C:473f  8A          TXA
.C:4740  98          TYA
.C:4741  8A          TXA
.C:4742  A8          TAY
; Same logic as before, but bitmasks now have CLOCK OUT clear
.C:4743  A0 0C       LDY #$0C			;00001100   - DATA OUT = 0, CLOCK OUT = 0
.C:4745  2E 52 47    ROL serial_byte
.C:4748  90 02       BCC set_signals_on_bus_2
.C:474a  A0 2C       LDY #$2C			;00101100   - DATA OUT = 1, CLOCK OUT = 0
set_signals_on_bus_2:
.C:474c  8C 00 DD    STY cia2_port_a_data_register
; Busy wait
.C:474f  8A          TXA
.C:4750  A8          TAY
.C:4751  60          RTS
;===========================================
.C:4752  00          BRK
.C:4753  45 49       EOR $49
voice_freq_register_offsets:
.C:4755  00 07 0E 15
voice_pwm_register_offsets:
.C:4759 02 09 10       
set_bitmasks:
.C:475c  01 02 04 08 10 20 40          
clear_bitmasks:
.C:4763  FE FD FB F7 EF DF BF 00    
volume_control_reg_copy 476A	;paired with D418 register (volume, voice 3 and filter enablement)
.C:476b  00          BRK
.C:476c  00          BRK
.C:476d  00          BRK
.C:476e  00          BRK
.C:476f  00          BRK
.C:4770  00          BRK
.C:4771  00          BRK
.C:4772  FF FF FF    ISB $FFFF,X
.C:4775  FF FF FF    ISB $FFFF,X
.C:4778  FF 00 00    ISB $0000,X
.C:477b  00          BRK
.C:4819  00          BRK
.C:481a  00          BRK
;===========================================
x_saved = $480d

sound_irq_handler:
;If sound processing is disabled, return
.C:481b  AD 19 48    LDA sound_processing_disabled
.C:481e  F0 01       BEQ entry
.C:4820  60          RTS
entry:
;If new sound instructions are not allowed, skip this section
.C:4821  AD 71 FE    LDA new_sound_instructions_allowed
.C:4824  F0 14       BEQ check_any_voice_in_execution
;----------------------------------------------------
;Check if there are any new sounds to start 
.C:4826  A2 06       LDX #$06
check_if_sounds_needs_to_start:
.C:4828  BD 72 47    LDA sound_id_to_start_on_voice,X
;Is there a sound to start? If not (#FF), skip to the next voice
.C:482b  C9 FF       CMP #$FF
.C:482d  F0 03       BEQ next_sound
;Sound needs to be started
.C:482f  20 39 49    JSR start_sound_for_voice
next_sound:
.C:4832  CA          DEX
.C:4833  10 F3       BPL check_if_sounds_needs_to_start
;----------------------------------------------------
;We completed a round of sound start checks - now disable new sound instructions
.C:4835  A9 00       LDA #$00
.C:4837  8D 71 FE    STA new_sound_instructions_allowed
check_any_voice_in_execution:
;Are there any voices executing sound instructions? If not, return
.C:483a  AD 0C 48    LDA voices_executing_instruction
.C:483d  D0 01       BNE apply_duration_to_voices
.C:483f  60          RTS
;----------------------------------------------------
;There are voices in use, so apply duration/glissando to each active voice
apply_duration_to_voices:
.C:4840  A2 06       LDX #$06
check_voice_execution:
.C:4842  AD 0C 48    LDA voices_executing_instruction
;Check if voice is active
.C:4845  3D 5C 47    AND set_bitmasks,X
;If not, skip to the next voice
.C:4848  F0 06       BEQ next_voice
;Apply duration and glissando to the active voice
.C:484a  20 1B 4A    JSR apply_duration_and_glissando
;.X was saved by apply_duration_and_glissando into x_saved
.C:484d  AE 0D 48    LDX x_saved
next_voice:
.C:4850  CA          DEX
.C:4851  10 EF       BPL check_voice_execution
;----------------------------------------------------
;Are we doing voice arpeggio?
.C:4853  AD 62 51    LDA arpeggio_active_1
;If not, skip this part
.C:4856  F0 35       BEQ set_voice_control_to_voices
;Voice arpeggio enabled
;Swap current setting 0 with alternate setting 0
.C:4858  A2 00       LDX #$00
.C:485a  A0 00       LDY #$00
.C:485c  20 A5 51    JSR swap_voice_settings
;Mark arpeggio as ongoing (so the regular frequency change doesn't apply)
.C:485f  A9 FF       LDA #$FF
.C:4861  8D 60 51    STA arpeggio_ongoing
;Apply duration/glissando to voice 0
.C:4864  A2 00       LDX #$00
.C:4866  20 1B 4A    JSR apply_duration_and_glissando
;Swap current setting 0 with alternate setting 0
.C:4869  A2 00       LDX #$00
.C:486b  A0 00       LDY #$00
.C:486d  20 A5 51    JSR swap_voice_settings
;Do we need to do another arpeggio?
.C:4870  AD 61 51    LDA arpeggio_active_2
.C:4873  F0 13       BEQ enable_freq_and_envelope_change
;Swap current setting 4 with alternate setting 1
.C:4875  A2 04       LDX #$04
.C:4877  A0 01       LDY #$01
.C:4879  20 A5 51    JSR swap_voice_settings
;Apply duration/glissando to voice 4
.C:487c  A2 04       LDX #$04
.C:487e  20 1B 4A    JSR apply_duration_and_glissando
;Swap current setting 4 with alternate setting 1
.C:4881  A2 04       LDX #$04
.C:4883  A0 01       LDY #$01
.C:4885  20 A5 51    JSR swap_voice_settings
enable_freq_and_envelope_change:
;Stop marking arpeggio as ongoing (so the regular frequency applies again)
.C:4888  A9 00       LDA #$00
.C:488a  8D 60 51    STA arpeggio_ongoing
;----------------------------------------------------
set_voice_control_to_voices:
.C:488d  A2 06       LDX #$06
check_voice_execution:
.C:488f  8E 0D 48    STX x_saved
.C:4892  AD 0C 48    LDA voices_executing_instruction
.C:4895  3D 5C 47    AND set_bitmasks,X
.C:4898  F0 03       BEQ next_voice_2
.C:489a  20 0D 4C    JSR set_voice_control
next_voice_2:
.C:489d  AE 0D 48    LDX x_saved
.C:48a0  CA          DEX
.C:48a1  10 EC       BPL check_voice_execution
;----------------------------------------------------
;Is there music playback in progress? If not, exit
.C:48a3  AD 16 48    LDA music_playback_in_progress
.C:48a6  F0 2B       BEQ exit
;Copy the sound resource for the music to music_to_start_ptr
.C:48a8  AE A3 FE    LDX music_index
.C:48ab  BD C5 78    LDA sound_rsrc_ptrs_hi,X
.C:48ae  8D A1 FE    STA <music_to_start_ptr
.C:48b1  BD 0B 79    LDA sound_rsrc_ptrs_lo,X
.C:48b4  8D A2 FE    STA >music_to_start_ptr
;Is the music to start the same as the music in progress?
;If so, jump to the music code and then exit
;If not, setup the music pointers
.C:48b7  AD A1 FE    LDA <music_to_start_ptr
.C:48ba  CD 7D 54    CMP <music_in_progress_ptr
.C:48bd  D0 0E       BNE setup_music_pointers
.C:48bf  AD A2 FE    LDA >music_to_start_ptr
.C:48c2  CD 7C 54    CMP >music_in_progress_ptr
.C:48c5  D0 06       BNE setup_music_pointers
.C:48c7  20 D4 48    JSR jump_to_music_code
.C:48ca  4C D3 48    JMP exit
setup_music_pointers:
.C:48cd  20 76 4C    JSR setup_music_pointers
.C:48d0  20 D4 48    JSR jump_to_music_code
exit:
.C:48d3  60          RTS
;===========================================
jump_to_music_code:
inlined_music_address = $48d5
.C:48d4  20 00 00    JSR $0000		;Inlined address
.C:48d7  60          RTS
;===========================================
init_sound_voices:
;Set voices #1-#3 off, disable sound filters
.C:48d8  A9 00       LDA #$00
.C:48da  8D 04 D4    STA voice1_control_register
.C:48dd  8D 0B D4    STA voice2_control_register
.C:48e0  8D 12 D4    STA voice3_control_register
.C:48e3  8D 17 D4    STA filter_control_register
.C:48e6  8D 15 D4    STA filter_cutoff_freq_lo_reg
.C:48e9  8D 16 D4    STA filter_cutoff_freq_hi_reg
;Set volume to max, disable filter pass selections (low, high, band)
.C:48ec  A9 0F       LDA #$0F
.C:48ee  8D 18 D4    STA volume_control_register
.C:48f1  8D 6A 47    STA volume_control_reg_copy
.C:48f4  20 76 4C    JSR setup_music_pointers
init_more_sound:
.C:48f7  A2 06       LDX #$06
stop_voice_loop:
.C:48f9  8A          TXA
.C:48fa  20 C7 50    JSR stop_voice
.C:48fd  AA          TAX
.C:48fe  CA          DEX
.C:48ff  10 F8       BPL stop_voice_loop
;Init variables
.C:4901  A9 00       LDA #$00
.C:4903  8D 16 48    STA music_playback_in_progress
.C:4906  20 3E 51    JSR clear_refcount_of_sounds_1_and_2
.C:4909  A9 00       LDA #$00
.C:490b  8D 18 48    STA music_voices_in_use_2
.C:490e  A9 00       LDA #$00
.C:4910  8D 17 48    STA music_voices_in_use
.C:4913  A9 03       LDA #$03
.C:4915  8D FF 4C    STA total_real_voices_available
.C:4918  A9 00       LDA #$00
.C:491a  8D 62 51    STA arpeggio_active_1
.C:491d  A9 00       LDA #$00
.C:491f  8D 64 51    STA filter_enable_flag
.C:4922  A9 00       LDA #$00
.C:4924  8D 61 51    STA arpeggio_active_2
.C:4927  A9 00       LDA #$00
.C:4929  8D 63 51    STA $5163
.C:492c  AD A2 FE    LDA >music_to_start_ptr
.C:492f  8D 7C 54    STA >music_in_progress_ptr
.C:4932  AD A1 FE    LDA <music_to_start_ptr
.C:4935  8D 7D 54    STA <music_in_progress_ptr
.C:4938  60          RTS
;===========================================
; Starts a sound for a specific voice.
;
; Arg: .X voice index
;
;	Returns:	#01	if sound not in memory
;===========================================
active_voice = $480d

start_sound_for_voice:
.C:4939  A8          TAY
;Save sound resource index for the current voice
.C:493a  BD 72 47    LDA sound_id_to_start_on_voice,X
.C:493d  9D 9C 47    STA rsrc_for_voice_0,X
;Clear out the starting information (to avoid further repetitions of the start)
.C:4940  A9 FF       LDA #$FF
.C:4942  9D 72 47    STA sound_id_to_start_on_voice,X
;Initialize instruction repeat counter
.C:4945  A9 00       LDA #$00
.C:4947  9D AA 47    STA instruction_repeat_counter,X
;-----------------------------------
;Check if .X < 3 - if so, set x_lower_than_3 to #FF (true)
;Otherwise, set x_lower_than_3 to #00 (false)
.C:494a  A9 FF       LDA #$FF
.C:494c  E0 03       CPX #$03
.C:494e  30 02       BMI set_x_lower_than_3_flag
.C:4950  A9 00       LDA #$00
set_x_lower_than_3_flag:
.C:4952  8D 11 48    STA x_lower_than_3
;-----------------------------------
;Save active voice index
.C:4955  8E 0D 48    STX active_voice
;Load voice instruction offset from the voice data offsets (which were set up in start_sound)
.C:4958  BD 8E 47    LDA voice_data_offsets_hi,X
.C:495b  9D 05 48    STA voice_instruction_offset_hi,X
.C:495e  BD 87 47    LDA voice_data_offsets_lo,X
.C:4961  9D FE 47    STA voice_instruction_offset_lo,X
;Update voice's base address and instruction pointer
.C:4964  20 1C 4C    JSR update_voice_base_and_instruction_ptr
;-------------------------------------------
;Update voice_data_base with the latest values
.C:4967  AD 15 48    LDA <voice_base
.C:496a  9D 79 47    STA voice_data_base_lo,X
.C:496d  AD 14 48    LDA >voice_base
.C:4970  9D 80 47    STA voice_data_base_hi,X
;-------------------------------------------
;More pointer adjustments (I think there's redundant pointer adjustment logic in this area)
; voice_instruction_ptr = voice_base_addr + voice_instruction_offset
; Also, copy it to voice_read_ptr
.C:4973  BD 79 47    LDA voice_data_base_lo,X
.C:4976  9D F0 47    STA voice_base_addr_lo,X
.C:4979  18          CLC
.C:497a  7D FE 47    ADC voice_instruction_offset_lo,X
.C:497d  9D B8 47    STA voice_instruction_ptr_lo,X
.C:4980  85 BA       STA <voice_read_ptr
;Check that the hi byte is non-zero - if not, continue with the hi byte
.C:4982  BD 80 47    LDA voice_data_base_hi,X
.C:4985  D0 07       BNE set_hi_bytes
;-------------------------------------------
;Hi byte is #00 - sound not in memory
.C:4987  8A          TXA
;Stop playback immediately
.C:4988  20 A4 50    JSR stop_sound_simple
;Return #01
.C:498b  A9 01       LDA #$01
.C:498d  60          RTS
;-------------------------------------------
;Finalize the pointer setup, now with the hi byte
set_hi_bytes:
.C:498e  9D F7 47    STA voice_base_addr_hi,X
.C:4991  7D 05 48    ADC voice_instruction_offset_hi,X
.C:4994  9D BF 47    STA voice_instruction_ptr_hi,X
.C:4997  85 BB       STA >voice_read_ptr
;-------------------------------------------
;This is an alternate variant of .X > 3 (instead doing .X >= 4)
;The result is set in .Y (#FF if .X > 3, #00 otherwise)
.C:4999  A0 FF       LDY #$FF
;X >= #04? If so, skip to move_pointers
.C:499b  E0 04       CPX #$04
.C:499d  10 38       BPL move_pointers
;Set .Y = 00
.C:499f  C8          INY
;-------------------------------------------
;Is .X == 3?
.C:49a0  E0 03       CPX #$03
.C:49a2  D0 06       BNE check_voice_control_change
;X == #03 - set filter and volume control
;Voice index #03 is a special voice reserved for setting filters and volume
.C:49a4  20 E7 49    JSR set_filter_and_volume_control
.C:49a7  4C D7 49    JMP move_pointers
check_voice_control_change:
;Is this voice in use by music? If not, set voice control
.C:49aa  AD 17 48    LDA music_voices_in_use
.C:49ad  3D 5C 47    AND set_bitmasks,X
.C:49b0  F0 04       BEQ set_voice_control
;It is - don't set voice control, skip next byte
.C:49b2  C8          INY
.C:49b3  4C D7 49    JMP move_pointers
;---------------------------------------------
; Voice control + filter enable/disable for voice
;
; Read 2 bytes - First byte is voice control
; Second byte - Filter control
;		If low nibble is #00, disable filter for this voice
;		Otherwise, enable filter for this voice
;---------------------------------------------
set_voice_control:
.C:49b6  B1 BA       LDA (voice_read_ptr),Y
.C:49b8  9D B1 47    STA voice_controls,X
;Read byte from next position
.C:49bb  C8          INY
.C:49bc  B1 BA       LDA (voice_read_ptr),Y
;Is low nibble zero?
.C:49be  29 0F       AND #$0F
.C:49c0  F0 09       BEQ clear_filter_bit
;Low nibble nonzero, set the bit in the filter control bitmask
.C:49c2  AD 6B 47    LDA filter_control_reg_copy
.C:49c5  1D 5C 47    ORA set_bitmasks,X
.C:49c8  4C D1 49    JMP set_filter_value
;Low nibble zero, clear the bit in the filter control bitmask
clear_filter_bit:
.C:49cb  AD 6B 47    LDA filter_control_reg_copy
.C:49ce  3D 63 47    AND clear_bitmasks,X
set_filter_value:
.C:49d1  8D 6B 47    STA filter_control_reg_copy
.C:49d4  8D 17 D4    STA filter_control_register
;---------------------------------------------
move_pointers:
.C:49d7  20 FC 49    JSR update_instruction_ptr_and_offset
;Mark the voice as executing instructions
.C:49da  AD 0C 48    LDA voices_executing_instruction
.C:49dd  1D 5C 47    ORA set_bitmasks,X
.C:49e0  8D 0C 48    STA voices_executing_instruction
;Process instructions for this voice
.C:49e3  20 6B 4A    JSR process_voice_instructions
.C:49e6  60          RTS
;===========================================
; Set filter and volume control, by reading 2 bytes
; from the read pointer.
;===========================================
set_filter_and_volume_control:
.C:49e7  B1 BA       LDA (voice_read_ptr),Y
.C:49e9  0D 6B 47    ORA filter_control_reg_copy
.C:49ec  8D 6B 47    STA filter_control_reg_copy
.C:49ef  8D 17 D4    STA filter_control_register
.C:49f2  C8          INY
.C:49f3  B1 BA       LDA (voice_read_ptr),Y
.C:49f5  8D 6A 47    STA volume_control_reg_copy		
.C:49f8  8D 18 D4    STA volume_control_register
.C:49fb  60          RTS
;===========================================
; Updates voice instruction pointer and offset after doing read operations.
;
; .Y is the index of last byte read from the pointer
; First, .Y is increased by 1 (to point to the next byte to be read).
; It then adds .Y to both voice_instruction_ptr and voice_instruction_offset.
;===========================================
update_instruction_ptr_and_offset:
.C:49fc  AE 0D 48    LDX active_voice
;Increment read offset by 1 (to point to the next byte)
.C:49ff  C8          INY
;Add read offset to voice_instruction_ptr
.C:4a00  98          TYA
.C:4a01  18          CLC
.C:4a02  7D B8 47    ADC voice_instruction_ptr_lo,X
.C:4a05  9D B8 47    STA voice_instruction_ptr_lo,X
.C:4a08  90 03       BCC update_offset
.C:4a0a  FE BF 47    INC voice_instruction_ptr_hi,X
update_offset:
;Add read offset to voice_instruction_offset
.C:4a0d  98          TYA
.C:4a0e  18          CLC
.C:4a0f  7D FE 47    ADC voice_instruction_offset_lo,X
.C:4a12  9D FE 47    STA voice_instruction_offset_lo,X
.C:4a15  90 03       BCC exit
.C:4a17  FE 05 48    INC voice_instruction_offset_hi,X
exit:
.C:4a1a  60          RTS
;===========================================
; Apply sound duration and glissando for a logical voice.
; For reference, a duration of 0100 takes approximately 4 seconds.
; So the maximum time for a single sound _instruction_
; to play would be 4 * 256 = 1024 seconds or roughly 17 minutes.
; This can be extended further using instruction repetitions.
;
; Arguments: .X voice index
;===========================================
x_saved = $480d

apply_duration_and_glissando:
;-----------------------------------
;Check if .X < 3 - if so, set x_lower_than_3 to #FF (true)
;Otherwise, set x_lower_than_3 to #00 (false)
.C:4a1b  A9 FF       LDA #$FF
.C:4a1d  E0 03       CPX #$03
.C:4a1f  30 02       BMI set_result
.C:4a21  A9 00       LDA #$00
set_result:
.C:4a23  8D 11 48    STA x_lower_than_3
;-----------------------------------
;Save .X so caller can restore it
.C:4a26  8E 0D 48    STX x_saved
;Subtract 1 from duration_lo
.C:4a29  BD D4 47    LDA sound_duration_lo,X
.C:4a2c  38          SEC
.C:4a2d  E9 01       SBC #$01
.C:4a2f  9D D4 47    STA sound_duration_lo,X
;If carry is set, duration countdown still ongoing
.C:4a32  B0 11       BCS do_glissando
;Carry is clear, so subtract from duration_hi
.C:4a34  BD DB 47    LDA sound_duration_hi,X
.C:4a37  E9 00       SBC #$00
.C:4a39  9D DB 47    STA sound_duration_hi,X
;If carry is set, duration countdown still ongoing
.C:4a3c  B0 07       BCS do_glissando
;Duration countdown expired - process next sound instruction
.C:4a3e  20 6B 4A    JSR process_voice_instructions
.C:4a41  20 E6 4B    JSR set_voice_frequency_and_envelope
.C:4a44  60          RTS
;-----------------------------------
do_glissando:
;Add glissando to the voice frequency
.C:4a45  BD C6 47    LDA voice_frequencies_lo,X
.C:4a48  18          CLC
.C:4a49  7D E2 47    ADC glissando_lo,X
.C:4a4c  9D C6 47    STA voice_frequencies_lo,X
.C:4a4f  BD CD 47    LDA voice_frequencies_hi,X
.C:4a52  7D E9 47    ADC glissando_hi,X
.C:4a55  9D CD 47    STA voice_frequencies_hi,X
;Update voice frequency
.C:4a58  20 E6 4B    JSR set_voice_frequency_and_envelope
.C:4a5b  60          RTS
;===========================================
; Clear sound duration and glissando for a logical voice
;
; Arguments: .X voice index
;===========================================
clear_duration_and_glissando:
.C:4a5c  A9 00       LDA #$00
.C:4a5e  9D D4 47    STA sound_duration_lo,X
.C:4a61  9D DB 47    STA sound_duration_hi,X
.C:4a64  9D E2 47    STA glissando_lo,X
.C:4a67  9D E9 47    STA glissando_hi,X
.C:4a6a  60          RTS
;===========================================
; Process voice instructions
;
; This is the main decoder and executor of voice instructions.
; Instructions can be either repeatable or not.
; If an instruction is repeatable, a running count is started,
; and the routine processes the same instruction repeatedly until the count is over.
; After a repeatable instruction count is over, another instruction is read and executed.
;
; After the first non-repeatable instruction is executed, the routine returns.
;
; Repeatable instructions need to supply two operands:
;		-a repeat count
;		-an offset
;
; The offset is supposed to be a positive number, which gets subtracted from the
; instruction read pointer. Thus going back to previous data, from which the next instruction 
; will be processed (again). If the offset is misconfigured, obviously things will break.
;
; Summary of bit meanings
; =======================
;
; Bit 0 - trigger/release note (bit set = trigger, bit clear = release)
; Bit 1 - bit set - stop voice
; Bit 2 - change frequency, duration, glissando
;		-bit clear - clear duration and glissando
;		-bit set
;				-Read 2 bytes - set frequency
;				-Test bit 6 of original instruction
;					-Bit 6 set 
;						-clear duration and glissando
;					-Bit 6 clear 
;						-read 2 bytes - set as duration
;						-read another 2 bytes - set as glissando
; Bit 3 - change ADSR
;		-Bit set - change ADSR
;			-Read 2 bytes - set as ADSR
;			-Repeat note action (trigger/release)
; Bit 4 - change PWM (pulse width modulation), filter cutoff frequency, duration
;		-Read a byte -> instruction_operand
;			Bit 0 set - set PWM (read 2 bytes as value)
;			Bit 1 set - set filter cutoff frequency (read 2 bytes as value)
;			Bit 2 set - set duration (read 2 bytes as duration)
; Bit 5 - change waveform
;			-Read 1 byte as waveform bitmask 
;			-OR the waveform bitmask into voice control
; Bit 6 - used by the "bit 2" section to enable/disable duration/glissando changes (already explained)
; Bit 7 - repetitions
;		-Details are explained in the relevant section
;===========================================
temp_y = $4813
voice_index = $480d
instruction_shifter = $480e
instruction_operand = $480f
instruction_original = $4810

process_voice_instructions:
.C:4a6b  AE 0D 48    LDX voice_index
.C:4a6e  20 1C 4C    JSR update_voice_base_and_instruction_ptr
;Check return value - if it's #01, then sound pointers are not correct (sound evicted? stopped?)
.C:4a71  C9 01       CMP #$01
.C:4a73  D0 04       BNE sound_in_memory
;Sound not loaded in memory - stop playback and return
.C:4a75  20 A4 50    JSR stop_sound_simple
.C:4a78  60          RTS
;--------------------------------------------
sound_in_memory:
;Set voice_read_ptr = voice_instruction_ptr
.C:4a79  BD B8 47    LDA voice_instruction_ptr_lo,X
.C:4a7c  85 BA       STA <voice_read_ptr
.C:4a7e  BD BF 47    LDA voice_instruction_ptr_hi,X
.C:4a81  85 BB       STA >voice_read_ptr
;4812 = #FF (not used anywhere in the main code)
.C:4a83  A9 FF       LDA #$FF
.C:4a85  8D 12 48    STA $4812
;.Y = read offset
.C:4a88  A0 00       LDY #$00
;Read the instruction byte
.C:4a8a  B1 BA       LDA (voice_read_ptr),Y
.C:4a8c  D0 09       BNE instruction_present
;--------------------------------------------
;Byte is zero
;4812 = #00 (not used anywhere in the main code)
.C:4a8e  8D 12 48    STA $4812
;Clear repeat count
.C:4a91  9D AA 47    STA instruction_repeat_counter,X
.C:4a94  4C BC 4A    JMP cut_voice
;--------------------------------------------
;Byte not zero
instruction_present:
.C:4a97  9D A3 47    STA instruction_for_voice,X
.C:4a9a  8D 0E 48    STA instruction_shifter
.C:4a9d  8D 10 48    STA instruction_original
; As x_lower_than_3 is treated as a "boolean", its possible values will be either #00 or #FF.
; So either its bits will all be 0 or all 1.
; Running the BIT instruction will set the N and V flags according to the operand.
; Specifically, if the operand has bit 7 set, N will be set and viceversa.
; Same thing for the oVerflow flag and bit 6.
;
; Testing a boolean for either bit 7 or bit 6, then, is equivalent to testing for true or false.
;
; The BIT operation will simply set/clear flags N and V.
; But the LSR operation might overwrite the N flag, so the only unaffected flag when 
; executing BIT followed by LSR will be V. This will be relevant when we test the boolean later.
.C:4aa0  2C 11 48    BIT x_lower_than_3
;Shift right once - bit 0 will go into carry (N might change)
.C:4aa3  4E 0E 48    LSR instruction_shifter
;Now we test for the V flag that was set/cleared before (in the BIT instruction)
;If x_lower_than_3 is #00 (true), .X < 3, then the trigger/release logic will apply
.C:4aa6  50 0F       BVC test_bit1
;--------------------------------------------
; Voice index < 3 - Trigger/release voice
;--------------------------------------------
;Note: LDA will NOT change the carry, which will still keep the bit shifted before
.C:4aa8  BD B1 47    LDA voice_controls,X
;Branch on carry
.C:4aab  90 05       BCC release_note
;Carry set - set bit 0 of voice control, which triggers a note
.C:4aad  09 01       ORA #$01
.C:4aaf  4C B4 4A    JMP update_control
;Carry clear - clear bit 0 of voice control, which releases the note
release_note:
.C:4ab2  29 FE       AND #$FE
update_control:
.C:4ab4  9D B1 47    STA voice_controls,X
;--------------------------------------------
test_bit1:
;Shift right once - bit 0 will go into carry
.C:4ab7  4E 0E 48    LSR instruction_shifter
.C:4aba  90 0B       BCC test_bit2
;--------------------------------------------
;Bit 1 is set - stop voice, simple mode
cut_voice:
.C:4abc  A9 FF       LDA #$FF
.C:4abe  8D 1A 48    STA stop_sound_mode
.C:4ac1  8A          TXA
.C:4ac2  20 C7 50    JSR stop_voice
.C:4ac5  AA          TAX
.C:4ac6  60          RTS
;--------------------------------------------
test_bit2:
.C:4ac7  4E 0E 48    LSR instruction_shifter
;Test the original unshifted instruction to set/clear the oVerflow bit (bit 6)
.C:4aca  2C 10 48    BIT instruction_original
.C:4acd  90 2F       BCC no_duration_or_glissando_2
;--------------------------------------------
; Bit 2 set - Set frequency + duration + glissando
;--------------------------------------------
;Read 2 bytes - set as frequency
.C:4acf  C8          INY
.C:4ad0  B1 BA       LDA (voice_read_ptr),Y
.C:4ad2  9D C6 47    STA voice_frequencies_lo,X
.C:4ad5  C8          INY
.C:4ad6  B1 BA       LDA (voice_read_ptr),Y
.C:4ad8  9D CD 47    STA voice_frequencies_hi,X
;Test the bit 6 of the original instruction value
.C:4adb  70 1B       BVS no_duration_or_glissando
;Bit 6 clear
;Read 2 bytes, set as duration
.C:4add  C8          INY
.C:4ade  B1 BA       LDA (voice_read_ptr),Y
.C:4ae0  9D D4 47    STA sound_duration_lo,X
.C:4ae3  C8          INY
.C:4ae4  B1 BA       LDA (voice_read_ptr),Y
.C:4ae6  9D DB 47    STA sound_duration_hi,X
.C:4ae9  C8          INY
;Read 2 bytes, set as glissando
.C:4aea  B1 BA       LDA (voice_read_ptr),Y
.C:4aec  9D E2 47    STA glissando_lo,X
.C:4aef  C8          INY
.C:4af0  B1 BA       LDA (voice_read_ptr),Y
.C:4af2  9D E9 47    STA glissando_hi,X
;Continue testing bit 3
.C:4af5  4C 01 4B    JMP test_bit3
;Bit 6 set, clear duration/glissando
no_duration_or_glissando:
.C:4af8  20 5C 4A    JSR clear_duration_and_glissando
.C:4afb  4C 01 4B    JMP test_bit3
;Bit 2 clear - clear duration/glissando
no_duration_or_glissando_2:
.C:4afe  20 5C 4A    JSR clear_duration_and_glissando
;--------------------------------------------
test_bit3:
;Check if .X < 3
.C:4b01  2C 11 48    BIT x_lower_than_3
.C:4b04  4E 0E 48    LSR instruction_shifter
;If .X < 3, the ADSR part doesn't apply
.C:4b07  50 2D       BVC test_bit4
.C:4b09  90 2B       BCC test_bit4
;--------------------------------------------
; Instruction bit 3 set - set ADSR envelope
;--------------------------------------------
;The logic can be summarized as:
;	-Release note
;	-Change ADSR envelop
;	-Repeat original gate action
;		-If it was a trigger note, retrigger it (with the new ADSR)
;		-If it was a release note, release it again (with the new ADSR)
;Save .Y in stack
.C:4b0b  8C 13 48    STY temp_y
;Release note (clear bit 0 of the voice control)
.C:4b0e  BD B1 47    LDA voice_controls,X
.C:4b11  29 FE       AND #$FE
.C:4b13  9D B1 47    STA voice_controls,X
.C:4b16  20 0D 4C    JSR set_voice_control
;Restore .Y from stack
.C:4b19  AC 13 48    LDY temp_y
;Read voice index
.C:4b1c  AE 0D 48    LDX voice_index
;Read 2 bytes, set as ADSR envelope for voice
.C:4b1f  C8          INY
.C:4b20  B1 BA       LDA (voice_read_ptr),Y
.C:4b22  9D 6C 47    STA voice_attack_delays,X
.C:4b25  C8          INY
.C:4b26  B1 BA       LDA (voice_read_ptr),Y
.C:4b28  9D 6F 47    STA voice_sustain_releases,X
;Read the original instruction value, mask out bit 0
;This will represent trigger note (bit set) or release note (bit clear)
.C:4b2b  BD A3 47    LDA instruction_for_voice,X
.C:4b2e  29 01       AND #$01
;OR the bit 0 into voice controls - this repeats the action (trigger or release)
;The action now takes place with the new ADSR envelope
.C:4b30  1D B1 47    ORA voice_controls,X
.C:4b33  9D B1 47    STA voice_controls,X
test_bit4:
.C:4b36  4E 0E 48    LSR instruction_shifter
.C:4b39  90 4C       BCC test_bit5
;--------------------------------------------
; Bit 4 set - an operand is needed
;--------------------------------------------
;Read the operand
.C:4b3b  C8          INY
.C:4b3c  B1 BA       LDA (voice_read_ptr),Y
.C:4b3e  8D 0F 48    STA instruction_operand
;Check if .X < 3
.C:4b41  2C 11 48    BIT x_lower_than_3
test_operand_bit0:
.C:4b44  4E 0F 48    LSR instruction_operand
;If .X < 3, the PWM part doesn't apply
.C:4b47  50 15       BVC test_operand_bit1
;Test bit 0
.C:4b49  90 13       BCC test_operand_bit1
;--------------------------------------------
; Operand bit 0 set - set PWM (pulse width modulation)
;--------------------------------------------
.C:4b4b  C8          INY
;Load the register offset for PWM control into .X
.C:4b4c  BD 59 47    LDA voice_pwm_register_offsets,X
.C:4b4f  AA          TAX
;Read 2 bytes, set as PWM control
.C:4b50  B1 BA       LDA (voice_read_ptr),Y
.C:4b52  9D 00 D4    STA voice1_freq_reg_lo,X
.C:4b55  C8          INY
.C:4b56  B1 BA       LDA (voice_read_ptr),Y
.C:4b58  9D 01 D4    STA voice1_freq_reg_hi,X
.C:4b5b  AE 0D 48    LDX voice_index
test_operand_bit1:
.C:4b5e  4E 0F 48    LSR instruction_operand
.C:4b61  90 10       BCC test_operand_bit2
;--------------------------------------------
; Operand bit 1 set - set filter cutoff settings
;--------------------------------------------
.C:4b63  C8          INY
.C:4b64  20 E7 49    JSR set_filter_and_volume_control
.C:4b67  C8          INY
.C:4b68  B1 BA       LDA (voice_read_ptr),Y
.C:4b6a  8D 15 D4    STA filter_cutoff_freq_lo_reg
.C:4b6d  C8          INY
.C:4b6e  B1 BA       LDA (voice_read_ptr),Y
.C:4b70  8D 16 D4    STA filter_cutoff_freq_hi_reg
test_operand_bit2:
.C:4b73  4E 0F 48    LSR instruction_operand
.C:4b76  90 0F       BCC test_bit5
;--------------------------------------------
; Operand bit 2 set - set duration
;--------------------------------------------
.C:4b78  20 5C 4A    JSR clear_duration_and_glissando
.C:4b7b  C8          INY
.C:4b7c  B1 BA       LDA (voice_read_ptr),Y
.C:4b7e  9D D4 47    STA sound_duration_lo,X
.C:4b81  C8          INY
.C:4b82  B1 BA       LDA (voice_read_ptr),Y
.C:4b84  9D DB 47    STA sound_duration_hi,X
test_bit5:
.C:4b87  4E 0E 48    LSR instruction_shifter
.C:4b8a  90 0B       BCC test_bit7
;--------------------------------------------
; Bit 5 set - set voice waveform, keep bits 0-3 of voice control unchanged
;--------------------------------------------
.C:4b8c  BD B1 47    LDA voice_controls,X
.C:4b8f  29 0F       AND #$0F
.C:4b91  C8          INY
.C:4b92  11 BA       ORA (voice_read_ptr),Y
.C:4b94  9D B1 47    STA voice_controls,X
test_bit7:
.C:4b97  4E 0E 48    LSR instruction_shifter
.C:4b9a  4E 0E 48    LSR instruction_shifter
.C:4b9d  90 43       BCC exit
;--------------------------------------------
;Bit 7 set - instruction repetition
;--------------------------------------------
;Check if we have reached the last repetition (#01)
;If the repetition count is #00, it means we're starting a repeat run
.C:4b9f  BD AA 47    LDA instruction_repeat_counter,X
.C:4ba2  C9 01       CMP #$01
.C:4ba4  D0 0B       BNE repetitions_pending
;--------------------------------------------
;Last repetition occurred - decrease the counter (set it to #00)
.C:4ba6  DE AA 47    DEC instruction_repeat_counter,X
;Skip the 2 bytes which store the repeat offset and repetition count
.C:4ba9  C8          INY
.C:4baa  C8          INY
;Update pointers and continue with next instruction
.C:4bab  20 FC 49    JSR update_instruction_ptr_and_offset
.C:4bae  4C DF 4B    JMP process_next_instruction
;--------------------------------------------
repetitions_pending:
;There are still repetitions pending (including when instruction_repeat_counter is still 0)
;Repetitions are handled in this manner:
;	-Read 1 byte, which constitutes an offset
;	-Subtract the offset from the playback pointer (thus going back to a previous point in the sound instructions)
;	Note: the playback and current read pointers are independent, to allow reading the next byte easily
;	-If there's an ongoing repeat count, count down 1 and continue
;	-Otherwise read another byte, which constitutes the repetition count
;
;Read 1 offset byte - subtract offset from voice_instruction_ptr
.C:4bb1  C8          INY
.C:4bb2  BD B8 47    LDA voice_instruction_ptr_lo,X
.C:4bb5  38          SEC
.C:4bb6  F1 BA       SBC (voice_read_ptr),Y
.C:4bb8  9D B8 47    STA voice_instruction_ptr_lo,X
.C:4bbb  B0 03       BCS adjust_voice_instruction_offset
.C:4bbd  DE BF 47    DEC voice_instruction_ptr_hi,X
adjust_voice_instruction_offset:
;Subtract the same offset from voice_instruction_offset
.C:4bc0  BD FE 47    LDA voice_instruction_offset_lo,X
.C:4bc3  38          SEC
.C:4bc4  F1 BA       SBC (voice_read_ptr),Y
.C:4bc6  9D FE 47    STA voice_instruction_offset_lo,X
.C:4bc9  B0 03       BCS read_repeat_count
.C:4bcb  DE 05 48    DEC voice_instruction_offset_hi,X
read_repeat_count:
.C:4bce  C8          INY
;If there's already a repeat count, just count down
.C:4bcf  BD AA 47    LDA instruction_repeat_counter,X
.C:4bd2  D0 08       BNE count_down_repeats
;If there's no repeat count yet, read a new repeat count
.C:4bd4  B1 BA       LDA (voice_read_ptr),Y
.C:4bd6  9D AA 47    STA instruction_repeat_counter,X
.C:4bd9  4C DF 4B    JMP process_next_instruction
count_down_repeats:
.C:4bdc  DE AA 47    DEC instruction_repeat_counter,X
process_next_instruction:
;Jump back to the beginning of the routine to process the next instruction
.C:4bdf  4C 6B 4A    JMP process_voice_instructions
;--------------------------------------------
;Bit 7 clear - exit
;--------------------------------------------
exit:
;Update pointer and offset and exit
.C:4be2  20 FC 49    JSR update_instruction_ptr_and_offset
.C:4be5  60          RTS
;===========================================
; Sets a physical voice frequency and envelope
;
; Arguments:	.X	logical voice index
; Note: if the voice physical index is 3, the filter cutoff frequency is copied
;===========================================
set_voice_frequency_and_envelope:
;If there's voice arpeggio ongoing, exit - arpeggio takes care of changing frequencies
.C:4be6  AD 60 51    LDA arpeggio_ongoing
.C:4be9  F0 01       BEQ change_enabled
.C:4beb  60          RTS
change_enabled:
;Load voice frequency register offset into .Y
.C:4bec  BD 55 47    LDA voice_freq_register_offsets,X
.C:4bef  A8          TAY
;Copy voice frequency
;Note: if the voice index is 3, we're actually copying the filter cutoff frequency
.C:4bf0  BD C6 47    LDA voice_frequencies_lo,X
.C:4bf3  99 00 D4    STA voice1_freq_reg_lo,Y
.C:4bf6  BD CD 47    LDA voice_frequencies_hi,X
.C:4bf9  99 01 D4    STA voice1_freq_reg_hi,Y
;If voice physical index >= 3, exit
.C:4bfc  E0 03       CPX #$03
.C:4bfe  10 0C       BPL exit
;Copy ADSR envelope for the voice
.C:4c00  BD 6C 47    LDA voice_attack_delays,X
.C:4c03  99 05 D4    STA voice1_attack_delay_reg,Y
.C:4c06  BD 6F 47    LDA voice_sustain_releases,X
.C:4c09  99 06 D4    STA voice1_sustain_release_reg,Y
exit:
.C:4c0c  60          RTS
;===========================================
; Sets a voice control
;
; Arguments:	.X	voice index
;===========================================
set_voice_control:
;If .X >= 3, exit
.C:4c0d  E0 03       CPX #$03
.C:4c0f  10 0A       BPL exit
;Get the voice index for .X
.C:4c11  BD 55 47    LDA voice_freq_register_offsets,X
.C:4c14  A8          TAY
;Set the voice control value
.C:4c15  BD B1 47    LDA voice_controls,X
.C:4c18  99 04 D4    STA voice1_control_register,Y
exit:
.C:4c1b  60          RTS
;===========================================
; Updates a voice's base address and instruction pointer
;
; Arguments:	.X	sound slot index
; Returns:		#00 if sound pointer was already set
;					and no relocation happened
;				#01 if sound resource is not in memory
;				#FF if sound pointer had to be recomputed
;					because of relocation
;===========================================
voice_base = $4815

update_voice_base_and_instruction_ptr:
;Ensure the sound resource is actually loaded in memory
.C:4c1c  BC 9C 47    LDY rsrc_for_voice_0,X
.C:4c1f  B9 C5 78    LDA sound_rsrc_ptrs_hi,Y
.C:4c22  D0 1A       BNE resource_in_memory
;-------------------------------------
sound_ptr_unset:
.C:4c24  98          TYA
.C:4c25  20 A4 50    JSR stop_sound_simple
.C:4c28  CD F1 4C    CMP sound_starting
.C:4c2b  D0 0E       BNE return_01
.C:4c2d  A9 00       LDA #$00
.C:4c2f  8D F1 4C    STA sound_starting
.C:4c32  8D F2 4C    STA starting_sound_with_priority_1
.C:4c35  8D 62 51    STA arpeggio_active_1
.C:4c38  8D 61 51    STA arpeggio_active_2
return_01:
.C:4c3b  A9 01       LDA #$01
.C:4c3d  60          RTS
;-------------------------------------
resource_in_memory:
;Copy the sound resource pointer to voice_base
.C:4c3e  8D 14 48    STA >voice_base
.C:4c41  B9 0B 79    LDA sound_rsrc_ptrs_lo,Y
.C:4c44  8D 15 48    STA <voice_base
;Check that voice_base and voice_base_addr actually match
;They might not match if there has been a relocation
.C:4c47  DD F0 47    CMP voice_base_addr_lo,X
.C:4c4a  D0 0B       BNE adjust
.C:4c4c  AD 14 48    LDA >voice_base
.C:4c4f  DD F7 47    CMP voice_base_addr_hi,X
.C:4c52  D0 03       BNE adjust
return_00:
;They match, return #00
.C:4c54  A9 00       LDA #$00
.C:4c56  60          RTS
adjust:
;They didn't match, so we have to readjust addresses
;Reset voice_base_addr = voice_base
.C:4c57  AD 14 48    LDA >voice_base
.C:4c5a  9D F7 47    STA voice_base_addr_hi,X	
.C:4c5d  AD 15 48    LDA <voice_base
.C:4c60  9D F0 47    STA voice_base_addr_lo,X
;Add offsets to recalculate voice_instruction_ptr
.C:4c63  18          CLC
.C:4c64  7D FE 47    ADC voice_instruction_offset_lo,X		
.C:4c67  9D B8 47    STA voice_instruction_ptr_lo,X
.C:4c6a  AD 14 48    LDA >voice_base
.C:4c6d  7D 05 48    ADC voice_instruction_offset_hi,X		
.C:4c70  9D BF 47    STA voice_instruction_ptr_hi,X
return_ff:
.C:4c73  A9 FF       LDA #$FF
.C:4c75  60          RTS
;===========================================
setup_music_pointers:
.C:4c76  8A          TXA
.C:4c77  48          PHA
;Compute each music track pointer: 
; music_track_ptrs = music_to_start_ptr + music_track_offsets
.C:4c78  A2 08       LDX #$08
music_track_ptr_loop:
;Compute lo
.C:4c7a  BD 7E 54    LDA music_track_offsets_lo,X
.C:4c7d  18          CLC
.C:4c7e  6D A2 FE    ADC >music_to_start_ptr
.C:4c81  9D 90 54    STA music_track_ptrs_lo,X
;Compute hi
.C:4c84  BD 87 54    LDA music_track_offsets_hi,X
.C:4c87  6D A1 FE    ADC <music_to_start_ptr
.C:4c8a  9D 99 54    STA music_track_ptrs_hi,X
;Next track
.C:4c8d  CA          DEX
.C:4c8e  10 EA       BPL music_track_ptr_loop
;---------------------------
;inlined_music_address = music_to_start_ptr + #14D
.C:4c90  AD A2 FE    LDA >music_to_start_ptr
.C:4c93  8D 7C 54    STA >music_in_progress_ptr
.C:4c96  18          CLC
.C:4c97  69 4D       ADC #$4D
.C:4c99  8D D5 48    STA <inlined_music_address
.C:4c9c  AD A1 FE    LDA <music_to_start_ptr
.C:4c9f  8D 7D 54    STA <music_in_progress_ptr
.C:4ca2  69 01       ADC #$01
.C:4ca4  8D D6 48    STA >inlined_music_address
.C:4ca7  68          PLA
.C:4ca8  AA          TAX
.C:4ca9  60          RTS
;===========================================
; Stop music
;===========================================
stop_music:
;Stop playback
.C:4caa  A9 00       LDA #$00
.C:4cac  8D 18 48    STA music_voices_in_use_2
.C:4caf  8D 16 48    STA music_playback_in_progress
;
.C:4cb2  20 3E 51    JSR clear_refcount_of_sounds_1_and_2
.C:4cb5  AE 59 54    LDX $5459
.C:4cb8  AE 6D 54    LDX $546D
.C:4cbb  F0 03       BEQ reset_voice_priorities
.C:4cbd  20 DA 4C    JSR decrease_sound_memory_attribute
reset_voice_priorities:
.C:4cc0  A9 02       LDA #$02
.C:4cc2  8D 95 47    STA voice_priority_0
.C:4cc5  8D 96 47    STA voice_priority_1
.C:4cc8  8D 97 47    STA voice_priority_2
;Clear voices in use
.C:4ccb  A9 00       LDA #$00
.C:4ccd  8D 17 48    STA music_voices_in_use
.C:4cd0  8D 67 54    STA $5467
.C:4cd3  8D 68 54    STA $5468
.C:4cd6  8D 69 54    STA $5469
.C:4cd9  60          RTS
;===========================================
; Decrease the memory attribute count for a sound resource.
; This keeps the original sign (bit 7) of the previous value.
;
; Arguments:	.X		sound resource ID
;===========================================
decrease_sound_memory_attribute:
;Load the memory attribute for this sound
.C:4cda  BD 51 79    LDA sound_memory_attrs,X
;Save flags in stack - specifically, flag N (bit 7) is relevant
.C:4cdd  08          PHP
;Clear bit 7
.C:4cde  29 7F       AND #$7F
;Subtract 1
.C:4ce0  38          SEC
.C:4ce1  E9 01       SBC #$01
;If result is still >= 0, skip
.C:4ce3  10 03       BPL restore_bit7
;The result of subtracting 1 from a positive number (including 0) is negative
;The only way this could have happened is that the previous value was #00
;Add 1, that will make it #00 again
.C:4ce5  18          CLC
.C:4ce6  69 01       ADC #$01
restore_bit7:
;Restore flags from stack
.C:4ce8  28          PLP
;If bit 7 was clear, set the result
.C:4ce9  10 02       BPL set_result
;Otherwise set bit 7
.C:4ceb  09 80       ORA #$80
set_result:
.C:4ced  9D 51 79    STA sound_memory_attrs,X
.C:4cf0  60          RTS
;===========================================
; Starts a sound
;
;	Arguments:	.A	sound index
;
;	Returns:	#01	if sound is not in memory
;				#FE if all voices are in used by music (which has higher priority)
;				#FF if sound can't be started because there are not enough voices available
;
; This subroutine performs the following logic:
;
;	-validates that the sound resource is effectively in memory
;	-determines how many voices are needed to play the sound
;	-checks if there are enough voices available
;	-if there aren't enough, checks if there are lower-priority sounds
;	whose voices can be evicted to make room
;	-if that's the case, it stops those sounds to evict voices and make room
;	-allocates voices needed
;	-sets up base and offset read pointers for each of those voices
;===========================================
temp = $4d04
real_voices_needed = $4cfe
voice3_is_needed = $4cf4
voice3_conflict = $4CF6
voices_needed_are_available = $4d00
voices_needed = $4d02
first_voice_index = $4cf3

start_sound:
.C:4d0a  8D 05 4D    STA sound_to_start
.C:4d0d  48          PHA
.C:4d0e  8A          TXA
.C:4d0f  48          PHA
.C:4d10  98          TYA
.C:4d11  48          PHA
;Disable sound processing while we load the sound data
.C:4d12  A9 FF       LDA #$FF
.C:4d14  8D 19 48    STA sound_processing_disabled
.C:4d17  AD 16 48    LDA music_playback_in_progress
.C:4d1a  F0 0E       BEQ check_resource_loaded
;Is the music using up all 3 real voices? If so, we can't play a sound
.C:4d1c  AD 17 48    LDA music_voices_in_use
.C:4d1f  29 07       AND #$07
.C:4d21  C9 07       CMP #$07
.C:4d23  D0 05       BNE check_resource_loaded
;All 3 voices are in use - return #FE
.C:4d25  A9 FE       LDA #$FE
.C:4d27  4C 88 4E    JMP exit
;---------------------------------------
; Check if the sound resource is actually loaded in memory - if not, exit
check_resource_loaded:
.C:4d2a  AC 05 4D    LDY sound_to_start
.C:4d2d  B9 C5 78    LDA sound_rsrc_ptrs_hi,Y
.C:4d30  D0 05       BNE set_sound_read_pointer
;Sound not in memory - return #01
.C:4d32  A9 01       LDA #$01
.C:4d34  4C 88 4E    JMP exit
;---------------------------------------
; Set the resource memory address as the sound data base address
set_sound_read_pointer:
.C:4d37  85 BD       STA >sound_read_ptr
.C:4d39  B9 0B 79    LDA sound_rsrc_ptrs_lo,Y
.C:4d3c  85 BC       STA <sound_read_ptr
;Set offset to #04 (to skip the resource header)
.C:4d3e  A0 04       LDY #$04
;-----------------------------------------------
;Read the sound priority 
.C:4d40  B1 BC       LDA (sound_read_ptr),Y
.C:4d42  8D 01 4D    STA sound_priority
.C:4d45  C9 01       CMP #$01
.C:4d47  D0 0B       BNE read_real_voice_requirements
;sound_priority == #01
.C:4d49  AD 05 4D    LDA sound_to_start
.C:4d4c  8D F1 4C    STA sound_starting
.C:4d4f  A9 01       LDA #$01
.C:4d51  8D F2 4C    STA starting_sound_with_priority_1		
;-----------------------------------------------
; Compute real voice requirements
;
; This section counts how many real voices are required.
; The result will be set into real_voices_needed.
;
; If bit 6 is set, the count will be #00
; If bit 6 is clear, the count will be 1 + value of bit 3 + value of bit 1
;
; Note: for all the observed sounds with ID > 6, bit 6 is always clear
;-----------------------------------------------
read_real_voice_requirements:
;Read voice requirements from the next byte
.C:4d54  C8          INY
.C:4d55  B1 BC       LDA (sound_read_ptr),Y
;Save voice requirements into .Y
.C:4d57  A8          TAY
;Count bits set in the voice requirements bitmask into .X
.C:4d58  A2 00       LDX #$00
;Test bit 6
.C:4d5a  29 40       AND #$40
;If bit 6 set, finish this section, .X = #00
.C:4d5c  D0 0D       BNE set_voices_needed
;Bit 6 clear - set .X to 1
.C:4d5e  A2 01       LDX #$01
.C:4d60  98          TYA
;Test bit 1 - rotate right twice, check for carry
.C:4d61  6A          ROR A
.C:4d62  6A          ROR A
.C:4d63  90 01       BCC test_bit3
;Bit 1 set - increment .X
.C:4d65  E8          INX
test_bit3:
;Test bit 3 - rotate right twice, check for carry 
.C:4d66  6A          ROR A
.C:4d67  6A          ROR A
.C:4d68  90 01       BCC set_voices_needed
;Bit 3 set - increment .X
.C:4d6a  E8          INX
set_voices_needed:
;Store bits set 
.C:4d6b  8E FE 4C    STX real_voices_needed
;-----------------------------------------------
; Check if there are enough voices available
;-----------------------------------------------
;Restore voice requirements from .Y
.C:4d6e  98          TYA
;Test bit 5 to see if the special voice #3 will be needed
;Save it into voice3_is_needed (read the voice allocation section for details on the meaning of bit5)
.C:4d6f  29 20       AND #$20
.C:4d71  8D F4 4C    STA voice3_is_needed
;Check if there's enough voices available
;If total_real_voices_available < real_voices_needed, set voices_needed_are_available = #FF (False)
;Otherwise, set it to #00 (True)
.C:4d74  A0 00       LDY #$00
.C:4d76  AD FF 4C    LDA total_real_voices_available
.C:4d79  CD FE 4C    CMP real_voices_needed
.C:4d7c  10 02       BPL set_voices_needed_are_available
.C:4d7e  A0 FF       LDY #$FF
set_voices_needed_are_available:
.C:4d80  8C 00 4D    STY voices_needed_are_available
;-----------------------------------------------
;Check if special voice #3 is needed and also in use
;If so, there's a conflict to be solved
.C:4d83  A0 00       LDY #$00
.C:4d85  AD F5 4C    LDA voice3_in_use
.C:4d88  F0 07       BEQ set_voice3_conflict
.C:4d8a  AD F4 4C    LDA voice3_is_needed
.C:4d8d  F0 02       BEQ set_voice3_conflict
.C:4d8f  A0 FF       LDY #$FF
set_voice3_conflict:
.C:4d91  8C F6 4C    STY voice3_conflict
;-----------------------------------------------
;If there's no conflict on voice 3 and enough voices are available, proceed to allocation
.C:4d94  D0 08       BNE assert_voices_attainable
.C:4d96  AD 00 4D    LDA voices_needed_are_available
.C:4d99  D0 03       BNE assert_voices_attainable
;The voices needed are available right now, go straight to the allocation section
.C:4d9b  4C 15 4E    JMP allocate_voices_needed
;-----------------------------------------------
; There are not enough voices available right now,
; so see how many voices we could evict to make room.
;-----------------------------------------------
assert_voices_attainable:
.C:4d9e  20 D8 4E    JSR count_evictable_voices
;Check total_real_voices_available + total_evictable_voices > real_voices_needed
;If so, continue
.C:4da1  18          CLC
.C:4da2  AD FF 4C    LDA total_real_voices_available
.C:4da5  6D F9 4C    ADC total_evictable_voices
.C:4da8  CD FE 4C    CMP real_voices_needed
.C:4dab  10 05       BPL check_voice3_priority
;-----------------------------------------------
; There are not enough real voices even with eviction, so return with an error
;-----------------------------------------------
.C:4dad  A9 FF       LDA #$FF
.C:4daf  4C 88 4E    JMP exit
;-----------------------------------------------
check_voice3_priority:
;Check if voice 3 is needed, if it's also in use, and whether the in-use priority is higher
.C:4db2  AD F4 4C    LDA voice3_is_needed
.C:4db5  F0 0F       BEQ check_voice3_conflict
.C:4db7  AD F5 4C    LDA voice3_in_use
.C:4dba  F0 0A       BEQ check_voice3_conflict
.C:4dbc  AD F7 4C    LDA voice3_priority_is_higher
.C:4dbf  D0 05       BNE check_voice3_conflict
;Voice 3 needed, but it's in use, and the in-use priority is higher, so we can't evict it
;Return with an error
.C:4dc1  A9 FF       LDA #$FF
.C:4dc3  4C 88 4E    JMP exit
;-----------------------------------------------
check_voice3_conflict:
;Is there a voice 3 conflict to solve? If not, go straight to the sound stopping section
.C:4dc6  AD F6 4C    LDA voice3_conflict
.C:4dc9  F0 16       BEQ find_sound_to_stop
;Check if the new sound priority is lower than the voice 3 priority
;If so, return with an error
.C:4dcb  AD 01 4D    LDA sound_priority
.C:4dce  CD 98 47    CMP voice_priority_3
.C:4dd1  30 09       BMI return_ff
;The new sound priority is higher, so we can evict the sound for voice 3
.C:4dd3  AD 9F 47    LDA rsrc_for_voice_3
.C:4dd6  4C F2 4D    JMP evict_sound
;Unreachable code
;.C:4dd9  4C E1 4D    JMP $4DE1
return_ff:
.C:4ddc  A9 FF       LDA #$FF
.C:4dde  4C 88 4E    JMP exit
;-----------------------------------------------
; Voices needed can be attained by evicting voices in use
; Find which sounds we need to stop to achieve that goal
find_sound_to_stop:
.C:4de1  20 D8 4E    JSR count_evictable_voices
;Sanity check - validate that the lowest priority found is actually lower than the new sound priority
;If not, return with an error
.C:4de4  AD FC 4C    LDA smallest_priority
.C:4de7  CD 01 4D    CMP sound_priority
.C:4dea  10 24       BPL return_ff_2
;Stop sound of lowest evictable voice
.C:4dec  AE FD 4C    LDX lowest_priority_voice
.C:4def  BD 9C 47    LDA rsrc_for_voice_0,X
evict_sound:
.C:4df2  20 88 50    JSR stop_sound_full
;Check if now there are as many real available voices as needed
.C:4df5  AD FF 4C    LDA total_real_voices_available
.C:4df8  CD FE 4C    CMP real_voices_needed
.C:4dfb  10 03       BPL enough_real_voices_available
;If not, loop back and check which other sound to stop
.C:4dfd  4C E1 4D    JMP find_sound_to_stop
;There are enough real voices now, check that voice 3 is available if needed
enough_real_voices_available:
.C:4e00  AD F4 4C    LDA voice3_is_needed
.C:4e03  F0 08       BEQ alloc_voices
.C:4e05  AD F5 4C    LDA voice3_in_use
.C:4e08  F0 03       BEQ alloc_voices
;Voice 3 needed and still in use, continue stopping sounds
.C:4e0a  4C E1 4D    JMP find_sound_to_stop
alloc_voices:
.C:4e0d  4C 15 4E    JMP allocate_voices_needed
;------------------------------------------------
return_ff_2:
.C:4e10  A9 FF       LDA #$FF
.C:4e12  4C 88 4E    JMP exit
;------------------------------------------------
; This section will allocate and set up all the voices needed for the sound.
; Real voices (0, 1 and 2) need to be allocated so no other sound uses them concurrently.
; Virtual voices (4-7) are used to generate arpeggios.
; Special voice 3 is used to control filter and volume.
;
; Apart from selecting the correct available voices and doing allocation,
; setup is needed to prepare read pointers for each voice. 
; This takes the form of a base address and an offset, for each voice.
; The sound resource data contains the starting offsets for each voice, immediately following the voices_needed byte (offset #05).
; These offsets will be present for each associated needed voice.
; After these offsets, the sound data for the first voice will begin. So the offset for the first voice allocated is not needed.
;
; Byte #05 in the sound resource data contains a bitmask specifying which voices, and of which kinds, are needed to play the sound.
;
; With all bits clear, the default case of "1 real voice needed" is represented.
;
; For each extra voice needed, a bit is set.
; Bits 1 and 3 represent real voices.
; Bits 0, 2 and 4 represent virtual voices (used to arpeggio a sound).
;
; Bits 5 and 6 are 2 different bits that can be used to request special voice #3.
; If bit 6 is clear, one available real voice is allocated (which is the minimum for a sound).
;
; To summarize:
;	Bit 6 clear	- allocate 1 available real voice
;	Bit 6 set 	- allocate special voice #3
;	Bit 5 set 	- allocate special voice #3
;	Bit 4 set 	- setup virtual voice #.X + 4
;	Bit 3 set 	- allocate 1 available real voice
;	Bit 2 set 	- setup virtual voice #.X + 4
;	Bit 1 set 	- allocate 1 available real voice
;	Bit 0 set 	- setup virtual voice #.X + 4
;
; In observed real values, bit 6 is always clear.
; Virtual voices are expected to be requested always coupled with a real voice and not by themselves.
; And voice 3 is requested only using bit 5 (and not bit 6).
;------------------------------------------------
allocate_voices_needed:
;Offset #05 encodes which voices are needed
;Read from offset #05 into voices_needed
.C:4e15  A0 05       LDY #$05
.C:4e17  B1 BC       LDA (sound_read_ptr),Y
.C:4e19  8D 02 4D    STA voices_needed
;Test bit 6
.C:4e1c  29 40       AND #$40
.C:4e1e  F0 06       BEQ bit6_clear
;-------------------------
;Bit 6 set - allocate special voice #3
.C:4e20  20 D0 4E    JSR allocate_special_voice_3
.C:4e23  4C 29 4E    JMP save_first_voice_index
;Bit 6 clear - allocate 1 real voice
bit6_clear:
.C:4e26  20 B8 4E    JSR allocate_available_real_voice
;-------------------------
;The allocated voice index is returned in .X
;Save the voice index, as we'll perform set up for that voice right at the end
save_first_voice_index:
.C:4e29  8E F3 4C    STX first_voice_index
;-------------------------
;Load the voices_needed bitmask again, in preparation for testing each bit via rotations into carry
.C:4e2c  AD 02 4D    LDA voices_needed
;Move read offset in .Y to read past the voice bitmask byte
.C:4e2f  C8          INY
;-------------------------
test_bit0:
.C:4e30  6A          ROR A
.C:4e31  90 07       BCC test_bit1
;-------------------------
;Bit 0 set - setup virtual voice #.X + 4
.C:4e33  E8          INX
.C:4e34  E8          INX
.C:4e35  E8          INX
.C:4e36  E8          INX
.C:4e37  20 99 4E    JSR set_voice_data_base_and_offset
;-------------------------
test_bit1:
.C:4e3a  6A          ROR A
.C:4e3b  90 06       BCC test_bit2
;-------------------------
;Bit 1 set - allocate 1 available real voice
.C:4e3d  20 B8 4E    JSR allocate_available_real_voice
.C:4e40  20 99 4E    JSR set_voice_data_base_and_offset
;-------------------------
test_bit2:
.C:4e43  6A          ROR A
.C:4e44  90 07       BCC test_bit3
;-------------------------
;Bit 2 set - setup virtual voice #.X + 4
.C:4e46  E8          INX
.C:4e47  E8          INX
.C:4e48  E8          INX
.C:4e49  E8          INX
.C:4e4a  20 99 4E    JSR set_voice_data_base_and_offset
;-------------------------
test_bit3:
.C:4e4d  6A          ROR A
.C:4e4e  90 06       BCC test_bit4
;-------------------------
;Bit 3 set - allocate 1 available real voice
.C:4e50  20 B8 4E    JSR allocate_available_real_voice
.C:4e53  20 99 4E    JSR set_voice_data_base_and_offset
;-------------------------
test_bit4:
.C:4e56  6A          ROR A
.C:4e57  90 07       BCC test_bit5
;-------------------------
;Bit 4 set - setup virtual voice #.X + 4
.C:4e59  E8          INX
.C:4e5a  E8          INX
.C:4e5b  E8          INX
.C:4e5c  E8          INX
.C:4e5d  20 99 4E    JSR set_voice_data_base_and_offset
;-------------------------
test_bit5:
.C:4e60  6A          ROR A
.C:4e61  90 06       BCC save_pointer_and_offset
;-------------------------
;Bit 5 set - allocate special voice #3
.C:4e63  20 D0 4E    JSR allocate_special_voice_3
.C:4e66  20 99 4E    JSR set_voice_data_base_and_offset
;------------------------------------------------
;Set up the first voice we allocated (back when we tested bit 6)
;This is done here at the end because the offsets for other voices (if any)
;had to be read and skipped first. Now that that's done, the current read offset in .Y points
; to the beginning of data for the first voice.
save_pointer_and_offset:
;Recover the first allocated voice index into .X
.C:4e69  AE F3 4C    LDX first_voice_index
;Set the voice's base address
.C:4e6c  A5 BC       LDA <sound_read_ptr
.C:4e6e  9D 79 47    STA voice_data_base_lo,X
.C:4e71  A5 BD       LDA >sound_read_ptr
.C:4e73  9D 80 47    STA voice_data_base_hi,X
;Set the voice's offset - #00 in the high byte, .Y (current read offset) into low byte
.C:4e76  98          TYA
.C:4e77  9D 87 47    STA voice_data_offsets_lo,X
.C:4e7a  A9 00       LDA #$00
.C:4e7c  9D 8E 47    STA voice_data_offsets_hi,X
;Associate the sound ID with the voice
.C:4e7f  AD 05 4D    LDA sound_to_start
.C:4e82  9D 72 47    STA sound_id_to_start_on_voice,X
;-------------------------
.C:4e85  AD 05 4D    LDA sound_to_start
exit:
.C:4e88  8D 04 4D    STA temp
;Re-enable sound processing
.C:4e8b  A9 00       LDA #$00
.C:4e8d  8D 19 48    STA sound_processing_disabled
.C:4e90  68          PLA
.C:4e91  A8          TAY
.C:4e92  68          PLA
.C:4e93  AA          TAX
.C:4e94  68          PLA
.C:4e95  AD 04 4D    LDA temp
.C:4e98  60          RTS
;===========================================
; Sets a voice data base address and offset.
; Also stores the sound ID for the voice.
;
; Arguments:	.X	voice index
;				.Y	read offset
;
; Note: the read offset in .Y is updated after reading
;===========================================
set_voice_data_base_and_offset:
.C:4e99  48          PHA
;Store voice data's base address
.C:4e9a  A5 BC       LDA <sound_read_ptr
.C:4e9c  9D 79 47    STA voice_data_base_lo,X
.C:4e9f  A5 BD       LDA >sound_read_ptr
.C:4ea1  9D 80 47    STA voice_data_base_hi,X
;Read and set bvoice's data offset
.C:4ea4  B1 BC       LDA (sound_read_ptr),Y
.C:4ea6  9D 87 47    STA voice_data_offsets_lo,X
.C:4ea9  C8          INY
.C:4eaa  B1 BC       LDA (sound_read_ptr),Y
.C:4eac  9D 8E 47    STA voice_data_offsets_hi,X
.C:4eaf  C8          INY
;Associate the sound ID with the voice
.C:4eb0  AD 05 4D    LDA sound_to_start
.C:4eb3  9D 72 47    STA sound_id_to_start_on_voice,X
.C:4eb6  68          PLA
.C:4eb7  60          RTS
;===========================================
; Allocates the first available real voice (voices #00-#02)
;
; Returns:	.X	#FF if no available voice
;				#00-02 index of voice assigned
;===========================================
allocate_available_real_voice:
;Save .A in stack
.C:4eb8  48          PHA
;Load the voices allocated bitmask
.C:4eb9  AD 07 4D    LDA voices_allocated
;Start testing at voice 2, go downwards
.C:4ebc  A2 02       LDX #$02
test_voice_allocation:
;Is the voice allocated?
.C:4ebe  3D 5C 47    AND set_bitmasks,X
;If it is, skip to the next one
.C:4ec1  D0 05       BNE next_voice
;Voice is free, allocate it and exit
.C:4ec3  20 FE 4F    JSR allocate_voice
.C:4ec6  68          PLA
.C:4ec7  60          RTS
next_voice:
.C:4ec8  AD 07 4D    LDA voices_allocated
;Decrement .X and continue while .X >= #00
.C:4ecb  CA          DEX
.C:4ecc  10 F0       BPL test_voice_allocation
;Restore .A from stack
.C:4ece  68          PLA
.C:4ecf  60          RTS
;===========================================
; Allocates special voice #03
;===========================================
allocate_special_voice_3:
.C:4ed0  48          PHA
.C:4ed1  A2 03       LDX #$03
.C:4ed3  20 FE 4F    JSR allocate_voice
.C:4ed6  68          PLA
.C:4ed7  60          RTS
;===========================================
; Counts how many voices are evictable, based on sound priorities.
; Voices of sounds that have a lower priority than the sound to be started
; are evictable.
;
; This routine will also set the "lowest" evictable voice, based on which one has
; the smallest priority among them all.
;
; Returns:	total_evictable_voices		the total number of evictable voices
; 			voice3_priority_is_higher	#00		if sound_priority < voice_priority_3 (True)
;										#FF		if sound_priority >= voice_priority_3 (False)
;
;===========================================
voice3_priority_is_higher = $4cf7
smallest_priority = $4cfc
lowest_priority_voice = $4cfd
total_evictable_voices = $4cf9

count_evictable_voices:
;Set initial value of smallest priority to #7F
.C:4ed8  A9 7F       LDA #$7F
.C:4eda  8D FC 4C    STA smallest_priority
;Start from voice 2 (.X), go downwards, start evictable count in 00 (.Y)
.C:4edd  A0 00       LDY #$00
.C:4edf  A2 02       LDX #$02
;------------------------
;Check if voice is allocated
check_if_voice_is_allocated:
.C:4ee1  AD 07 4D    LDA voices_allocated
.C:4ee4  3D 5C 47    AND set_bitmasks,X
;If voice is free, continue with the next one
.C:4ee7  F0 14       BEQ next_voice
;Voice is allocated
;If sound_priority > voice_priority, this voice is evictable
.C:4ee9  BD 95 47    LDA voice_priority_0,X
.C:4eec  CD 01 4D    CMP sound_priority
.C:4eef  10 01       BPL update_smallest_priority
;Sound priority is higher, so increment the eviction count
.C:4ef1  C8          INY
;------------------------
update_smallest_priority:
; Update the smallest priority to keep its status of being the minimum
; Compare smallest_priority vs. voice_priority, keep the minimum among them
; If there's a new minimum, save the voice as lowest_priority_voice
.C:4ef2  CD FC 4C    CMP smallest_priority
.C:4ef5  10 06       BPL next_voice
.C:4ef7  8D FC 4C    STA smallest_priority
.C:4efa  8E FD 4C    STX lowest_priority_voice
next_voice:
.C:4efd  CA          DEX
.C:4efe  10 E1       BPL check_if_voice_is_allocated
;------------------------
;Save the total evictable count into the result variable
.C:4f00  8C F9 4C    STY total_evictable_voices
.C:4f03  AD 01 4D    LDA sound_priority
;Check if we need to compare voice 3 priority or simply exit
.C:4f06  AC F6 4C    LDY voice3_conflict
.C:4f09  F0 1A       BEQ exit
;Compare sound priority with voice #3, set result accordingly in a boolean variable
; called voice3_priority_is_higher
.C:4f0b  CD 98 47    CMP voice_priority_3
.C:4f0e  30 05       BMI set_result_to_00
set_result_to_ff:
.C:4f10  A2 FF       LDX #$FF
.C:4f12  4C 22 4F    JMP set_result
set_result_to_00:
.C:4f15  A2 00       LDX #$00
;These 4 lines of code should have no net effect
;.C:4f17  AD FD 4C    LDA lowest_priority_voice
;.C:4f1a  CD 98 47    CMP voice_priority_3
;.C:4f1d  10 03       BPL set_result
;.C:4f1f  8D FD 4C    STA lowest_priority_voice
set_result:
.C:4f22  8E F7 4C    STX voice3_priority_is_higher
exit:
.C:4f25  60          RTS
;===========================================
; Updates how many total real voices are available
; 
; Updates:		total_real_voices_available	
;===========================================
count_available_real_voices:
.C:4f26  48          PHA
.C:4f27  8A          TXA
.C:4f28  48          PHA
.C:4f29  98          TYA
.C:4f2a  48          PHA
;Load bitmask to test
.C:4f2b  AD 07 4D    LDA voices_allocated
;Count bits clear with .X
.C:4f2e  A2 00       LDX #$00
;Rotate bit into carry
.C:4f30  6A          ROR A
;Is the carry set? If so, skip
.C:4f31  B0 01       BCS test_1
;Carry is clear, increase count
.C:4f33  E8          INX
;Repeat for bits 1 and 2
test_1:
.C:4f34  6A          ROR A
.C:4f35  B0 01       BCS test_2
.C:4f37  E8          INX
test_2:
.C:4f38  6A          ROR A
.C:4f39  B0 01       BCS set_result
.C:4f3b  E8          INX
set_result:
.C:4f3c  8E FF 4C    STX total_real_voices_available
.C:4f3f  68          PLA
.C:4f40  A8          TAY
.C:4f41  68          PLA
.C:4f42  AA          TAX
.C:4f43  68          PLA
.C:4f44  60          RTS
;===========================================
;===========================================
release_voice:
;Save registers in stack
.C:4f45  48          PHA
.C:4f46  8A          TXA
.C:4f47  48          PHA
.C:4f48  98          TYA
.C:4f49  48          PHA
;Is arpeggio ongoing?
.C:4f4a  AD 60 51    LDA arpeggio_ongoing
.C:4f4d  F0 12       BEQ no_arpeggio
;-----------------------------------
;Arpeggio ongoing, disable it
; Is the voice #00?
.C:4f4f  E0 00       CPX #$00
.C:4f51  D0 06       BNE disable_arpeggio_2
;Voice is #00, disable arpeggio #1
.C:4f53  8E 62 51    STX arpeggio_active_1
;Clear all alternate settings
.C:4f56  20 D0 52    JSR clear_all_alternate_settings
disable_arpeggio_2:
;Disable arpeggio #2
.C:4f59  A9 00       LDA #$00
.C:4f5b  8D 61 51    STA arpeggio_active_2
.C:4f5e  4C D6 4F    JMP clear_resource_for_voice
;-----------------------------------
no_arpeggio:
;Is voice #3?
.C:4f61  E0 03       CPX #$03
.C:4f63  D0 05       BNE check_sound_priority
;Update flag indicating it's no longer in use
.C:4f65  A9 00       LDA #$00
.C:4f67  8D F5 4C    STA voice3_in_use
;Is the voice priority #01?
check_sound_priority:
.C:4f6a  BD 95 47    LDA voice_priority_0,X
.C:4f6d  C9 01       CMP #$01
.C:4f6f  D0 17       BNE sound_priority_not_01
;----------------------------------------------
;Priority == #01
;----------------------------------------------
;Are we doing a full stop mode?
.C:4f71  AD 1A 48    LDA stop_sound_mode
.C:4f74  C9 01       CMP #$01
.C:4f76  D0 06       BNE stop_notes_for_main_voices
;-----------
;Full stop, update arpeggios
.C:4f78  20 E5 52    JSR process_arpeggio
.C:4f7b  4C C5 4F    JMP deallocate_voice
;--------
;Simple stop
stop_notes_for_main_voices:
;For real voices (.X < 3), stop note and clear waveform
.C:4f7e  E0 03       CPX #$03
.C:4f80  10 03       BPL release_voice_common
.C:4f82  20 0A 51    JSR clear_waveform_and_stop_note
release_voice_common:
.C:4f85  4C C5 4F    JMP deallocate_voice
;----------------------------------------------
;Priority != #01
;----------------------------------------------
sound_priority_not_01:
;If the sound starting does not have priority 1, release the voice
.C:4f88  AD F2 4C    LDA starting_sound_with_priority_1
.C:4f8b  F0 38       BEQ deallocate_voice
;If there's no arpeggio active, release the voice
.C:4f8d  AD 62 51    LDA arpeggio_active_1
.C:4f90  F0 33       BEQ deallocate_voice
;If the voice index >= 3, release the voice
.C:4f92  E0 03       CPX #$03
.C:4f94  10 2F       BPL deallocate_voice
;If the filter for the voice is not enabled, set the voice in use
.C:4f96  AD 64 51    LDA filter_enable_flag
.C:4f99  F0 08       BEQ set_voice_in_use
;If voice 3 is not in unse, set the voice in use
.C:4f9b  AD F5 4C    LDA voice3_in_use
.C:4f9e  F0 03       BEQ set_voice_in_use
;Otherwise, release the voice
.C:4fa0  4C C5 4F    JMP deallocate_voice
;-----------------------------------
set_voice_in_use:
;Load resource index for voice and save it in the stack
;It will be used later to decrease the memory attribute
.C:4fa3  BD 9C 47    LDA rsrc_for_voice_0,X
.C:4fa6  48          PHA
;Mark voice as executing instructions
.C:4fa7  AD 0C 48    LDA voices_executing_instruction
.C:4faa  1D 5C 47    ORA set_bitmasks,X
.C:4fad  8D 0C 48    STA voices_executing_instruction
;Adjust waveform/filter
.C:4fb0  20 42 53    JSR adjust_waveform_and_filter_for_voice
;Start a note (set bit 1 of voice control)
.C:4fb3  BD B1 47    LDA voice_controls,X
.C:4fb6  09 01       ORA #$01
.C:4fb8  9D B1 47    STA voice_controls,X
.C:4fbb  20 0D 4C    JSR set_voice_control
;Restore resource index for voice from stack
.C:4fbe  68          PLA
.C:4fbf  AA          TAX
.C:4fc0  A0 00       LDY #$00
.C:4fc2  4C E1 4F    JMP decrease_memory_attribute
;===========================================
; Deallocate a voice
; 
; Arguments:	.X	voice index to release
;
; This will also clear the resource associated with the voice,
; decrease the sound resource reference count,
; and update the count of available real voices.
;===========================================
deallocate_voice:
;Clear voice priority
.C:4fc5  A9 00       LDA #$00
.C:4fc7  9D 95 47    STA voice_priority_0,X
;Clear voice in voices_allocated bitmask
.C:4fca  AD 07 4D    LDA voices_allocated
.C:4fcd  3D 63 47    AND clear_bitmasks,X
.C:4fd0  8D 07 4D    STA voices_allocated
.C:4fd3  20 26 4F    JSR count_available_real_voices
;-----------------------------------
clear_resource_for_voice:
;Move voice index to .Y
.C:4fd6  8A          TXA
.C:4fd7  A8          TAY
;Read the resource ID for this voice into .X
.C:4fd8  BE 9C 47    LDX rsrc_for_voice_0,Y
;Clear the resource ID for the voice
.C:4fdb  A9 00       LDA #$00
.C:4fdd  99 9C 47    STA rsrc_for_voice_0,Y
.C:4fe0  A8          TAY
;-----------------------------------
decrease_memory_attribute:
;Decrease resource reference count (resource ID in .X)
.C:4fe1  20 EA 4F    JSR decrease_sound_memory_attr
;-----------------------------------
.C:4fe4  68          PLA
.C:4fe5  A8          TAY
.C:4fe6  68          PLA
.C:4fe7  AA          TAX
.C:4fe8  68          PLA
.C:4fe9  60          RTS
;===========================================
; Decrease reference count of a sound
;
;	Arguments:		.X		sound index
;===========================================
decrease_sound_memory_attr:
;If music playback is ongoing, exit
.C:4fea  AD 16 48    LDA music_playback_in_progress
.C:4fed  F0 01       BEQ do_decrease
.C:4fef  60          RTS
do_decrease:
.C:4ff0  20 DA 4C    JSR decrease_sound_memory_attribute
.C:4ff3  60          RTS
;===========================================
; Increase reference count of a sound
;
;	Arguments:		.X		sound index
;===========================================
increment_sound_memory_attr:
;If music playback is ongoing, exit
.C:4ff4  AD 16 48    LDA music_playback_in_progress
.C:4ff7  F0 01       BEQ do_increase
.C:4ff9  60          RTS
do_increase:
.C:4ffa  FE 51 79    INC sound_memory_attrs,X
.C:4ffd  60          RTS
;===========================================
; Allocate a voice
; 
;	Arguments:	.X	voice index
;
;	If the voice index is in the #00-#02 range (a real voice), mark voice as allocated
;	If it's #03, set voice3_in_use = True
;
;	In both cases, stores the sound priority for the voice,
;	and increments the memory attribute's reference count.
;===========================================
allocate_voice:
.C:4ffe  48          PHA
.C:4fff  8A          TXA
.C:5000  48          PHA
.C:5001  98          TYA
.C:5002  48          PHA
;Switch on voice index
.C:5003  E0 03       CPX #$03
.C:5005  D0 08       BNE case_not_3
case_03:
;Update flag indicating voice 3 is in use
.C:5007  A9 FF       LDA #$FF
.C:5009  8D F5 4C    STA voice3_in_use
.C:500c  4C 1D 50    JMP set_voice_priority
case_not_3:
;If voice index > 3, skip the logic intended for real voices
.C:500f  10 0C       BPL set_voice_priority
case_lt_3:
;Voice index < 3 - it's a real voice
;Mark real voice as allocated in the voices_allocated bitmask
.C:5011  AD 07 4D    LDA voices_allocated
.C:5014  1D 5C 47    ORA set_bitmasks,X
.C:5017  8D 07 4D    STA voices_allocated
;Update the count of available real voices
.C:501a  20 26 4F    JSR count_available_real_voices
set_voice_priority:
;Copy the priority for this voice
.C:501d  AD 01 4D    LDA sound_priority
.C:5020  9D 95 47    STA voice_priority_0,X
.C:5023  A0 00       LDY #$00
;Increase sound resource reference count (resource ID in .X)
.C:5025  AE 05 4D    LDX sound_to_start
.C:5028  20 F4 4F    JSR increment_sound_memory_attr
.C:502b  68          PLA
.C:502c  A8          TAY
.C:502d  68          PLA
.C:502e  AA          TAX
.C:502f  68          PLA
.C:5030  60          RTS
;===========================================
;
;	Arguments:		
;		.A		sound index
;		stop_sound_mode	
;			#01		stop, dereference sound, stop arpeggio
;			#FF		simple stop (don't dereference sound or stop arpeggio)
;===========================================
stop_sound_playback:
.C:5031  8D 08 4D    STA sound_to_stop
.C:5034  48          PHA
.C:5035  8A          TXA
.C:5036  48          PHA
.C:5037  98          TYA
.C:5038  48          PHA
;Does the sound to be stopped match?
.C:5039  AD 08 4D    LDA sound_to_stop
.C:503c  CD F1 4C    CMP sound_starting
.C:503f  D0 26       BNE stop_voice_
;It matches, stop the voice
.C:5041  20 70 50    JSR stop_voice_for_sound
;Check stop mode
.C:5044  AD 1A 48    LDA stop_sound_mode
.C:5047  C9 FF       CMP #$FF
.C:5049  D0 19       BNE exit_2
;-----------------------------------
;Mode #01 - stop and dereference
.C:504b  AE 08 4D    LDX sound_to_stop
.C:504e  A0 00       LDY #$00
;Dereference sound
.C:5050  20 EA 4F    JSR decrease_sound_memory_attr
.C:5053  A9 00       LDA #$00
.C:5055  8D F1 4C    STA sound_starting
.C:5058  8D F2 4C    STA starting_sound_with_priority_1
;Stop arpeggio
.C:505b  8D 62 51    STA arpeggio_active_1
.C:505e  8D 61 51    STA arpeggio_active_2
.C:5061  20 D0 52    JSR clear_all_alternate_settings
;-----------------------------------
;Mode #FF - simple stop (don't dereference sound or stop arpeggio)
exit_2:
.C:5064  4C 6A 50    JMP exit
stop_voice_:
.C:5067  20 70 50    JSR stop_voice_for_sound
exit:
.C:506a  68          PLA
.C:506b  A8          TAY
.C:506c  68          PLA
.C:506d  AA          TAX
.C:506e  68          PLA
.C:506f  60          RTS
;===========================================
; Stops the voice associated with a specific sound resource index
;
; Arguments:	sound_to_stop	the sound resource index to be stopped
;===========================================
temp_x = $4d09
stop_voice_for_sound:
;Start with voice #3, move downwards
.C:5070  A2 03       LDX #$03
check_voice:
;Check if the sound to stop is associated with this voice
.C:5072  AD 08 4D    LDA sound_to_stop
.C:5075  DD 9C 47    CMP rsrc_for_voice_0,X
;If not, continue
.C:5078  D0 0A       BNE next_voice
;Sound associated with this voice
.C:507a  8E 09 4D    STX temp_x
.C:507d  8A          TXA
.C:507e  20 C7 50    JSR stop_voice
.C:5081  AE 09 4D    LDX temp_x
next_voice:
.C:5084  CA          DEX
.C:5085  10 EB       BPL check_voice
.C:5087  60          RTS
;===========================================
; Stop sound, dereference, stop arpeggio
;===========================================
stop_sound_full:
.C:5088  48          PHA
.C:5089  A9 01       LDA #$01
.C:508b  8D 1A 48    STA stop_sound_mode
.C:508e  68          PLA
.C:508f  20 31 50    JSR stop_sound_playback
.C:5092  60          RTS
;===========================================
; Stops a sound by sound ID
;
;	Arguments:		.A		ID of sound to stop
;===========================================
stop_sound:
.C:5093  A2 06       LDX #$06
compare:
.C:5095  DD 72 47    CMP sound_id_to_start_on_voice,X
.C:5098  D0 07       BNE next
;Save sound index in stack
.C:509a  48          PHA
;Clear sound index
.C:509b  A9 FF       LDA #$FF
.C:509d  9D 72 47    STA sound_id_to_start_on_voice,X
;Restore sound index from stack
.C:50a0  68          PLA
next:
.C:50a1  CA          DEX
.C:50a2  10 F1       BPL compare
;===========================================
; Stop sound
;===========================================
stop_sound_simple:
;Save sound index in stack
.C:50a4  48          PHA
.C:50a5  A9 FF       LDA #$FF
.C:50a7  8D 1A 48    STA stop_sound_mode
;Restore sound index from stack
.C:50aa  68          PLA
.C:50ab  20 31 50    JSR stop_sound_playback
.C:50ae  60          RTS
;===========================================
;Apparently unused
.C:50af  48          PHA
.C:50b0  8A          TXA
.C:50b1  48          PHA
.C:50b2  98          TYA
.C:50b3  48          PHA
.C:50b4  A9 FF       LDA #$FF
.C:50b6  8D 1A 48    STA stop_sound_mode
.C:50b9  AD F1 4C    LDA sound_starting
.C:50bc  F0 03       BEQ $50C1
.C:50be  20 A4 50    JSR stop_sound_simple
:
.C:50c1  68          PLA
.C:50c2  A8          TAY
.C:50c3  68          PLA
.C:50c4  AA          TAX
.C:50c5  68          PLA
.C:50c6  60          RTS
;===========================================
; Stops a voice
;
; Arguments:	.A	logical voice index
;===========================================
stop_voice:
;Save .A in stack
.C:50c7  48          PHA
.C:50c8  AA          TAX
;Mark voice as unused
.C:50c9  20 26 51    JSR set_voice_to_unused
;If .X >= 4, exit
.C:50cc  E0 04       CPX #$04
.C:50ce  10 38       BPL exit
;If .X >= 3 (which, combined with .X >= 4, imply .X == 3), skip the waveform reset and note stop
.C:50d0  E0 03       CPX #$03
.C:50d2  10 09       BPL release_the_voice
;Set the default filter control
.C:50d4  AD 6B 47    LDA filter_control_reg_copy
.C:50d7  8D FA 4C    STA default_filter_control_value
;Clear waveform and stop note
.C:50da  20 0A 51    JSR clear_waveform_and_stop_note
release_the_voice:
;Release the voice
.C:50dd  20 45 4F    JSR release_voice
;If voice index >= 3, exit
.C:50e0  E0 03       CPX #$03
.C:50e2  10 24       BPL exit
;-----------------------
;Voice index < 3 (real voices)
;-----------------------
.C:50e4  AD 6B 47    LDA filter_control_reg_copy
.C:50e7  CD FA 4C    CMP default_filter_control_value
.C:50ea  F0 15       BEQ release_virtual_voice
.C:50ec  29 07       AND #$07
.C:50ee  D0 11       BNE release_virtual_voice
.C:50f0  8A          TXA
.C:50f1  48          PHA
;If voice #3 is in use, release it
.C:50f2  AD F5 4C    LDA voice3_in_use
.C:50f5  F0 08       BEQ $50FF
.C:50f7  A2 03       LDX #$03
.C:50f9  20 45 4F    JSR release_voice
.C:50fc  20 26 51    JSR set_voice_to_unused
:
.C:50ff  68          PLA
.C:5100  AA          TAX
release_virtual_voice:
.C:5101  E8          INX
.C:5102  E8          INX
.C:5103  E8          INX
.C:5104  E8          INX
.C:5105  20 26 51    JSR set_voice_to_unused
exit:
;Restore .A from stack
.C:5108  68          PLA
.C:5109  60          RTS
;===========================================
; Arguments:	.X	logical voice index
;===========================================
clear_waveform_and_stop_note:
;Get current voice control value for this voice
.C:510a  BD B1 47    LDA voice_controls,X
;Save voice control value in stack
.C:510d  48          PHA
;Copy it to .Y as well
.C:510e  A8          TAY
;Check flags
.C:510f  AD 16 48    LDA music_playback_in_progress
.C:5112  D0 10       BNE exit
;Are doing a simple stop?
.C:5114  AD 1A 48    LDA stop_sound_mode
.C:5117  C9 FF       CMP #$FF
;If not a simple stop, exit
.C:5119  D0 09       BNE exit
;Full stop
;Restore copy (unnecessary)
.C:511b  98          TYA
;Clear waveform bits and the gate bit (which will stop any ongoing note)
.C:511c  29 0E       AND #$0E
;Apply changes
.C:511e  9D B1 47    STA voice_controls,X
.C:5121  20 0D 4C    JSR set_voice_control
exit:
;Restore voice control value from stack
.C:5124  68          PLA
.C:5125  60          RTS
;===========================================
; Sets a voice to unused.
;
; Arguments:	.X	logical voice index
;===========================================
set_voice_to_unused:
.C:5126  A9 00       LDA #$00
.C:5128  9D AA 47    STA instruction_repeat_counter,X
;Mark that this voice is no longer executing instructions
.C:512b  AD 0C 48    LDA voices_executing_instruction
.C:512e  3D 63 47    AND clear_bitmasks,X
.C:5131  8D 0C 48    STA voices_executing_instruction
;If X < 4, exit
.C:5134  E0 04       CPX #$04
.C:5136  30 05       BMI exit
;X >= 4, clear the resource index for this sound slot
.C:5138  A9 00       LDA #$00
.C:513a  9D 9C 47    STA rsrc_for_voice_0,X
exit:
.C:513d  60          RTS
;===========================================
clear_refcount_of_sounds_1_and_2:
.C:513e  AD 52 79    LDA sound_1_memory_attr
.C:5141  29 80       AND #$80
.C:5143  8D 52 79    STA sound_1_memory_attr
.C:5146  AD 53 79    LDA sound_2_memory_attr
.C:5149  29 80       AND #$80
.C:514b  8D 53 79    STA sound_2_memory_attr
.C:514e  60          RTS
;===========================================
set_refcount_of_sounds_1_and_2:
.C:514f  AD 52 79    LDA sound_1_memory_attr
.C:5152  09 01       ORA #$01
.C:5154  8D 52 79    STA sound_1_memory_attr
.C:5157  AD 53 79    LDA sound_2_memory_attr
.C:515a  09 01       ORA #$01
.C:515c  8D 53 79    STA sound_2_memory_attr
.C:515f  60          RTS
;===========================================
; Swaps a logical voice's current settings with the alternate settings.
; For logical voices 0-2, there's a total of 21 byte settings.
;
; Arguments:	.X	current voice index
;				.Y	alternate voice index	(must be in the range 0-2)
;
; The settings copied are:
;
;	voice_attack_delays
;	voice_sustain_releases
;	voice_data_base_lo
;	sound_data_ptrs
;	voice_priority_0
;	rsrc_for_voice_0
;	instruction_for_voice
;	instruction_repeat_counter
;	voice_controls
;	sound_playback_ptr
;	voice_frequencies
;	sound_duration
;	glissando
;	sound_base_addr
;	sound_offset
;
; Note: some of these settings are 16-bit words.
;===========================================
swap_voice_settings:
.C:51a5  E0 03       CPX #$03
.C:51a7  10 1C       BPL skip_adsr
;--------------
.C:51a9  BD 6C 47    LDA voice_attack_delays,X
.C:51ac  48          PHA
.C:51ad  B9 68 51    LDA alt_voice_attack_delays,Y
.C:51b0  9D 6C 47    STA voice_attack_delays,X
.C:51b3  68          PLA
.C:51b4  99 68 51    STA alt_voice_attack_delays,Y
;--------------
.C:51b7  BD 6F 47    LDA voice_sustain_releases,X
.C:51ba  48          PHA
.C:51bb  B9 6A 51    LDA alt_voice_sustain_releases,Y
.C:51be  9D 6F 47    STA voice_sustain_releases,X
.C:51c1  68          PLA
.C:51c2  99 6A 51    STA alt_voice_sustain_releases,Y
;--------------
skip_adsr:
.C:51c5  BD 79 47    LDA voice_data_base_lo,X
.C:51c8  48          PHA
.C:51c9  B9 6C 51    LDA alt_voice_data_ptrs_lo,Y
.C:51cc  9D 79 47    STA voice_data_base_lo,X
.C:51cf  68          PLA
.C:51d0  99 6C 51    STA alt_voice_data_ptrs_lo,Y
;--------------
.C:51d3  BD 80 47    LDA voice_data_base_hi,X
.C:51d6  48          PHA
.C:51d7  B9 6F 51    LDA alt_voice_data_ptrs_hi,Y
.C:51da  9D 80 47    STA voice_data_base_hi,X
.C:51dd  68          PLA
.C:51de  99 6F 51    STA alt_voice_data_ptrs_hi,Y
;--------------
.C:51e1  BD 95 47    LDA voice_priority_0,X
.C:51e4  48          PHA
.C:51e5  B9 72 51    LDA $5172,Y
.C:51e8  9D 95 47    STA voice_priority_0,X
.C:51eb  68          PLA
.C:51ec  99 72 51    STA $5172,Y
;--------------
.C:51ef  BD 9C 47    LDA rsrc_for_voice_0,X
.C:51f2  48          PHA
.C:51f3  B9 75 51    LDA $5175,Y
.C:51f6  9D 9C 47    STA rsrc_for_voice_0,X
.C:51f9  68          PLA
.C:51fa  99 75 51    STA $5175,Y
;--------------
.C:51fd  BD A3 47    LDA instruction_for_voice,X
.C:5200  48          PHA
.C:5201  B9 78 51    LDA $5178,Y
.C:5204  9D A3 47    STA instruction_for_voice,X
.C:5207  68          PLA
.C:5208  99 78 51    STA $5178,Y
;--------------
.C:520b  BD AA 47    LDA instruction_repeat_counter,X
.C:520e  48          PHA
.C:520f  B9 7B 51    LDA $517B,Y
.C:5212  9D AA 47    STA instruction_repeat_counter,X
.C:5215  68          PLA
.C:5216  99 7B 51    STA $517B,Y
;--------------
.C:5219  BD B1 47    LDA voice_controls,X
.C:521c  48          PHA
.C:521d  B9 7E 51    LDA alt_voice_controls,Y
.C:5220  9D B1 47    STA voice_controls,X
.C:5223  68          PLA
.C:5224  99 7E 51    STA alt_voice_controls,Y
;--------------
.C:5227  BD B8 47    LDA voice_instruction_ptr_lo,X
.C:522a  48          PHA
.C:522b  B9 81 51    LDA $5181,Y
.C:522e  9D B8 47    STA voice_instruction_ptr_lo,X
.C:5231  68          PLA
.C:5232  99 81 51    STA $5181,Y
;--------------
.C:5235  BD BF 47    LDA voice_instruction_ptr_hi,X
.C:5238  48          PHA
.C:5239  B9 84 51    LDA $5184,Y
.C:523c  9D BF 47    STA voice_instruction_ptr_hi,X
.C:523f  68          PLA
.C:5240  99 84 51    STA $5184,Y
;--------------
.C:5243  BD C6 47    LDA voice_frequencies_lo,X
.C:5246  48          PHA
.C:5247  B9 87 51    LDA alt_voice_frequencies_lo,Y
.C:524a  9D C6 47    STA voice_frequencies_lo,X
.C:524d  68          PLA
.C:524e  99 87 51    STA alt_voice_frequencies_lo,Y
;--------------
.C:5251  BD CD 47    LDA voice_frequencies_hi,X
.C:5254  48          PHA
.C:5255  B9 8A 51    LDA alt_voice_frequencies_hi,Y
.C:5258  9D CD 47    STA voice_frequencies_hi,X
.C:525b  68          PLA
.C:525c  99 8A 51    STA alt_voice_frequencies_hi,Y
;--------------
.C:525f  BD D4 47    LDA sound_duration_lo,X
.C:5262  48          PHA
.C:5263  B9 8D 51    LDA alt_sound_duration_lo,Y
.C:5266  9D D4 47    STA sound_duration_lo,X
.C:5269  68          PLA
.C:526a  99 8D 51    STA alt_sound_duration_lo,Y
;--------------
.C:526d  BD DB 47    LDA sound_duration_hi,X
.C:5270  48          PHA
.C:5271  B9 90 51    LDA alt_sound_duration_hi,Y
.C:5274  9D DB 47    STA sound_duration_hi,X
.C:5277  68          PLA
.C:5278  99 90 51    STA alt_sound_duration_hi,Y
;--------------
.C:527b  BD E2 47    LDA glissando_lo,X
.C:527e  48          PHA
.C:527f  B9 93 51    LDA alt_glissando_lo,Y
.C:5282  9D E2 47    STA glissando_lo,X
.C:5285  68          PLA
.C:5286  99 93 51    STA alt_glissando_lo,Y
;--------------
.C:5289  BD E9 47    LDA glissando_hi,X
.C:528c  48          PHA
.C:528d  B9 96 51    LDA alt_glissando_hi,Y
.C:5290  9D E9 47    STA glissando_hi,X
.C:5293  68          PLA
.C:5294  99 96 51    STA alt_glissando_hi,Y
;--------------
.C:5297  BD F0 47    LDA voice_base_addr_lo,X
.C:529a  48          PHA
.C:529b  B9 99 51    LDA $5199,Y
.C:529e  9D F0 47    STA voice_base_addr_lo,X
.C:52a1  68          PLA
.C:52a2  99 99 51    STA $5199,Y
;--------------
.C:52a5  BD F7 47    LDA voice_base_addr_hi,X
.C:52a8  48          PHA
.C:52a9  B9 9C 51    LDA $519C,Y
.C:52ac  9D F7 47    STA voice_base_addr_hi,X
.C:52af  68          PLA
.C:52b0  99 9C 51    STA $519C,Y
;--------------
.C:52b3  BD FE 47    LDA voice_instruction_offset_lo,X
.C:52b6  48          PHA
.C:52b7  B9 9F 51    LDA $519F,Y
.C:52ba  9D FE 47    STA voice_instruction_offset_lo,X
.C:52bd  68          PLA
.C:52be  99 9F 51    STA $519F,Y
;--------------
.C:52c1  BD 05 48    LDA voice_instruction_offset_hi,X
.C:52c4  48          PHA
.C:52c5  B9 A2 51    LDA $51A2,Y
.C:52c8  9D 05 48    STA voice_instruction_offset_hi,X
.C:52cb  68          PLA
.C:52cc  99 A2 51    STA $51A2,Y
.C:52cf  60          RTS
;===========================================
; Clears all the alternate settings for logical voices 0-2
;===========================================
clear_all_alternate_settings:
;Save registers in stack
.C:52d0  48          PHA
.C:52d1  8A          TXA
.C:52d2  48          PHA
.C:52d3  98          TYA
.C:52d4  48          PHA
;Clear voices 0-2 alternate settings
.C:52d5  A2 3C       LDX #$3C
.C:52d7  A9 00       LDA #$00
clear_loop:
.C:52d9  9D 68 51    STA alt_voice_attack_delays,X
.C:52dc  CA          DEX
.C:52dd  10 FA       BPL clear_loop
;Restore registers from stack
.C:52df  68          PLA
.C:52e0  A8          TAY
.C:52e1  68          PLA
.C:52e2  AA          TAX
.C:52e3  68          PLA
.C:52e4  60          RTS
;===========================================
; Set up voice arpeggio
;===========================================
process_arpeggio:
;If voice number is > 3, exit
.C:52e5  E0 04       CPX #$04
.C:52e7  30 01       BMI x_validated
.C:52e9  60          RTS
x_validated:
.C:52ea  48          PHA
.C:52eb  8A          TXA
.C:52ec  48          PHA
.C:52ed  98          TYA
.C:52ee  48          PHA
;Check if voice is 3 or > 3
.C:52ef  E0 03       CPX #$03
.C:52f1  10 26       BPL x_greater_than_3
;.X == #03
;If all alt settings have already been cleared, skip that
.C:52f3  AD 67 51    LDA all_alt_settings_cleared
.C:52f6  D0 03       BNE swap_with_alternate_0
.C:52f8  20 D0 52    JSR clear_all_alternate_settings
;---------------------------------------
swap_with_alternate_0:
;Swap voice with alternate voice #00
.C:52fb  A0 00       LDY #$00
.C:52fd  20 A5 51    JSR swap_voice_settings
;Pick voice .X + 4
.C:5300  E8          INX
.C:5301  E8          INX
.C:5302  E8          INX
.C:5303  E8          INX
;Check if the voice is executing instructions
.C:5304  AD 0C 48    LDA voices_executing_instruction
.C:5307  3D 5C 47    AND set_bitmasks,X
;If it's available, exit
.C:530a  F0 0A       BEQ exit_2
;---------------------------------------
;It's in use, swap with alternate #1
.C:530c  A0 01       LDY #$01
.C:530e  20 A5 51    JSR swap_voice_settings
;Enable arpeggio_active_2 and exit
.C:5311  A9 FF       LDA #$FF
.C:5313  8D 61 51    STA arpeggio_active_2
exit_2:
.C:5316  4C 37 53    JMP exit
;---------------------------------------
x_greater_than_3:
.C:5319  D0 1C       BNE exit
;Get bits 6-4 (filter mode control: low-pass, band-pass, high-pass)
.C:531b  AD 6A 47    LDA volume_control_reg_copy
.C:531e  29 70       AND #$70
;Save those bits as filter_pass_select
.C:5320  8D 66 51    STA filter_pass_select
;Clear all alt settings
.C:5323  20 D0 52    JSR clear_all_alternate_settings
;Mark that all alt settings have been cleared already,
; to disable clearing the next time
.C:5326  A9 FF       LDA #$FF
.C:5328  8D 67 51    STA all_alt_settings_cleared
;Swap settings #3 with alt #2
.C:532b  A2 03       LDX #$03
.C:532d  A0 02       LDY #$02
.C:532f  20 A5 51    JSR swap_voice_settings
.C:5332  A9 FF       LDA #$FF
.C:5334  8D 64 51    STA filter_enable_flag
;---------------------------------------
exit:
;Enable arpeggio_active_1
.C:5337  A9 FF       LDA #$FF
.C:5339  8D 62 51    STA arpeggio_active_1
.C:533c  68          PLA
.C:533d  A8          TAY
.C:533e  68          PLA
.C:533f  AA          TAX
.C:5340  68          PLA
.C:5341  60          RTS
;===========================================
voice_being_modified = $5165

adjust_waveform_and_filter_for_voice:
.C:5342  E0 03       CPX #$03
.C:5344  30 01       BMI voice_index_validated
.C:5346  60          RTS
voice_index_validated:
;Save registers in stack
.C:5347  48          PHA
.C:5348  8A          TXA
.C:5349  48          PHA
.C:534a  98          TYA
.C:534b  48          PHA
;Save the logical voice being modified
.C:534c  8E 65 51    STX voice_being_modified
;Swap voice with alternate voice #00
.C:534f  A0 00       LDY #$00
.C:5351  20 A5 51    JSR swap_voice_settings
;Set frequency and envelope
.C:5354  20 E6 4B    JSR set_voice_frequency_and_envelope
;Do we need to multiplex?
.C:5357  AD 61 51    LDA arpeggio_active_2
.C:535a  F0 0C       BEQ check_filter_change
;Yes, we need to multiplex
;Add 4 to current voice index
.C:535c  E8          INX
.C:535d  E8          INX
.C:535e  E8          INX
.C:535f  E8          INX
;Swap voice with alternate voice #01
.C:5360  A0 01       LDY #$01
.C:5362  20 A5 51    JSR swap_voice_settings
;Set frequency and envelope
.C:5365  20 E6 4B    JSR set_voice_frequency_and_envelope
check_filter_change:
;Do we have to filter the voice?
.C:5368  AD 64 51    LDA filter_enable_flag
.C:536b  C9 FF       CMP #$FF
;If not, skip to stop_filtering_voice
.C:536d  D0 35       BNE stop_filtering_voice
;Yes, we have to filter
;Swap current voice 3 with alternate voice 2
.C:536f  A2 03       LDX #$03
.C:5371  A0 02       LDY #$02
.C:5373  20 A5 51    JSR swap_voice_settings
;---------------------
start_filtering_voice:
;Read the default filter control value
.C:5376  AD FA 4C    LDA default_filter_control_value
.C:5379  AE 65 51    LDX voice_being_modified
;Take the high nibble (the filter resonance)
.C:537c  29 F0       AND #$F0
;Set the bit corresponding to the voice position (0-2)
;That will enable filtering for that voice
.C:537e  1D 5C 47    ORA set_bitmasks,X
;Save a copy of the value
.C:5381  8D 6B 47    STA filter_control_reg_copy
;Set it to the actual register
.C:5384  8D 17 D4    STA filter_control_register
;---------------------
;Read the current saved volume control value
.C:5387  AD 6A 47    LDA volume_control_reg_copy
;Take the low nibble (volume value)
.C:538a  29 0F       AND #$0F
;Set the filter pass selection bits
.C:538c  0D 66 51    ORA filter_pass_select
;Save a copy of the value
.C:538f  8D 6A 47    STA volume_control_reg_copy
;Set it to the actual register
.C:5392  8D 18 D4    STA volume_control_register
;---------------------
;Copy the filter cutoff setting
.C:5395  AD C9 47    LDA filter_cutoff_freq_lo
.C:5398  8D 15 D4    STA filter_cutoff_freq_lo_reg
.C:539b  AD D0 47    LDA filter_cutoff_freq_hi
.C:539e  8D 16 D4    STA filter_cutoff_freq_hi_reg
.C:53a1  4C B3 53    JMP exit
;---------------------
stop_filtering_voice:
;Read the default filter control value
.C:53a4  AD FA 4C    LDA default_filter_control_value
;Clear the bit corresponding to the voice position (0-2)
;That will disable filtering for that voice
.C:53a7  AE 65 51    LDX voice_being_modified
.C:53aa  3D 63 47    AND clear_bitmasks,X
;Save a copy of the value
.C:53ad  8D 6B 47    STA filter_control_reg_copy
;Set it to the actual register
.C:53b0  8D 17 D4    STA filter_control_register
;---------------------
exit:
;Disable multiple flags
.C:53b3  A9 00       LDA #$00
.C:53b5  8D 62 51    STA arpeggio_active_1
.C:53b8  8D 61 51    STA arpeggio_active_2
.C:53bb  8D 67 51    STA all_alt_settings_cleared
.C:53be  8D 66 51    STA filter_pass_select
.C:53c1  8D 64 51    STA filter_enable_flag
;Restore registers from stack
.C:53c4  68          PLA
.C:53c5  A8          TAY
.C:53c6  68          PLA
.C:53c7  AA          TAX
.C:53c8  68          PLA
.C:53c9  60          RTS
;===========================================
jump_to_inlined_music_routine:
inlined_music_ptr = $53cb
.C:53ca  4C FF FF    JMP $FFFF
sound_3:
.C:53cd  00          BRK
.C:53ce  00          BRK
.C:53cf  00          BRK
.C:53d0  00          BRK
.C:53d1  7F 01 19    RRA $1901,X
.C:53d4  00          BRK
.C:53d5  00          BRK
.C:53d6  00          BRK
.C:53d7  2D 00 00    AND $0000
.C:53da  00          BRK
.C:53db  00          BRK
.C:53dc  00          BRK
.C:53dd  00          BRK
.C:53de  00          BRK
.C:53df  F0 40       BEQ $5421
.C:53e1  10 04       BPL $53E7
.C:53e3  00          BRK
.C:53e4  00          BRK
.C:53e5  00          BRK
.C:53e6  04 27       NOOP $27
.C:53e8  03 FF       SLO ($FF,X)
.C:53ea  FF 01 00    ISB $0001,X
.C:53ed  00          BRK
.C:53ee  00          BRK
.C:53ef  00          BRK
.C:53f0  00          BRK
.C:53f1  00          BRK
.C:53f2  00          BRK
.C:53f3  00          BRK
.C:53f4  00          BRK
.C:53f5  00          BRK
.C:53f6  00          BRK
.C:53f7  00          BRK
.C:53f8  00          BRK
.C:53f9  00          BRK
sound_4:
.C:53fa  00          BRK
.C:53fb  00          BRK
.C:53fc  00          BRK
.C:53fd  00          BRK
.C:53fe  7F 01 19    RRA $1901,X
.C:5401  00          BRK
.C:5402  00          BRK
.C:5403  00          BRK
.C:5404  2D 00 00    AND $0000
.C:5407  00          BRK
.C:5408  00          BRK
.C:5409  00          BRK
.C:540a  00          BRK
.C:540b  00          BRK
.C:540c  F0 20       BEQ $542E
.C:540e  10 04       BPL $5414
.C:5410  00          BRK
.C:5411  00          BRK
.C:5412  00          BRK
.C:5413  04 27       NOOP $27
.C:5415  03 FF       SLO ($FF,X)
.C:5417  FF 02 00    ISB $0002,X
.C:541a  00          BRK
.C:541b  00          BRK
.C:541c  00          BRK
.C:541d  00          BRK
.C:541e  00          BRK
.C:541f  00          BRK
.C:5420  00          BRK
.C:5421  00          BRK
.C:5422  00          BRK
.C:5423  00          BRK
.C:5424  00          BRK
.C:5425  00          BRK
.C:5426  00          BRK
sound_5:
.C:5427  00          BRK
.C:5428  00          BRK
.C:5429  00          BRK
.C:542a  00          BRK
.C:542b  7F 01 19    RRA $1901,X
.C:542e  00          BRK
.C:542f  00          BRK
.C:5430  00          BRK
.C:5431  2D 00 00    AND $0000
.C:5434  00          BRK
.C:5435  00          BRK
.C:5436  00          BRK
.C:5437  00          BRK
.C:5438  00          BRK
.C:5439  F0 20       BEQ $545B
.C:543b  10 04       BPL $5441
.C:543d  00          BRK
.C:543e  00          BRK
.C:543f  00          BRK
.C:5440  04 27       NOOP $27
.C:5442  03 FF       SLO ($FF,X)
.C:5444  FF 02 00    ISB $0002,X
.C:5447  00          BRK
.C:5448  00          BRK
.C:5449  00          BRK
.C:544a  00          BRK
.C:544b  00          BRK
.C:544c  00          BRK
.C:544d  00          BRK
.C:544e  00          BRK
.C:544f  00          BRK
.C:5450  00          BRK
.C:5451  00          BRK
.C:5452  00          BRK
.C:5453  00          BRK
.C:5454  00          BRK
;Voice data offsets used in the music player
voice_offsets_in_music_resource:
.C:5455  06 08 0A
.C:5458  00          BRK
sound_resource_index_for_music_voice:
.C:5459  03 04 05 
.C:545C 00       ORA $00
;Offset constants lo/hi for each sound "track"
;00CC
;014D
;03B9
;044B
;03F4
;014F
;04D2
;04FD
;055E
music_track_offsets_lo:
.547E	CC 4D B9 4B F4 4F D2 FD 5E 
music_track_offsets_hi:
.5487	00 01 03 04 03 01 04 04 05

;===========================================
; Allocate a memory block of a given size
;
; Arguments:	.X/.Y	size of data to fit
; Returns:		.X/.Y	memory_range_ptr
;===========================================
temp_x = $5501
temp_y = $5502
	
alloc_data:
;Backup .X and .Y
.C:54e4  8E 01 55    STX temp_x
.C:54e7  8C 02 55    STY temp_y
;Try to get a free block
.C:54ea  20 1B 58    JSR get_free_block
.C:54ed  D0 11       BNE block_found
;No success, compact free memory and release resources as needed
.C:54ef  20 D5 58    JSR compact_and_release
.C:54f2  D0 0C       BNE block_found
;Release one costume and try again
.C:54f4  20 7B 56    JSR release_one_costume
.C:54f7  AE 01 55    LDX temp_x
.C:54fa  AC 02 55    LDY temp_y
.C:54fd  4C E4 54    JMP alloc_data
block_found:
.C:5500  60          RTS
;===========================================
; Releases a resource
;
; The new free block will be appended as the last element in 
; the linked list of free blocks. The list of free blocks will be
; sorted by block addresses, and finally adjacent free blocks
; will be merged.
;
; Arguments:	.X/.Y	pointer to resource block
;===========================================
free_block = $61

release_resource:
;Fetch the last free block into free_block so we can edit it later
.C:5503  AD 65 FF    LDA <last_free_block
.C:5506  85 61       STA <free_block
.C:5508  AD 66 FF    LDA >last_free_block
.C:550b  85 62       STA >free_block
;Set the block we're deleting as the new last free block
.C:550d  8E 65 FF    STX <last_free_block
.C:5510  8C 66 FF    STY >last_free_block
;Append last_free_block to the list by doing
; free_block->next = last_free_block
.C:5513  A0 02       LDY #$02
.C:5515  AD 65 FF    LDA <last_free_block
.C:5518  91 61       STA (free_block),Y
.C:551a  C8          INY
.C:551b  AD 66 FF    LDA >last_free_block
.C:551e  91 61       STA (free_block),Y
;Point to the new free block so we can edit it further
.C:5520  86 61       STX <free_block
.C:5522  85 62       STA >free_block
;Set free_block->next to null
.C:5524  A9 00       LDA #$00
.C:5526  A0 02       LDY #$02
.C:5528  91 61       STA (free_block),Y
.C:552a  C8          INY
.C:552b  91 61       STA (free_block),Y
;Sort all free blocks by their address
.C:552d  20 4C 57    JSR sort_free_blocks
;Coalesce all adjacent free blocks
.C:5530  20 C8 56    JSR coalesce_free_blocks
;Mark that a resource has been released
.C:5533  A9 01       LDA #$01
.C:5535  8D 4A FE    STA rsrc_has_been_released
.C:5538  60          RTS
;===========================================
; Load room data from disk
;
; Requires previously setting:
; 	read_offset
;	sector_chain_index
; Returns:	.X/.Y	pointer to room data loaded
;===========================================
read_offset = $5678
sector_chain_index = $5679

ZERO_BYTE_OFFSET = #$02
CHECKSUM_OFFSET = #$03
RSRC_HEADER_SIZE = #$04
local_header = $553b
rsrc_size = $553b
rsrc_data = $553f
raw_data = $e4
raw_data_count = $e6
expected_checksum = $e9
running_checksum = $e8
retry_counter = $EA
checksum_ptr = $4f

load_resource:
;Pause game
.C:5541  20 D1 18    JSR pause_game
;Read the first data sector from disk
.C:5544  AE 78 56    LDX read_offset
.C:5547  AC 79 56    LDY sector_chain_index
.C:554a  20 F7 44    JSR disk_seek_read
;Copy the resource header to local memory
.C:554d  A2 3B       LDX #<local_header
.C:554f  A0 55       LDY #>local_header
.C:5551  A9 04       LDA RSRC_HEADER_SIZE
.C:5553  8D 3C 46    STA disk_copy_count_lo
.C:5556  A9 00       LDA #$00
.C:5558  8D 3D 46    STA disk_copy_count_hi
.C:555b  20 1F 45    JSR disk_stream_copy
;Validate that the "zero byte" is zero
;If not, start over
.C:555e  AD 3D 55    LDA local_header + ZERO_BYTE_OFFSET
.C:5561  F0 06       BEQ find_memory_for_data
.C:5563  20 27 56    JSR disk_id_check
.C:5566  4C 41 55    JMP load_resource
;----------------------------------------
;Allocate space for the whole data
find_memory_for_data:
;Set data size argument
.C:5569  AE 3B 55    LDX <rsrc_size
.C:556c  AC 3C 55    LDY >rsrc_size
;Allocate memory
.C:556f  20 E4 54    JSR alloc_data
;Store available memory range into room_data_ptr
.C:5572  8E 3F 55    STX <rsrc_data
.C:5575  8C 40 55    STY >rsrc_data
.C:5578  A9 01       LDA #$01
.C:557a  85 EA       STA retry_counter
;----------------------------------------
room_raw_data_load:
;Load the whole resource data from disk into memory
.C:557c  AE 78 56    LDX read_offset
.C:557f  AC 79 56    LDY sector_chain_index
.C:5582  20 F7 44    JSR disk_seek_read
.C:5585  AE 3F 55    LDX <rsrc_data
.C:5588  AC 40 55    LDY >rsrc_data
.C:558b  AD 3B 55    LDA <rsrc_size
.C:558e  8D 3C 46    STA disk_copy_count_lo
.C:5591  AD 3C 55    LDA >rsrc_size
.C:5594  8D 3D 46    STA disk_copy_count_hi
.C:5597  20 1F 45    JSR disk_stream_copy
;-------------------------------------------
; Setup data checksum
;Copy resource pointer to checksum ptr
.C:559a  AD 3F 55    LDA <rsrc_data
.C:559d  85 4F       STA <checksum_ptr
.C:559f  AD 40 55    LDA >rsrc_data
.C:55a2  85 50       STA >checksum_ptr
;Compute resource raw data size (without the header)
.C:55a4  38          SEC
.C:55a5  AD 3B 55    LDA <rsrc_size
.C:55a8  E9 04       SBC RSRC_HEADER_SIZE
.C:55aa  85 E6       STA <raw_data_count
.C:55ac  AD 3C 55    LDA >rsrc_size
.C:55af  E9 00       SBC #$00
.C:55b1  85 E7       STA >raw_data_count
;Point to start of raw data by skipping the header
.C:55b3  18          CLC
.C:55b4  AD 3F 55    LDA <rsrc_data
.C:55b7  69 04       ADC RSRC_HEADER_SIZE
.C:55b9  85 E4       STA <raw_data
.C:55bb  AD 40 55    LDA >rsrc_data
.C:55be  69 00       ADC #$00
.C:55c0  85 E5       STA >raw_data
;Read the expected checksum
.C:55c2  A0 03       LDY CHECKSUM_OFFSET
.C:55c4  B1 4F       LDA (checksum_ptr),Y
.C:55c6  85 E9       STA expected_checksum
;----------------------------------------
;Set initial checksum value to #00
.C:55c8  A9 00       LDA #$00
.C:55ca  85 E8       STA running_checksum
checksum_byte:
.C:55cc  A0 00       LDY #$00
.C:55ce  A5 E8       LDA running_checksum
;Checksum by XOR'ing the byte with the running_checksum
.C:55d0  51 E4       EOR (raw_data),Y
.C:55d2  85 E8       STA running_checksum
;Move to the next byte
.C:55d4  E6 E4       INC <raw_data
.C:55d6  D0 02       BNE update_count
.C:55d8  E6 E5       INC >raw_data
update_count:
.C:55da  A5 E6       LDA <raw_data_count
.C:55dc  D0 02       BNE dec_lo_count
.C:55de  C6 E7       DEC >raw_data_count
dec_lo_count:
.C:55e0  C6 E6       DEC <raw_data_count
;Check if there's still data pending by OR'ing hi and lo
;If so, checksum the next byte
.C:55e2  A5 E6       LDA <raw_data_count
.C:55e4  05 E7       ORA >raw_data_count
.C:55e6  D0 E4       BNE checksum_byte
;----------------------------------------
;All data has been checksummed - now validate the checksum
.C:55e8  A5 E8       LDA running_checksum
.C:55ea  C5 E9       CMP expected_checksum
;If checksum matches, proceed with the metadata
.C:55ec  F0 16       BEQ setup_block_metadata
;Checksum not validated - retry 
.C:55ee  C6 EA       DEC retry_counter
.C:55f0  D0 0F       BNE reload_room
;No retries left, set retries back to 1
.C:55f2  A9 01       LDA #$01
.C:55f4  85 EA       STA retry_counter
;Print disk_error_msg, wait for joystick button press and try again
.C:55f6  A9 81       LDA #<disk_error_msg
.C:55f8  85 DA       STA $DA
.C:55fa  A9 3B       LDA #>disk_error_msg
.C:55fc  85 DB       STA $DB
.C:55fe  20 15 3B    JSR print_message_wait_for_button
reload_room:
.C:5601  4C 7C 55    JMP room_raw_data_load
;===========================================
; Writes the metadata for a resource
;
; Arguments:	raw_data_size		resource size
;				resource_type
;				resource_index
;
;
; This takes 4 bytes in total
;
; Bytes 0-1 are the raw data size
; Byte 2 is the resource type (#2-#6 enumerated type)
; Byte 3 is the resource index
;===========================================
raw_data_size = $fd9c
block = $4f
resource_type = $5677
resource_index = $5676

setup_block_metadata:
;Store raw data size
.C:5604  A0 00       LDY #$00
.C:5606  AD 9C FD    LDA <raw_data_size
.C:5609  91 4F       STA (block),Y
.C:560b  C81         INY
.C:560c  AD 9D FD    LDA >raw_data_size
.C:560f  91 4F       STA (block),Y
;Store resource type 
.C:5611  C8          INY
.C:5612  AD 77 56    LDA resource_type		
.C:5615  91 4F       STA (block),Y
;Store resource index
.C:5617  C8          INY
.C:5618  AD 76 56    LDA resource_index		
.C:561b  91 4F       STA (block),Y
;Return the resource data pointer via .X and .Y
.C:561d  AE 3F 55    LDX <rsrc_data
.C:5620  AC 40 55    LDY >rsrc_data
;Unpause game
.C:5623  20 DF 18    JSR unpause_game
.C:5626  60          RTS
;===========================================
disk_id_in_sector = $567A

disk_id_check:
.C:5627  AD 33 46    LDA sector_desired
.C:562a  48          PHA
.C:562b  AD 34 46    LDA track_desired
.C:562e  48          PHA
;Read track 1 sector 0, starting from byte offset #00
.C:562f  A2 00       LDX #$00
.C:5631  A0 01       LDY #$01
.C:5633  20 D3 44    JSR disk_init_chain
.C:5636  A2 00       LDX #$00
.C:5638  A0 00       LDY #$00
.C:563a  20 F7 44    JSR disk_seek_read
;Copy 1 byte to disk_id_in_sector
;This is the first byte of track 1 sector 0, which is always the Disk ID
.C:563d  A2 7A       LDX #<disk_id_in_sector
.C:563f  A0 56       LDY #>disk_id_in_sector
.C:5641  A9 01       LDA #$01
.C:5643  8D 3C 46    STA disk_copy_count_lo
.C:5646  A9 00       LDA #$00
.C:5648  8D 3D 46    STA disk_copy_count_hi
.C:564b  20 1F 45    JSR disk_stream_copy
;Compare Disk ID with desired_disk_id
.C:564e  AD 9C FE    LDA desired_disk_id
.C:5651  CD 7A 56    CMP disk_id_in_sector
.C:5654  D0 11       BNE disk_id_mismatch
;----------------
.C:5656  A9 2F       LDA #$2F
.C:5658  85 DC       STA $DC
;map_in_io
.C:565a  A0 25       LDY #$25		
.C:565c  84 01       STY processor_port_register
infinite_loop:
.C:565e  8D 20 D0    STA vic_border_color_register
.C:5661  4C 5E 56    JMP infinite_loop	
;Unreachable code
;.C:5664  4C 6D 56    JMP $566D
;----------------
;Disk ID doesn't match
disk_id_mismatch:
.C:5667  AD 9C FE    LDA desired_disk_id
.C:566a  20 EB 3A    JSR check_disk_side
.C:566d  68          PLA
.C:566e  8D 34 46    STA track_desired
.C:5671  68          PLA
.C:5672  8D 33 46    STA sector_desired
.C:5675  60          RTS
;===========================================
MAX_costume_index = #$18

release_one_costume:
.C:567b  A2 18       LDX MAX_costume_index
check_costume:
;Check memory attribute of costume
.C:567d  BD A3 77    LDA costume_memory_attrs,X
;Is it unlocked? (bit 7 clear) - if so, continue
.C:5680  10 06       BPL next_costume
;It's locked, unlock it (clear bit 7) and return
.C:5682  29 7F       AND #$7F
.C:5684  9D A3 77    STA costume_memory_attrs,X
.C:5687  60          RTS
next_costume:
.C:5688  CA          DEX
.C:5689  D0 F2       BNE check_costume
;All costumes were unlocked
;Check the first 8 costumes in detail
.C:568b  A2 08       LDX #$08
check_eligibility:
;Is it the current kid? If so, continue
.C:568d  EC 67 FF    CPX current_kid
.C:5690  F0 21       BEQ next_costume_2
;Is it loaded in memory? If not, continue
.C:5692  BD 61 78    LDA costume_rsrc_ptrs_hi,X
.C:5695  F0 1C       BEQ next_costume_2
;------------------------------------------------
; Release the costume
;------------------------------------------------
;It's loaded (and unlocked), mark it as released
.C:5697  A9 00       LDA #$00
.C:5699  9D A3 77    STA costume_memory_attrs,X
;Save costume index in stack
.C:569c  8A          TXA
.C:569d  48          PHA
;
.C:569e  20 E4 38    JSR release_costume
;Restore costume index
.C:56a1  68          PLA
.C:56a2  AA          TAX
;Set default coordinates
.C:56a3  A9 14       LDA #$14
.C:56a5  9D 2E FF    STA costume_x_destination,X
.C:56a8  A9 3C       LDA #$3C
.C:56aa  9D 15 FF    STA costume_y_destination,X
;Set costume's room to #2C and exit
.C:56ad  A9 2C       LDA #$2C
.C:56af  9D FC FE    STA room_for_character,X
.C:56b2  60          RTS
;------------------------------------------------
next_costume_2:
.C:56b3  CA          DEX
.C:56b4  D0 D7       BNE check_eligibility
;We exhausted the first 8 costumes and we couldn't release any of them
;Hang up
.C:56b6  A9 05       LDA #$05
.C:56b8  85 DC       STA $DC
;map_in_io
.C:56ba  A0 25       LDY #$25
.C:56bc  84 01       STY processor_port_register
hangup_loop:
.C:56be  8D 20 D0    STA vic_border_color_register
.C:56c1  4C BE 56    JMP hangup_loop
;===========================================
; Coalesces all adjacent free blocks
;
; In this context, "adjacent" means "comes immediately after".
; It can be thought of right-adjacency.
;
; 	Arguments:	None
;	Reads:		first_free_block
;				last_free_block
;	Updates: 	last_free_block
;===========================================
block_size = $56c5
free_block = $4f
adjacent_block = $59

coalesce_free_blocks:
;Start with the first block
.C:56c8  AD 63 FF    LDA <first_free_block
.C:56cb  85 4F       STA <free_block
.C:56cd  AD 64 FF    LDA >first_free_block				
.C:56d0  85 50       STA >free_block
;If there's not a first block, exit
.C:56d2  F0 71       BEQ exit
compute_adjacent:
;Read block size
.C:56d4  A0 00       LDY #$00
.C:56d6  B1 4F       LDA (free_block),Y
.C:56d8  8D C5 56    STA <block_size
.C:56db  C8          INY
.C:56dc  B1 4F       LDA (free_block),Y
.C:56de  8D C6 56    STA >block_size
;Calculate the start of the adjacent_block
;By doing: free_block + block_size
.C:56e1  18          CLC
.C:56e2  AD C5 56    LDA <block_size
.C:56e5  65 4F       ADC <free_block
.C:56e7  85 59       STA <adjacent_block
.C:56e9  AD C6 56    LDA >block_size
.C:56ec  65 50       ADC >free_block
.C:56ee  85 5A       STA >adjacent_block
;Get next block 
.C:56f0  20 FF 58    JSR get_next_block
;Is there a next block? If not, exit
.C:56f3  D0 01       BNE adjacency_check
.C:56f5  60          RTS
;Do the next linked block and the next area match?
;That is, are the 2 blocks (the current and the next one) immediately adjacent?
adjacency_check:
.C:56f6  E4 59       CPX <adjacent_block
.C:56f8  D0 02       BNE adjacency_check_2
.C:56fa  C4 5A       CPY >adjacent_block
adjacency_check_2:
.C:56fc  D0 3E       BNE next_block_is_not_adjacent
;They are adjacent, so we will coalesce them into one
;Save .X/.Y into adjacent_block (unnecessary, as they already matched)
.C:56fe  86 59       STX <adjacent_block
.C:5700  84 5A       STY >adjacent_block
;Copy the "next block" pointer from the second block to the first one
;This effectively removes the second block from the list
.C:5702  A0 02       LDY #$02
.C:5704  B1 59       LDA (adjacent_block),Y
.C:5706  91 4F       STA (free_block),Y
.C:5708  C8          INY
.C:5709  B1 59       LDA (adjacent_block),Y
.C:570b  91 4F       STA (free_block),Y
;Add the block sizes, store the result as the coalesced block size
.C:570d  A0 00       LDY #$00
.C:570f  18          CLC
.C:5710  AD C5 56    LDA <block_size
.C:5713  71 59       ADC (adjacent_block),Y		;adjacent_block[0-1] is the adjacent block size
.C:5715  91 4F       STA (free_block),Y
.C:5717  C8          INY
.C:5718  AD C6 56    LDA >block_size
.C:571b  71 59       ADC (adjacent_block),Y
.C:571d  91 4F       STA (free_block),Y
;Was the adjacent block the last free block?
; If not, continue
.C:571f  A5 59       LDA <adjacent_block
.C:5721  CD 65 FF    CMP <last_free_block
.C:5724  D0 11       BNE continue
.C:5726  A5 5A       LDA >adjacent_block
.C:5728  CD 66 FF    CMP >last_free_block
.C:572b  D0 0A       BNE continue
;Yes, it was the last one - then set the coalesced block as the last free block
.C:572d  A5 4F       LDA <free_block
.C:572f  8D 65 FF    STA <last_free_block
.C:5732  A5 50       LDA >free_block
.C:5734  8D 66 FF    STA >last_free_block
continue:
.C:5737  A5 50       LDA >free_block
.C:5739  4C 43 57    JMP is_block_null
next_block_is_not_adjacent:
;The two free blocks are not adjacent - proceed to the next free block
.C:573c  20 FF 58    JSR get_next_block
.C:573f  86 4F       STX <free_block
.C:5741  84 50       STY >free_block
;If the block pointer is not null, continue the analysis
is_block_null:
.C:5743  D0 8F       BNE compute_adjacent
exit:
.C:5745  60          RTS
;===========================================
; Sorts free blocks in AO (Address Order)
;
; Arguments: None
;
; Summary of algorithm (omitting some details):
;
;	-Start with the first free block and its next one
;	-Save the next block as "start_next"
;	-For the current block
;		-Select the next block as successor
;			-Check if the current block and its successor are in AO
;			-If yes, continue with the next's next block as new successor
;			-If no, check if successor is the lowest AO offender we found so far (lowest in address)
;				-If no, ignore it and continue
;				-If yes, save it as the lowest offender
;	-Once the end of the list is reached, check if there's any offender
;	-If so, swap lowest_offender with start_next in the free blocks linked list
;	-Move forward to start's next block and repeat until the list is exhausted
;===========================================
current_block = $4f
start_block = $51
start_next = $53
lowest_offender = $55
selected_prev = $57
prev_block = $5746
next_block = $5748
selected_next = $574a

sort_free_blocks:
;Start by pointing to the free block table
;The pointer to the first free block is on offsets 2-3, just like the pointer to the next block on regular free blocks.
;So, when getting the "next block" from the table, we'll get the first one
.C:574c  A9 61       LDA #$61
.C:574e  85 51       STA <start_block
.C:5750  A9 FF       LDA #$FF
.C:5752  85 52       STA >start_block
setup_comparison:
;Initialize lowest_offender to #FFFF
;This will make any other 16-bit value lower than it 
;Its purpose will be explained later
.C:5754  A9 FF       LDA #$FF
.C:5756  85 55       STA <lowest_offender
.C:5758  85 56       STA >lowest_offender
;We'll actually move to the next block to start the comparisons
;So the current one will become the "previous" block
;Save the previous block
.C:575a  A5 51       LDA <start_block
.C:575c  8D 46 57    STA <prev_block
.C:575f  A5 52       LDA >start_block
.C:5761  8D 47 57    STA >prev_block
;Fetch the next block
;Also, copy it into .X/.Y (effectively copying it into current_block immediately next)
.C:5764  A0 02       LDY #$02
.C:5766  B1 51       LDA (start_block),Y
.C:5768  85 53       STA <start_next
.C:576a  AA          TAX
.C:576b  C8          INY
.C:576c  B1 51       LDA (start_block),Y
.C:576e  85 54       STA >start_next
.C:5770  A8          TAY
.C:5771  D0 03       BNE compare_order
;There isn't a next block, so there's nothing to compare, exit
.C:5773  4C 08 58    JMP no_more_blocks
compare_order:
;In the context of the order comparison, we'll call the current block being compared as "current_block"
;current_block = .X/.Y
;This is either "start_next" (when entering from the setup section above)
; or the former "next_block" (when looping from the next_comparison section below)
.C:5776  86 4F       STX <current_block
.C:5778  84 50       STY >current_block
;Fetch the next block of the current one
.C:577a  20 FF 58    JSR get_next_block
.C:577d  8E 48 57    STX <next_block
.C:5780  8C 49 57    STY >next_block
; Now we need to compare the current_block vs. start_next to see if they are in AO (address order)
; If they are in order, then proceed to the next comparison
; This is done by subtracting one from the other and checking the carry.
;
; In practical terms, if current_block < start_next:
;		-current block has a lower address than start_next
;		-current_block is a successor of start_next in the linked list
;
; This violates AO. In this situation, the carry will be clear.
; If AO is satisfied, instead, the carry will be set
;
; Minor note: in the very first iteration of this comparison loop (compare_order), current_block is equal to start_next
; so the first subtraction will yield zero.
.C:5783  38          SEC
.C:5784  A5 4F       LDA <current_block
.C:5786  E5 53       SBC <start_next
.C:5788  A5 50       LDA >current_block
.C:578a  E5 54       SBC >start_next
.C:578c  B0 29       BCS next_comparison
;AO is not satisfied, so we found an offender
;The algorithm will select the lowest offender among all
;Again, this is done by comparing the current offender vs. the lowest offender
; If current offender < lowest, carry will be clear
.C:578e  38          SEC
.C:578f  A5 4F       LDA <current_block
.C:5791  E5 55       SBC <lowest_offender
.C:5793  A5 50       LDA >current_block
.C:5795  E5 56       SBC >lowest_offender
.C:5797  B0 1E       BCS next_comparison
;We found a new lowest offender, so save it, as well as its previous and next siblings in the linked list
;lowest_offender = current_block
;selected_prev = prev_block
;selected_next = next_block
.C:5799  A5 4F       LDA <current_block
.C:579b  85 55       STA <lowest_offender
.C:579d  A5 50       LDA >current_block
.C:579f  85 56       STA >lowest_offender
.C:57a1  AD 46 57    LDA <prev_block
.C:57a4  85 57       STA <selected_prev
.C:57a6  AD 47 57    LDA >prev_block
.C:57a9  85 58       STA >selected_prev
.C:57ab  AD 48 57    LDA <next_block
.C:57ae  8D 4A 57    STA <selected_next
.C:57b1  AD 49 57    LDA >next_block
.C:57b4  8D 4B 57    STA >selected_next
next_comparison:
;Prepare the next comparison, by updating prev, current and next, 
; moving each of them to their next position in the list.
;prev_block = current_block
.C:57b7  A5 4F       LDA <current_block
.C:57b9  8D 46 57    STA <prev_block
.C:57bc  A5 50       LDA >current_block
.C:57be  8D 47 57    STA >prev_block
;Set next_block in .X/.Y, so it gets stored into current_block when we jump back to compare_order
;Once we jump back, next_block will be also updated accordingly
.C:57c1  AE 48 57    LDX <next_block
.C:57c4  AC 49 57    LDY >next_block
;If the next block is $0000, we reached the end of the list
;So we need to check if block swaps are needed
;Otherwise, jump back, finish updating current and next, and continue
.C:57c7  D0 AD       BNE compare_order
;----------------------------------------
;List navigation finished - check if swaps are needed
;If lowest_offender is not FFxx, then we have at least one offender to remediate
;Note that the memory area used for resources doesn't overlap with FF00-FFFF
;Otherwise, move forward to the next start block and continue
.C:57c9  A5 56       LDA >lowest_offender
.C:57cb  C9 FF       CMP #$FF
.C:57cd  F0 25       BEQ next_start_block
;We have an offender, so a swap of pointers is needed
;Set .Y index as #02, as it's the offset of the "next" pointers in free blocks
.C:57cf  A0 02       LDY #$02
;Swap lowest_offender with start_next
;
; List before the swap:
; start_block -> start_next -> .... -> selected_prev -> lowest_offender -> selected_next
;
; Progress during the swaps:
; start_block -> lowest_offender -> selected_next  AND start_next -> ... -> selected_prev -> lowest_offender -> selected_next
; start_block -> lowest_offender -> selected_next  AND ... -> selected_prev -> start_next -> ...
; start_block -> lowest_offender -> ... -> selected_prev -> start_next -> ...
; start_block -> lowest_offender -> ... -> selected_prev -> start_next -> selected_next
;
; List after the swap:
; start_block -> lowest_offender -> .... -> selected_prev -> start_next -> selected_next
;
; Effectively swapping start_next with lowest_offender
;
;start_block.next = lowest_offender
;selected_prev.next = start_next
;lowest_offender.next = start_next.next
;start_next.next = selected_next
.C:57d1  A5 55       LDA <lowest_offender
.C:57d3  91 51       STA (start_block),Y
.C:57d5  A5 53       LDA <start_next
.C:57d7  91 57       STA (selected_prev),Y
.C:57d9  B1 53       LDA (start_next),Y
.C:57db  91 55       STA (lowest_offender),Y
.C:57dd  AD 4A 57    LDA <selected_next
.C:57e0  91 53       STA (start_next),Y
.C:57e2  C8          INY
.C:57e3  A5 56       LDA >lowest_offender
.C:57e5  91 51       STA (start_block),Y
.C:57e7  A5 54       LDA >start_next
.C:57e9  91 57       STA (selected_prev),Y
.C:57eb  B1 53       LDA (start_next),Y
.C:57ed  91 55       STA (lowest_offender),Y
.C:57ef  AD 4B 57    LDA >selected_next
.C:57f2  91 53       STA (start_next),Y
next_start_block:
;If there's a next block to the start block, move to it and start the comparison process again
.C:57f4  A5 51       LDA <start_block
.C:57f6  85 4F       STA <current_block
.C:57f8  A5 52       LDA >start_block
.C:57fa  85 50       STA >current_block
.C:57fc  20 FF 58    JSR get_next_block
;Otherwise, exit
.C:57ff  F0 07       BEQ no_more_blocks
;There is a next block, so set it as the new start block
.C:5801  86 51       STX <start_block
.C:5803  84 52       STY >start_block
.C:5805  4C 54 57    JMP setup_comparison
no_more_blocks:
.C:5808  A5 51       LDA <start_block
.C:580a  8D 65 FF    STA <last_free_block						
.C:580d  A5 52       LDA >start_block
.C:580f  8D 66 FF    STA >last_free_block
.C:5812  60          RTS
;===========================================
; Get a free block for a given data size
;
; Arguments:	raw_data_size
;	Reads:	first_free_block
;===========================================
raw_data_size = $fd9c
size_needed = $5819
free_block = $4f

get_free_block:
.C:581b  8E 9C FD    STX <raw_data_size
.C:581e  8C 9D FD    STY >raw_data_size
;Compute the size needed by doing raw_data_size + memory block header size (4 bytes)
.C:5821  18          CLC
.C:5822  AD 9C FD    LDA <raw_data_size
.C:5825  69 04       ADC #$04
.C:5827  8D 19 58    STA <size_needed
.C:582a  AD 9D FD    LDA >raw_data_size
.C:582d  69 00       ADC #$00
.C:582f  8D 1A 58    STA >size_needed
;Start with the first free block
.C:5832  AD 63 FF    LDA <first_free_block
.C:5835  85 4F       STA <free_block
.C:5837  AD 64 FF    LDA >first_free_block
.C:583a  85 50       STA >free_block
;If free block is non-zero, there's at least 1 free block, find the best one
.C:583c  D0 01       BNE find_best_free_block
;Pointer is zero, so there are no free blocks
;Return with Z flag set
.C:583e  60          RTS
;===========================================
; Finds the best free block for a given data size
;
; "Best" means the smallest one available
;
; Arguments: size_needed
;			free_block		
;				
;===========================================
best_free_block = $5813
best_free_size = $5815
candidate_free_size = $56c5
free_block = $4f
prev_block = $5817
unused = $51

find_best_free_block:
;Init best free size as #FFFF
.C:583f  A9 FF       LDA #$FF
.C:5841  8D 15 58    STA <best_free_size
.C:5844  8D 16 58    STA >best_free_size
;Init best free block pointer to $0000
.C:5847  A9 00       LDA #$00
.C:5849  8D 13 58    STA <best_free_block
.C:584c  A9 00       LDA #$00
.C:584e  8D 14 58    STA >best_free_block
;Init last free block pointer
.C:5851  A9 61       LDA #$61
.C:5853  8D 17 58    STA <prev_block
.C:5856  A9 FF       LDA #$FF
.C:5858  8D 18 58    STA >prev_block
;--------------------------------
check_candidate_free_block:
;Load candidate block free size (which is stored in bytes 0 and 1, at the beginning of the free block)
.C:585b  A0 00       LDY #$00
.C:585d  B1 4F       LDA (<free_block),Y
.C:585f  8D C5 56    STA <candidate_free_size
.C:5862  C8          INY
.C:5863  B1 4F       LDA (<free_block),Y
.C:5865  8D C6 56    STA >candidate_free_size
;Compare size needed vs. candidate's free size by doing a subtraction
.C:5868  38          SEC
.C:5869  AD C5 56    LDA <candidate_free_size
.C:586c  ED 19 58    SBC <size_needed
.C:586f  AD C6 56    LDA >candidate_free_size
.C:5872  ED 1A 58    SBC >size_needed
;Carry clear means: size_needed > candidate_free_size - so the data doesn't fit, proceed to next free block
.C:5875  90 32       BCC move_to_next_block
;--------------------------------
; DATA FITS
;Carry set: candidate_free_size > size_needed - data fits, check if this block is smaller than the minimum
;Compare minimum free size vs. current free size by doing a subtraction
.C:5877  38          SEC
.C:5878  AD 15 58    LDA <best_free_size
.C:587b  ED C5 56    SBC <candidate_free_size
.C:587e  AD 16 58    LDA >best_free_size
.C:5881  ED C6 56    SBC >candidate_free_size
;Carry clear - candidate_free_size > best_free_size - it's not a minimum, so proceed to next free block
.C:5884  90 23       BCC move_to_next_block
;--------------------------------
; NEW MINIMUM
;Carry set - we have a new minimum
;Read the next entry in the free block pointer list into .X, .Y
;This call seems unnecessary
.C:5886  20 FF 58    JSR get_next_block			;Of the free block
;Set the candidate free size as the new best
.C:5889  AD C5 56    LDA <candidate_free_size
.C:588c  8D 15 58    STA <best_free_size
.C:588f  AD C6 56    LDA >candidate_free_size
.C:5892  8D 16 58    STA >best_free_size
;Save the free block as the best free block
.C:5895  A5 4F       LDA <free_block
.C:5897  8D 13 58    STA <best_free_block
.C:589a  A5 50       LDA >free_block
.C:589c  8D 14 58    STA >best_free_block
; Purpose unknown - "unused" is not used in this routine or its subroutines
; Probably leftover debugging code
.C:589f  AD 17 58    LDA <prev_block
.C:58a2  85 51       STA <unused
.C:58a4  AD 18 58    LDA >prev_block
.C:58a7  85 52       STA >unused
;--------------------------------
move_to_next_block:
; Save the current block as the new prev (again, not really used)
.C:58a9  A5 4F       LDA <free_block
.C:58ab  8D 17 58    STA <prev_block
.C:58ae  A5 50       LDA >free_block
.C:58b0  8D 18 58    STA >prev_block
;Get the next free block
.C:58b3  20 FF 58    JSR get_next_block
.C:58b6  86 4F       STX <free_block
.C:58b8  84 50       STY >free_block
;Is it non-zero? If so, there's another free block to analyze
.C:58ba  D0 9F       BNE check_candidate_free_block
;--------------------------------
; NO MORE FREE BLOCKS
;The best block is the block we need to return
.C:58bc  AD 13 58    LDA <best_free_block
.C:58bf  85 4F       STA <free_block
.C:58c1  AD 14 58    LDA >best_free_block
.C:58c4  85 50       STA >free_block
;Do we have a non-null free block?
.C:58c6  D0 01       BNE free_block_found
;It's null - return, as we couldn't find a free block
;On return, Z flag will be set
.C:58c8  60          RTS
;--------------------------------
free_block_found:
;Allocate the memory
.C:58c9  20 09 59    JSR allocate_block
;Load the allocated memory pointer into .X/.Y and return
.C:58cc  AE 13 58    LDX <best_free_block
.C:58cf  AC 14 58    LDY >best_free_block
;On return, Z flag will be clear
.C:58d2  60          RTS
;===========================================
; Compact free memory and release resources
; as need to make room for a given data size.
;===========================================
size = $58d3

compact_and_release:
.C:58d5  AD 9C FD    LDA <raw_data_size
.C:58d8  8D D3 58    STA <size
.C:58db  AD 9D FD    LDA >raw_data_size
.C:58de  8D D4 58    STA >size
.C:58e1  A9 FF       LDA #$FF
.C:58e3  8D 9C FD    STA <raw_data_size
.C:58e6  A9 FF       LDA #$FF
.C:58e8  8D 9D FD    STA >raw_data_size
;Defragment memory
.C:58eb  20 AA 59    JSR move_free_blocks_to_back
;Find a free block for this size
.C:58ee  AE D3 58    LDX <size
.C:58f1  AC D4 58    LDY >size
.C:58f4  20 1B 58    JSR get_free_block
;Did we find anything?
.C:58f7  D0 05       BNE free_block_found
;No free block found - release resources and try again
.C:58f9  20 E3 5A    JSR release_rsrcs_by_priority
.C:58fc  D0 D7       BNE compact_and_release
;We found a free block, return
free_block_found:
.C:58fe  60          RTS
;===========================================
; Get pointer to the next block
;
; Arguments: block_ptr	pointer to current block
; Returns:	.X/.Y		pointer to next block
;===========================================
block_ptr = $4f

get_next_block:
.C:58ff  A0 02       LDY #$02
.C:5901  B1 4F       LDA (block_ptr),Y
.C:5903  AA          TAX
.C:5904  C8          INY
.C:5905  B1 4F       LDA (block_ptr),Y
.C:5907  A8          TAY
.C:5908  60          RTS
;===========================================
; Allocates a block of free memory
;
; Arguments:	min_free_block_size		Size of desired block
;				raw_data_size			Size of raw data
; 
;===========================================
free_block_size = $5815
free_block = $4f
raw_data_size = $fd9c
remaining_free_space = $56c5
new_free_block = $55
temp = $56c7

allocate_block:
;Compute remaining free space by subtracting the consumed space from the available space
; remaining_free_space = free_block_size - raw_data_size
.C:5909  38          SEC
.C:590a  AD 15 58    LDA <free_block_size
.C:590d  ED 9C FD    SBC <raw_data_size
.C:5910  8D C5 56    STA <remaining_free_space
.C:5913  AD 16 58    LDA >free_block_size
.C:5916  ED 9D FD    SBC >raw_data_size
.C:5919  8D C6 56    STA >remaining_free_space
;Check if remaining_free_space > #04, as we need space for the block metadata
.C:591c  38          SEC
.C:591d  AD C5 56    LDA <remaining_free_space
.C:5920  E9 04       SBC #$04
.C:5922  AD C6 56    LDA >remaining_free_space
.C:5925  E9 00       SBC #$00
.C:5927  90 3B       BCC no_space_for_metadata
;--------------------------------
;Carry set - free space > #04
;Compute the end of the allocated block, which becomes the new beginning of a free block
; new_free_block = free_block + raw_data_size
.C:5929  18          CLC
.C:592a  A5 4F       LDA <free_block
.C:592c  6D 9C FD    ADC <raw_data_size
.C:592f  85 55       STA <new_free_block
.C:5931  A5 50       LDA >free_block
.C:5933  6D 9D FD    ADC >raw_data_size
.C:5936  85 56       STA >new_free_block
;Save pointer to new free block
.C:5938  A0 02       LDY #$02
.C:593a  A5 55       LDA <new_free_block
.C:593c  91 51       STA (free_block_table_lo),Y
.C:593e  C8          INY
.C:593f  A5 56       LDA >new_free_block
.C:5941  91 51       STA (free_block_table_lo),Y
;Read the pointer to the next block (from the current free block metadata) into .X, .Y
.C:5943  20 FF 58    JSR get_next_block
;Store pointer to next block lo/hi in offsets #02 and #03 of the new free block
.C:5946  8C C7 56    STY temp
.C:5949  A0 02       LDY #$02
.C:594b  8A          TXA
.C:594c  91 55       STA (new_free_block),Y
.C:594e  C8          INY
.C:594f  AD C7 56    LDA temp
.C:5952  91 55       STA (new_free_block),Y
;Store remaining free space in offsets #00 and #01 of the new free block
.C:5954  A0 00       LDY #$00
.C:5956  AD C5 56    LDA <remaining_free_space
.C:5959  91 55       STA (new_free_block),Y
.C:595b  C8          INY
.C:595c  AD C6 56    LDA >remaining_free_space
.C:595f  91 55       STA (new_free_block),Y
.C:5961  4C 89 59    JMP last_block_adjustment_check
;--------------------------------
no_space_for_metadata:
;Carry clear - free space < #0004
;Read the pointer to the next block into .X, .Y
.C:5964  20 FF 58    JSR get_next_block
;Store pointer to next block lo/hi in offsets #02 and #03 of the free block table
.C:5967  8C C7 56    STY temp
.C:596a  A0 02       LDY #$02
.C:596c  8A          TXA
.C:596d  91 51       STA (free_block_table_lo),Y
.C:596f  C8          INY
.C:5970  AD C7 56    LDA temp
.C:5973  91 51       STA (free_block_table_lo),Y
;raw_data_size = free_block_size
.C:5975  AD 15 58    LDA <free_block_size
.C:5978  8D 9C FD    STA <raw_data_size
.C:597b  AD 16 58    LDA >free_block_size
.C:597e  8D 9D FD    STA >raw_data_size
;new_free_block = free_block_table
.C:5981  A5 51       LDA free_block_table_lo
.C:5983  85 55       STA <new_free_block
.C:5985  A5 52       LDA free_block_table_hi
.C:5987  85 56       STA >new_free_block
;--------------------------------
last_block_adjustment_check:
;Is this free block the last one? 
; If not, exit
.C:5989  AD 65 FF    LDA <prev_block
.C:598c  C5 4F       CMP <free_block
.C:598e  D0 05       BNE last_block_check_2
.C:5990  AD 66 FF    LDA >prev_block
.C:5993  C5 50       CMP >free_block
last_block_check_2:
.C:5995  D0 0A       BNE exit
;We have just allocated from the last free block, so we need to update it
; prev_block = new_free_block
.C:5997  A5 55       LDA <new_free_block
.C:5999  8D 65 FF    STA <prev_block
.C:599c  A5 56       LDA >new_free_block
.C:599e  8D 66 FF    STA >prev_block
exit:
.C:59a1  60          RTS
;===========================================
; Resource copy setup
;
; Arguments: 
;===========================================
free_block = $4f
adjacent_block = $57
free_block_size = $59a2
next_block = $59a6

move_free_blocks_to_back:
;Start with the first free block
.C:59aa  AD 63 FF    LDA <first_free_block
.C:59ad  85 4F       STA <free_block
.C:59af  AD 64 FF    LDA >first_free_block
.C:59b2  85 50       STA >free_block
;Fetch the block size
.C:59b4  A0 00       LDY #$00
.C:59b6  B1 4F       LDA (free_block),Y
.C:59b8  8D A2 59    STA <free_block_size
.C:59bb  C8          INY
.C:59bc  B1 4F       LDA (free_block),Y
.C:59be  8D A3 59    STA >free_block_size
;Compute the adjacent block
;Adjacent block = free_block + block_size
.C:59c1  18          CLC
.C:59c2  A5 4F       LDA <free_block
.C:59c4  6D A2 59    ADC <free_block_size
.C:59c7  85 57       STA <adjacent_block
.C:59c9  A5 50       LDA >free_block
.C:59cb  6D A3 59    ADC >free_block_size
.C:59ce  85 58       STA >adjacent_block
;Get free_block->next into .X/.Y
.C:59d0  20 FF 58    JSR get_next_block
;Is there a next block? If not, we exhausted the list
.C:59d3  D0 01       BNE next_block_present
.C:59d5  60          RTS
;There is a next block
next_block_present:
.C:59d6  8E A6 59    STX <next_block
.C:59d9  8C A7 59    STY >next_block
;Invoke move_to_back, passing the current block, its next one in the list and its adjacent one
.C:59dc  20 E5 59    JSR move_to_back
.C:59df  20 C8 56    JSR coalesce_free_blocks
.C:59e2  4C AA 59    JMP move_free_blocks_to_back
;===========================================
; Move the first free block "to the back" of memory space
;
; While the first free block is adjacent to a used block on the right, it swaps them around. 
; As soon as no blocks are left, or another free block is found adjacent to the right, it stops. 
; The ultimate goal is to make all free blocks adjacent, so they can be coalesced.
;
; When invoked: 
;				source = a free block's adjacent_block (which must be a used block)
;				destination = current (a free block)
;				next_block = current->next (another free block)
;
; Arguments: 
;			source			pointer to source block
;			destination		pointer to destination block
;			next_block		pointer to source->next
;			resource_type	
;			resource_index 
;===========================================
source = $57
destination = $4f
next_block = $59a6
resource_type = $59a8
resource_index = $59a9
free_block_size = $59a2

block_size = $59a4

move_to_back:
;Fetch the resource metadata to prepare the copy
.C:59e5  A0 00       LDY #$00
;Fetch bytes on last page (payload size lo)
.C:59e7  B1 57       LDA (source),Y
.C:59e9  8D A4 59    STA <block_size
.C:59ec  C8          INY
;Fetch total pages (payload size hi)
.C:59ed  B1 57       LDA (source),Y
.C:59ef  8D A5 59    STA >block_size
.C:59f2  C8          INY
;Fetch resource type
.C:59f3  B1 57       LDA (source),Y
.C:59f5  8D A8 59    STA resource_type
.C:59f8  48          PHA
.C:59f9  C8          INY
;Fetch resource index
.C:59fa  B1 57       LDA (source),Y
.C:59fc  8D A9 59    STA resource_index
.C:59ff  A8          TAY
.C:5a00  68          PLA
;Is it a sound? If not, continue
.C:5a01  C9 06       CMP #$06
.C:5a03  D0 0A       BNE copy_block_data
;Is the sound in use? If not, continue
.C:5a05  B9 51 79    LDA sound_memory_attrs,Y
.C:5a08  F0 05       BEQ copy_block_data
;It's a sound possibly in use - reload sound resource pointers
.C:5a0a  A9 01       LDA #$01
.C:5a0c  8D 70 FE    STA reload_snd_rsrc_ptrs
;-------------------
copy_block_data:
;Setup arguments for mem_copy_memory ($5B-$60)
;Bytes to copy on the last page
.C:5a0f  AD A4 59    LDA <block_size
.C:5a12  85 5B       STA $5B
;Total pages
.C:5a14  AD A5 59    LDA >block_size
.C:5a17  85 5C       STA $5C
;Read pointer
.C:5a19  A5 57       LDA <source
.C:5a1b  85 5D       STA $5D
.C:5a1d  A5 58       LDA >source
.C:5a1f  85 5E       STA $5E
;Write pointer
.C:5a21  A5 4F       LDA <destination
.C:5a23  85 5F       STA $5F
.C:5a25  A5 50       LDA >destination
.C:5a27  85 60       STA $60
;Do the memory copy
.C:5a29  20 13 5C    JSR mem_copy_memory
;-------------------
;Update resource pointers after relocation
.C:5a2c  AE A9 59    LDX resource_index
.C:5a2f  AC A8 59    LDY resource_type
.C:5a32  20 89 5A    JSR update_rsrc_pointers
;Don't reload the sound resource pointers
.C:5a35  A9 00       LDA #$00
.C:5a37  8D 70 FE    STA reload_snd_rsrc_ptrs
;Add the used block size to both source and destination
;Before the copy, they were spaced apart exactly as the free block size, and they still are
;Source now points to the used block's adjacent block (pre-copy)
;And destination points to the free block's adjacent block (pre-copy)
;
;In practical terms, destination now points to the start of the moved free block
;And source points to the start of whatever came after the used block
.C:5a3a  18          CLC
.C:5a3b  A5 4F       LDA <destination
.C:5a3d  6D A4 59    ADC <block_size
.C:5a40  85 4F       STA <destination
.C:5a42  A5 50       LDA >destination
.C:5a44  6D A5 59    ADC >block_size
.C:5a47  85 50       STA >destination
.C:5a49  18          CLC
.C:5a4a  A5 57       LDA <source
.C:5a4c  6D A4 59    ADC <block_size
.C:5a4f  85 57       STA <source
.C:5a51  A5 58       LDA >source
.C:5a53  6D A5 59    ADC >block_size
.C:5a56  85 58       STA >source
; Next_block (the next free block) can either:
; -come immediately after the moved free block
; -come "later", with at least one block in between
; If it comes later, then there's at least one used block in the middle and we can move it to the front
; If it comes immediately, we now have two consecutive free blocks, which can be coalesced
; 
; Find out which scenario is happening
.C:5a58  38          SEC
.C:5a59  A5 57       LDA <source
.C:5a5b  ED A6 59    SBC <next_block
.C:5a5e  A5 58       LDA >source
.C:5a60  ED A7 59    SBC >next_block
;Carry clear: next_block > source
; next_block comes later, keep moving resources to the front
.C:5a63  90 80       BCC move_to_back
;Carry set: source >= next_block (specifically, should be equal to)
;So we have 2 adjacent free blocks that we can coalesce
;We need to wrap up operations and return
;
;Update the first free block
.C:5a65  A5 4F       LDA <destination
.C:5a67  8D 63 FF    STA <first_free_block
.C:5a6a  A5 50       LDA >destination
.C:5a6c  8D 64 FF    STA >first_free_block
;Copy the original free block metadata (size and pointer to next) to the destination
.C:5a6f  A0 00       LDY #$00
.C:5a71  AD A2 59    LDA <free_block_size
.C:5a74  91 4F       STA (destination),Y
.C:5a76  C8          INY
.C:5a77  AD A3 59    LDA >free_block_size
.C:5a7a  91 4F       STA (destination),Y
.C:5a7c  C8          INY
.C:5a7d  AD A6 59    LDA <next_block
.C:5a80  91 4F       STA (destination),Y
.C:5a82  C8          INY
.C:5a83  AD A7 59    LDA >next_block
.C:5a86  91 4F       STA (destination),Y
.C:5a88  60          RTS
;===========================================
; Update resource pointers after relocation
;
; Argument: 	resource_ptr
;				resource_type		.Y
;				resource_index		.X
;===========================================
resource_ptr = $4F

update_rsrc_pointers:
;Switch on the resource type
.C:5a89  C0 03       CPY #$03
.C:5a8b  D0 0B       BNE check_type_4
;------------------
;Case 3 (room)
.C:5a8d  A5 4F       LDA <resource_ptr
.C:5a8f  9D 2A 78    STA room_rsrc_ptrs_lo,X
.C:5a92  A5 50       LDA >resource_ptr
.C:5a94  9D F3 77    STA room_rsrc_ptrs_hi,X
.C:5a97  60          RTS
;------------------
check_type_4:
.C:5a98  C0 04       CPY #$04
.C:5a9a  D0 0B       BNE check_type_2
;------------------
;Case 4 (room scene graphics layers)
.C:5a9c  A5 4F       LDA <resource_ptr
.C:5a9e  9D 79 7B    STA room_layers_rsrc_lo,X
.C:5aa1  A5 50       LDA >resource_ptr
.C:5aa3  9D 77 7B    STA room_layers_rsrc_hi,X
.C:5aa6  60          RTS
;------------------
check_type_2:
.C:5aa7  C0 02       CPY #$02
.C:5aa9  D0 0B       BNE check_type_1
;------------------
;Case 2 (costume)
.C:5aab  A5 4F       LDA <resource_ptr
.C:5aad  9D 7A 78    STA costume_rsrc_ptrs_lo,X
.C:5ab0  A5 50       LDA >resource_ptr
.C:5ab2  9D 61 78    STA costume_rsrc_ptrs_hi,X
.C:5ab5  60          RTS
;------------------
check_type_1:
.C:5ab6  C0 01       CPY #$01
.C:5ab8  D0 0B       BNE check_type_5
;------------------
;Case 1 (object)
.C:5aba  A5 4F       LDA <resource_ptr
.C:5abc  9D 5E 70    STA object_rsrc_ptrs_lo,X
.C:5abf  A5 50       LDA >resource_ptr
.C:5ac1  9D 8B 70    STA object_rsrc_ptrs_hi,X
.C:5ac4  60          RTS
;------------------
check_type_5:
.C:5ac5  C0 05       CPY #$05
.C:5ac7  D0 0B       BNE check_type_6
;------------------
;Case 5 (script)
.C:5ac9  A5 4F       LDA <resource_ptr
.C:5acb  9D 37 7A    STA script_rsrc_ptrs_lo,X
.C:5ace  A5 50       LDA >resource_ptr
.C:5ad0  9D 97 79    STA script_rsrc_ptrs_hi,X
.C:5ad3  60          RTS
;------------------
check_type_6:
.C:5ad4  C0 06       CPY #$06
.C:5ad6  D0 0B       BNE release_rsrcs_by_priority
;------------------
;Case 6 (sound)
.C:5ad8  A5 4F       LDA <resource_ptr
.C:5ada  9D 0B 79    STA sound_rsrc_ptrs_lo,X
.C:5add  A5 50       LDA >resource_ptr
.C:5adf  9D C5 78    STA sound_rsrc_ptrs_hi,X
.C:5ae2  60          RTS
;===========================================
; Release resources by priority
; Will attempt to release resources in this order:
;	-a room
;	-a costume
;	-all evictable sounds
;	-all evictable scripts
;
;	Output:		result	boolean in .A (#00 or #FF)
;===========================================
current_priority = $fe4b
old_priority = $fe4c

release_rsrcs_by_priority:
;Set that no resource has been released yet
.C:5ae3  A9 00       LDA #$00
.C:5ae5  8D 4A FE    STA rsrc_has_been_released
;Save the current priority
.C:5ae8  AD 4B FE    LDA current_priority
.C:5aeb  8D 4C FE    STA old_priority
switch_on_priority:
;Switch on the current priority
.C:5aee  AD 4B FE    LDA current_priority
.C:5af1  C9 00       CMP #$00
.C:5af3  D0 06       BNE check_01
;------------------
;Case #00 - release one room
.C:5af5  20 38 5B    JSR release_room_lru
.C:5af8  4C 22 5B    JMP next_priority
;------------------
check_01:
.C:5afb  C9 01       CMP #$01
.C:5afd  D0 06       BNE check_02
;------------------
;Case #01 - release one costume
.C:5aff  20 84 5B    JSR release_costume
.C:5b02  4C 22 5B    JMP next_priority
;------------------
check_02:
.C:5b05  C9 02       CMP #$02
.C:5b07  D0 06       BNE check_03
;------------------
;Case #02 - release evictable sounds
.C:5b09  20 B5 5B    JSR release_sounds
.C:5b0c  4C 22 5B    JMP next_priority
;------------------
check_03:
.C:5b0f  C9 03       CMP #$03
.C:5b11  D0 06       BNE check_04
;------------------
;Case #03 - release evictable scripts
.C:5b13  20 EA 5B    JSR release_scripts
.C:5b16  4C 22 5B    JMP next_priority
;------------------
check_04:
.C:5b19  C9 04       CMP #$04
.C:5b1b  90 05       BCC next_priority
;------------------
;Case >= #04 - wrap around
;Set priority as #FF so the INC below sets it back to #00
.C:5b1d  A9 FF       LDA #$FF
.C:5b1f  8D 4B FE    STA current_priority
;------------------
next_priority:
.C:5b22  EE 4B FE    INC current_priority
;Has a resource been released? If not, continue
.C:5b25  AD 4A FE    LDA rsrc_has_been_released
.C:5b28  F0 03       BEQ no_releases
;If so, return True (#FF)
.C:5b2a  A9 FF       LDA #$FF
.C:5b2c  60          RTS
;No resource release yet - Check if we have cycled back to the old priority
no_releases:
.C:5b2d  AD 4B FE    LDA current_priority
.C:5b30  CD 4C FE    CMP old_priority
;If not, continue
.C:5b33  D0 B9       BNE switch_on_priority
;We completed a cycle and nothing could be released
;Return False (#00)
.C:5b35  A9 00       LDA #$00
.C:5b37  60          RTS
;===========================================
; Release the LRU room eligible for eviction
;
; Arguments: None
; Reads:	room_memory_attrs
;			room_rsrc_ptrs
; Updates:	room_memory_attrs
;			room_rsrc_ptrs

;===========================================
MAX_ROOM_INDEX = #$36

candidate_attrs = $fd9f
candidate_index = $fd9e

release_room_lru:
.C:5b38  A9 00       LDA #$00
.C:5b3a  8D 9F FD    STA candidate_attrs
.C:5b3d  8D 9E FD    STA candidate_index
.C:5b40  A2 36       LDX MAX_ROOM_INDEX
;------------------
check_eligibility:
;Check if the room is loaded into memory - if not, continue
.C:5b42  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:5b45  F0 16       BEQ next_room
;Is the room resource locked? - if so, continue
.C:5b47  BD BC 77    LDA room_memory_attrs,X
.C:5b4a  30 11       BMI next_room
;Check if the memory attribute is zero - if so, continue
.C:5b4c  C9 00       CMP #$00
.C:5b4e  F0 0D       BEQ next_room
;We now have a candidate - find out if it's the LRU (Least Recently Used)
;Compare room's memory attr against candidate's memory attr
.C:5b50  CD 9F FD    CMP candidate_attrs
;If room's <= candidate's, continue
.C:5b53  90 08       BCC next_room
.C:5b55  F0 06       BEQ next_room
;Room's attr > candidate's, set this room as new candidate
.C:5b57  8D 9F FD    STA candidate_attrs
.C:5b5a  8E 9E FD    STX candidate_index
;------------------
next_room:
.C:5b5d  CA          DEX
.C:5b5e  D0 E2       BNE check_eligibility
.C:5b60  AD 9E FD    LDA candidate_index
.C:5b63  D0 01       BNE release_room
.C:5b65  60          RTS
;------------------
release_room:
.C:5b66  AE 9E FD    LDX candidate_index
;Fetch the pointer to the resource into .A/.Y
.C:5b69  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:5b6c  A8          TAY
.C:5b6d  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:5b70  48          PHA
;Clear reference to resource
.C:5b71  A9 00       LDA #$00
.C:5b73  9D F3 77    STA room_rsrc_ptrs_hi,X
.C:5b76  9D 2A 78    STA room_rsrc_ptrs_lo,X
;Clear memory attributes
.C:5b79  A9 00       LDA #$00
.C:5b7b  9D BC 77    STA room_memory_attrs,X
;Restore resource pointer lo as .X
.C:5b7e  68          PLA
.C:5b7f  AA          TAX
;Release the memory in .X/.Y and exit
.C:5b80  20 03 55    JSR release_resource
.C:5b83  60          RTS
;===========================================
; Release one costume eligible for eviction
;
; Arguments: None
; Reads:	costume_memory_attrs
;			costume_rsrc_ptrs
; Updates:	costume_memory_attrs
;			costume_rsrc_ptrs
;===========================================
MAX_costume_index = #$18

release_costume:
.C:5b84  A2 18       LDX MAX_costume_index
check_eligibility:
;Check if the costume is loaded into memory - if not, continue
.C:5b86  BD 61 78    LDA costume_rsrc_ptrs_hi,X
.C:5b89  F0 26       BEQ next_costume
;Check if the costume is in the current room - if not, continue
.C:5b8b  BD FC FE    LDA room_for_character,X
.C:5b8e  CD 49 71    CMP current_room
.C:5b91  F0 1E       BEQ next_costume
;Check if the memory attributes are zero - if not, continue
.C:5b93  BD A3 77    LDA costume_memory_attrs,X
.C:5b96  D0 19       BNE next_costume
;------------------
;Fetch the pointer to the resource into .A/.Y
.C:5b98  BD 61 78    LDA costume_rsrc_ptrs_hi,X
.C:5b9b  A8          TAY
.C:5b9c  BD 7A 78    LDA costume_rsrc_ptrs_lo,X
;Save .A in stack
.C:5b9f  48          PHA
;Clear reference to resource
.C:5ba0  A9 00       LDA #$00
.C:5ba2  9D 7A 78    STA costume_rsrc_ptrs_lo,X
.C:5ba5  9D 61 78    STA costume_rsrc_ptrs_hi,X
;Clear memory attributes
.C:5ba8  9D A3 77    STA costume_memory_attrs,X
;Restore resource pointer lo as .X
.C:5bab  68          PLA
.C:5bac  AA          TAX
;Release the memory in .X/.Y and exit
.C:5bad  20 03 55    JSR release_resource
.C:5bb0  60          RTS
;------------------
next_costume:
.C:5bb1  CA          DEX
.C:5bb2  D0 D2       BNE check_eligibility
.C:5bb4  60          RTS
;===========================================
; Release all sounds eligible for eviction
;
; Arguments: None
; Reads:	sound_memory_attrs
;			sound_rsrc_ptrs
; Updates:	sound_memory_attrs
;			sound_rsrc_ptrs
;===========================================
MAX_SOUND_INDEX = #$45

release_sounds:
.C:5bb5  A2 45       LDX MAX_SOUND_INDEX
check_eligibility:
;Check the memory attributes
;If non-zero, continue with next sound
.C:5bb7  BD 51 79    LDA sound_memory_attrs,X
.C:5bba  D0 2A       BNE next_sound
;Check if the sound is loaded into memory - if not, continue
.C:5bbc  BD C5 78    LDA sound_rsrc_ptrs_hi,X
.C:5bbf  F0 25       BEQ next_sound
;Sounds 3, 4 and 5 are not releaseable
.C:5bc1  E0 03       CPX #$03
.C:5bc3  F0 21       BEQ next_sound
.C:5bc5  E0 04       CPX #$04
.C:5bc7  F0 1D       BEQ next_sound
.C:5bc9  E0 05       CPX #$05
.C:5bcb  F0 19       BEQ next_sound
;------------------
;We found an eligible sound
;Save sound index in stack
.C:5bcd  8A          TXA
.C:5bce  48          PHA
;Fetch the pointer to the resource into .A/.Y
.C:5bcf  BD C5 78    LDA sound_rsrc_ptrs_hi,X
.C:5bd2  A8          TAY
.C:5bd3  BD 0B 79    LDA sound_rsrc_ptrs_lo,X
;Save .A in stack
.C:5bd6  48          PHA
;Clear reference to resource
.C:5bd7  A9 00       LDA #$00
.C:5bd9  9D 0B 79    STA sound_rsrc_ptrs_lo,X
.C:5bdc  9D C5 78    STA sound_rsrc_ptrs_hi,X
;Restore resource pointer lo as .X
.C:5bdf  68          PLA
.C:5be0  AA          TAX
;Release the memory in .X/.Y
.C:5be1  20 03 55    JSR release_resource
;Restore sound index and continue
.C:5be4  68          PLA
.C:5be5  AA          TAX
;------------------
next_sound:
.C:5be6  CA          DEX
.C:5be7  D0 CE       BNE check_eligibility
.C:5be9  60          RTS
;===========================================
; Release all scripts eligible for eviction
;
; Arguments: None
; Reads:	script_memory_attrs
;			script_rsrc_ptrs
; Updates:	script_memory_attrs
;			script_rsrc_ptrs
;===========================================
MAX_SCRIPT_INDEX = #$9F

release_scripts:
.C:5bea  A2 9F       LDX MAX_SCRIPT_INDEX
check_eligibility:
;Check the memory attributes
;If non-zero, continue with next script
.C:5bec  BD D7 7A    LDA script_memory_attrs,X
.C:5bef  D0 1E       BNE next_script
;Check if the script is loaded into memory - if not, continue
.C:5bf1  BD 97 79    LDA script_rsrc_ptrs_hi,X
.C:5bf4  F0 19       BEQ next_script
;------------------
;We found a loaded script that has a memory attribute of #00
;Save script index in stack
.C:5bf6  8A          TXA
.C:5bf7  48          PHA
;Fetch the pointer to the resource into .A/.Y
.C:5bf8  BD 97 79    LDA script_rsrc_ptrs_hi,X
.C:5bfb  A8          TAY
.C:5bfc  BD 37 7A    LDA script_rsrc_ptrs_lo,X
;Save .A in stack
.C:5bff  48          PHA
;Clear reference to resource
.C:5c00  A9 00       LDA #$00
.C:5c02  9D 37 7A    STA script_rsrc_ptrs_lo,X
.C:5c05  9D 97 79    STA script_rsrc_ptrs_hi,X
;Restore resource pointer lo as .X
.C:5c08  68          PLA
.C:5c09  AA          TAX
;Release the memory in .X/.Y
.C:5c0a  20 03 55    JSR release_resource
;Restore script index and continue
.C:5c0d  68          PLA
.C:5c0e  AA          TAX
;------------------
next_script:
.C:5c0f  CA          DEX
.C:5c10  D0 DA       BNE check_eligibility
.C:5c12  60          RTS
;===========================================
; Copy memory between locations
;
; Arguments:
;				read_ptr
;				write_ptr
;				total_pages 		blocks of 256 bytes to copy
;				page_bytes_to_copy	bytes to copy for the last page
;===========================================
page_bytes_to_copy = $5B
total_pages = $5C
read_ptr = $5D
write_ptr = $5F

mem_copy_memory:
;Save byte count of last page in stack
.C:5c13  A5 5B       LDA page_bytes_to_copy
.C:5c15  48          PHA
.C:5c16  A6 5C       LDX total_pages
next_page:
.C:5c18  F0 07       BEQ last_page
;Not the last page, set page_bytes_to_copy to #00 to copy the full page
.C:5c1a  A9 00       LDA #$00
.C:5c1c  85 5B       STA page_bytes_to_copy
.C:5c1e  4C 27 5C    JMP copy_page
;It's the last page, copy only the desired number of bytes
last_page:
.C:5c21  68          PLA
.C:5c22  85 5B       STA page_bytes_to_copy
.C:5c24  D0 01       BNE copy_page
.C:5c26  60          RTS
copy_page:
.C:5c27  A0 00       LDY #$00
;Copy from read_ptr to write_ptr until .Y reaches page_bytes_to_copy
copy_loop:
.C:5c29  B1 5D       LDA (read_ptr),Y
.C:5c2b  91 5F       STA (write_ptr),Y
.C:5c2d  C8          INY
.C:5c2e  C4 5B       CPY page_bytes_to_copy
.C:5c30  D0 F7       BNE copy_loop
;Page copy finished, move the hi pointers to copy the next page
.C:5c32  E6 5E       INC >read_ptr
.C:5c34  E6 60       INC >write_ptr
.C:5c36  CA          DEX
.C:5c37  10 DF       BPL next_page
.C:5c39  60          RTS
;===========================================
SAVED_GAME_DISK_ID = #$33
disk_id = $15

save_state_to_disk:
.C:5c3b  20 FC 5C    JSR load_and_validate_disk_id
;Set the saved game Disk ID
.C:5c3e  A9 33       LDA SAVED_GAME_DISK_ID
.C:5c40  85 15       STA disk_id
;Write the disk ID as the first byte on track 1, sector 0
.C:5c42  A2 00       LDX #$00
.C:5c44  A0 01       LDY #$01
.C:5c46  20 D3 44    JSR disk_init_chain
.C:5c49  A2 15       LDX #<disk_id
.C:5c4b  A0 00       LDY #>disk_id
.C:5c4d  A9 01       LDA #$01
.C:5c4f  8D 3C 46    STA disk_copy_count_lo
.C:5c52  A9 00       LDA #$00
.C:5c54  8D 3D 46    STA disk_copy_count_hi
.C:5c57  20 47 45    JSR disk_write_linear
;Write #$152 bytes from $FEA1-FFF3 to track 5, sector 0
;This includes the game engine state, game variables and free blocks
.C:5c5a  A2 00       LDX #$00
.C:5c5c  A0 05       LDY #$05
.C:5c5e  20 D3 44    JSR disk_init_chain
.C:5c61  A2 A1       LDX #$A1
.C:5c63  A0 FE       LDY #$FE
.C:5c65  A9 52       LDA #$52
.C:5c67  8D 3C 46    STA disk_copy_count_lo
.C:5c6a  A9 01       LDA #$01
.C:5c6c  8D 3D 46    STA disk_copy_count_hi
.C:5c6f  20 47 45    JSR disk_write_linear
;Write 7 bytes from $C9-D0 to track 6, sector 0
.C:5c72  A2 00       LDX #$00
.C:5c74  A0 06       LDY #$06
.C:5c76  20 D3 44    JSR disk_init_chain
.C:5c79  A2 C9       LDX #$C9
.C:5c7b  A0 00       LDY #$00
.C:5c7d  A9 07       LDA #$07
.C:5c7f  8D 3C 46    STA disk_copy_count_lo
.C:5c82  A9 00       LDA #$00
.C:5c84  8D 3D 46    STA disk_copy_count_hi
.C:5c87  20 47 45    JSR disk_write_linear
;Write #$57CF bytes from $7031-C800 to track 7, sector 0
;This includes the whole "heap" with current resources and free blocks,
; pointers to existing resources in memory, and the hardcoded game layout info
; (track/sectors, read offsets, etc.)
.C:5c8a  A2 00       LDX #$00
.C:5c8c  A0 07       LDY #$07
.C:5c8e  20 D3 44    JSR disk_init_chain
.C:5c91  A2 31       LDX #$31
.C:5c93  A0 70       LDY #$70
.C:5c95  A9 CF       LDA #$CF
.C:5c97  8D 3C 46    STA disk_copy_count_lo
.C:5c9a  A9 57       LDA #$57
.C:5c9c  8D 3D 46    STA disk_copy_count_hi
.C:5c9f  20 47 45    JSR disk_write_linear
;Return with #00 in .A
.C:5ca2  A9 00       LDA #$00
.C:5ca4  60          RTS
;===========================================
disk_id = $15
SAVED_GAME_DISK_ID = #$33

load_state_from_disk:
;Check if the disk ID is valid - if it's the game disk, return directly
.C:5ca5  20 FC 5C    JSR load_and_validate_disk_id;Not the game disk, check if it's a savegame disk by comparing the Disk ID
.C:5ca8  A5 15       LDA disk_id
.C:5caa  C9 33       CMP SAVED_GAME_DISK_ID
.C:5cac  F0 03       BEQ load_state_from_sectors
;Not the savegame disk, return #02 in .A
.C:5cae  A9 02       LDA #$02
.C:5cb0  60          RTS
load_state_from_sectors:
;Copy a total of #$0152 bytes from track 5, sector 0 to FEA1-FFF3
;This includes the game engine state, game variables and free blocks
.C:5cb1  A2 00       LDX #$00
.C:5cb3  A0 05       LDY #$05
.C:5cb5  20 EE 44    JSR disk_init_chain_and_read
.C:5cb8  A2 A1       LDX #$A1
.C:5cba  A0 FE       LDY #$FE
.C:5cbc  A9 52       LDA #$52
.C:5cbe  8D 3C 46    STA disk_copy_count_lo
.C:5cc1  A9 01       LDA #$01
.C:5cc3  8D 3D 46    STA disk_copy_count_hi
.C:5cc6  20 1F 45    JSR disk_stream_copy
;Copy 7 bytes from track 6, sector 0 to C9-D0
.C:5cc9  A2 00       LDX #$00
.C:5ccb  A0 06       LDY #$06
.C:5ccd  20 EE 44    JSR disk_init_chain_and_read
.C:5cd0  A2 C9       LDX #$C9
.C:5cd2  A0 00       LDY #$00
.C:5cd4  A9 07       LDA #$07
.C:5cd6  8D 3C 46    STA disk_copy_count_lo
.C:5cd9  A9 00       LDA #$00
.C:5cdb  8D 3D 46    STA disk_copy_count_hi
.C:5cde  20 1F 45    JSR disk_stream_copy
;Copy a total of 57CF bytes from track 7, sector 0 to $7031-C800
;This includes the whole "heap" with current resources and free blocks,
; pointers to existing resources in memory, and the hardcoded game layout info
; (track/sectors, read offsets, etc.)
.C:5ce1  A2 00       LDX #$00
.C:5ce3  A0 07       LDY #$07
.C:5ce5  20 EE 44    JSR disk_init_chain_and_read
.C:5ce8  A2 31       LDX #$31
.C:5cea  A0 70       LDY #$70
.C:5cec  A9 CF       LDA #$CF
.C:5cee  8D 3C 46    STA disk_copy_count_lo
.C:5cf1  A9 57       LDA #$57
.C:5cf3  8D 3D 46    STA disk_copy_count_hi
.C:5cf6  20 1F 45    JSR disk_stream_copy
;Return #03 on .A
.C:5cf9  A9 03       LDA #$03
.C:5cfb  60          RTS
;===========================================
; Load the Disk ID, check if it belongs
; to the game disk (side 1 or 2).
;
; Arguments: none
; Returns:	.A	#00 if it's not the game disk
;				#01 if it's one of the game disk sides
;
; Will store the Disk ID in $15
; Will pop the return address of one caller from the stack, if it's the game disk
;===========================================
disk_id = $15

load_and_validate_disk_id:
;Read first byte of track 1, sector 0 (Disk ID), store it in $15
;Track 1, sector 0
.C:5cfc  A2 00       LDX #$00
.C:5cfe  A0 01       LDY #$01
.C:5d00  20 EE 44    JSR disk_init_chain_and_read
.C:5d03  20 8E 45    JSR disk_stream_next_byte
.C:5d06  85 15       STA disk_id
;Check if Disk ID is valid (#31 or #32)
.C:5d08  A5 15       LDA disk_id
.C:5d0a  C9 31       CMP #$31
.C:5d0c  F0 07       BEQ valid_disk_id
.C:5d0e  C9 32       CMP #$32
.C:5d10  F0 03       BEQ valid_disk_id
;Disk ID is neither that of side 1 or side 2 - return #00 on .A
.C:5d12  A9 00       LDA #$00
.C:5d14  60          RTS
valid_disk_id:
.C:5d15  68          PLA
.C:5d16  68          PLA;Valid Disk ID - return #01 on .A, skip caller on return (return to the caller's caller).C:5d17  A9 01       LDA #$01
.C:5d19  60          RTS
;===========================================
; Clear the game engine variables (not the script variables)
;
; It's the region in $7031-7B7B, just before the heap
;===========================================
clear_engine_state:
.C:5d1a  A9 31       LDA #$31
.C:5d1c  85 19       STA $19
.C:5d1e  A9 70       LDA #$70
.C:5d20  85 1A       STA $1A
.C:5d22  A9 4A       LDA #$4A
.C:5d24  85 1B       STA $1B
.C:5d26  A9 0B       LDA #$0B
.C:5d28  85 1C       STA $1C
.C:5d2a  A2 00       LDX #$00
.C:5d2c  20 32 5D    JSR fill_memory_with_value_2
.C:5d2f  4C 4C 5D    JMP init_free_block
;===========================================
; Fills memory with a specific value
;
; Arguments: 	.X 				value to write
;				dest_pointer		pointer to destination
;				byte_counter	total number of bytes to write
;
; This is an exact clone of "fill_memory_with_value"
;===========================================
dest_pointer = $19
byte_counter = $1B

fill_memory_with_value_2:
;We'll move the base pointer instead of Y, which will stay set at #00
.C:5d32  A0 00       LDY #$00
.C:5d34  8A          TXA
;Store fill value in memory
.C:5d35  91 19       STA (dest_pointer),Y
;Move pointer
.C:5d37  E6 19       INC <dest_pointer
.C:5d39  D0 02       BNE update_counters_2
.C:5d3b  E6 1A       INC >dest_pointer
update_counters_2:
.C:5d3d  A5 1B       LDA <byte_counter
.C:5d3f  D0 02       BNE counter_lo_decrement_2
.C:5d41  C6 1C       DEC >byte_counter
counter_lo_decrement_2:
.C:5d43  C6 1B       DEC <byte_counter
;OR'ing both counter bytes will yield zero if both are zero
.C:5d45  A5 1B       LDA <byte_counter
.C:5d47  05 1C       ORA >byte_counter
.C:5d49  D0 E7       BNE fill_memory_with_value_2
.C:5d4b  60          RTS
;===========================================
; Initialize the single free block that exists when the game engine starts
;===========================================
init_free_block:
;Set free block size to 4C85
;7b7b+4c85 = c800
.C:5d4c  A9 85       LDA #$85
.C:5d4e  8D 7B 7B    STA $7B7B
.C:5d51  A9 4C       LDA #$4C
.C:5d53  8D 7C 7B    STA $7B7C
;Set pointer to next block to null
.C:5d56  A9 00       LDA #$00
.C:5d58  8D 7D 7B    STA $7B7D
.C:5d5b  A9 00       LDA #$00
.C:5d5d  8D 7E 7B    STA $7B7E
;Set first and last free blocks pointing to $7b7b
.C:5d60  A9 7B       LDA #$7B
.C:5d62  8D 63 FF    STA <first_free_block
.C:5d65  8D 65 FF    STA <last_free_block
.C:5d68  A9 7B       LDA #$7B
.C:5d6a  8D 64 FF    STA >first_free_block
.C:5d6d  8D 66 FF    STA >last_free_block
.C:5d70  60          RTS
;===========================================
; Executes each runing script
;
; The routine will start from the current script slot, going up until the last slot. 
; For each script slot with running state, it will execute operations from it. 
; Once the last slot is done, the current script slot is reset back to #01.
;===========================================
execute_running_scripts:
.C:5d71  AE 89 FE    LDX current_script_slot
;Is it running? If not, skip
.C:5d74  BD D9 70    LDA script_state_for_script_slot,X
.C:5d77  C9 02       CMP #$02
.C:5d79  D0 0C       BNE next_script
;Execute the script
.C:5d7b  8E B8 70    STX current_script_slot
.C:5d7e  20 20 5E    JSR set_script_resource_base_address
.C:5d81  20 E3 5D    JSR set_current_script_read_address	
.C:5d84  20 97 5D    JSR execute_next_operation
next_script:
.C:5d87  EE 89 FE    INC current_script_slot
.C:5d8a  AD 89 FE    LDA current_script_slot
.C:5d8d  C9 10       CMP #$10
.C:5d8f  D0 E0       BNE execute_running_scripts
;Reset script index back to #01
.C:5d91  A9 01       LDA #$01
.C:5d93  8D 89 FE    STA current_script_slot
.C:5d96  60          RTS
;===========================================
; Execute a script's next operation
;
; This will continually read and execute operations by dispatching them. 
; Execution has to be interrupted explicitly by the script  itself, 
; giving a chance to other scripts to execute, and even the rest of the game engine itself.
;===========================================
execute_next_operation:
;Read an operation byte
.C:5d97  20 14 5E    JSR script_read_byte
;Save it as the "opcode"
.C:5d9a  8D 8C FE    STA opcode
;Find the opcode handler and setup the inlined address for it
.C:5d9d  AA          TAX
.C:5d9e  BD 00 D0    LDA opcode_handlers_lo,X
.C:5da1  8D AB 5D    STA <inlined_handler
.C:5da4  BD 00 D1    LDA opcode_handlers_hi,X
.C:5da7  8D AC 5D    STA >inlined_handler
;Invoke the inlined handler
inlined_handler = $5dab
.C:5daa  20 00 00    JSR $0000		;Inlined address
;Process next script operation
.C:5dad  4C 97 5D    JMP execute_next_operation
;===========================================
; Compute a script's relative offset
;
; This is useful in case execution is about to be interrupted,
; so that we can resume it from the correct place later.
;===========================================
save_script_relative_offset:
;Update the script relative offset (as we're halting execution)
.C:5db0  20 FA 5D    JSR compute_script_relative_offset
.C:5db3  60          RTS
;===========================================
; Handle possible script resource memory relocation
;
; This has to be invoked each time there's a possibility that memory is compacted,
; and so existing resource blocks are moved around.
;
;===========================================
debug_semaphore = $2f

handle_script_relocation:
;Is there a current script running? If not, exit
.C:5db4  AD B8 70    LDA current_script_slot
.C:5db7  C9 FF       CMP #$FF
.C:5db9  F0 27       BEQ exit
;Is there a loaded base address for the script resource?
.C:5dbb  AD 8B FE    LDA current_script_rsrc_base_hi
;If so, adjust the script pointers
.C:5dbe  D0 19       BNE adjust_script_pointers
;-------------------------------------
;We shouldn't ever reach this section unless there's a bug
;If there's a running script, current_script_rsrc_base_hi should always be set
;If semaphore bit 7 is set, skip this section
.C:5dc0  A5 2F       LDA debug_semaphore
.C:5dc2  30 15       BMI adjust_script_pointers
;Clear semaphore
.C:5dc4  A9 00       LDA #$00
.C:5dc6  85 2F       STA debug_semaphore
;map_in_io
.C:5dc8  A0 25       LDY #$25
.C:5dca  84 01       STY processor_port_register
wait_for_semaphore:
.C:5dcc  A9 01       LDA #$01
.C:5dce  8D 20 D0    STA vic_border_color_register
;Wait for semaphore to be set
.C:5dd1  A5 2F       LDA debug_semaphore
.C:5dd3  F0 F7       BEQ wait_for_semaphore
;map_out_io
.C:5dd5  A0 24       LDY #$24
.C:5dd7  84 01       STY processor_port_register
;-------------------------------------
;Cover the scenario where a memory relocation has occurred
adjust_script_pointers:
;Compute the current relative offset
;It doesn't matter that the script block has moved as the base address and read pointer have not changed yet
;With them, we can compute the relative offset
.C:5dd9  20 FA 5D    JSR compute_script_relative_offset
;Reset the script resource base address (now we do use updated blocks that have been moved)
.C:5ddc  20 20 5E    JSR set_script_resource_base_address	
;Recompute the script's read address, now that we have the correct base and correct offset
.C:5ddf  20 E3 5D    JSR set_current_script_read_address
exit:
.C:5de2  60          RTS
;===========================================
; Sets the current script's read address
; It adds the script's base address to the relative offset
;===========================================
set_current_script_read_address:
;Load index of current script being executed
.C:5de3  AC B8 70    LDY current_script_slot
;Perform: script_read_pointer = current_script_rsrc_base + script_offsets
.C:5de6  AD 8A FE    LDA current_script_rsrc_base_lo
.C:5de9  18          CLC
.C:5dea  79 C9 70    ADC script_offsets_lo,Y
.C:5ded  8D 15 5E    STA script_read_pointer_lo
.C:5df0  AD 8B FE    LDA current_script_rsrc_base_hi
.C:5df3  79 B9 70    ADC script_offsets_hi,Y
.C:5df6  8D 16 5E    STA script_read_pointer_hi
.C:5df9  60          RTS
;===========================================
; Computes the current's script relative offset
; It subtracts the script's read pointer from the base address 
;===========================================
compute_script_relative_offset:
;Load index of current script being executed
.C:5dfa  AC B8 70    LDY current_script_slot
;Perform: script_offsets = script_read_pointer - current_script_rsrc_base
.C:5dfd  AD 15 5E    LDA script_read_pointer_lo
.C:5e00  38          SEC
.C:5e01  ED 8A FE    SBC current_script_rsrc_base_lo
.C:5e04  99 C9 70    STA script_offsets_lo,Y				
.C:5e07  AD 16 5E    LDA script_read_pointer_hi
.C:5e0a  ED 8B FE    SBC current_script_rsrc_base_hi
.C:5e0d  99 B9 70    STA script_offsets_hi,Y				
.C:5e10  60          RTS
;===========================================
; Skip a 16-bit offset
;
; This is performed by doing a double byte read, effectively skipping 2 bytes (which constitute a 16-bit offset).
; After reading once via "script_read_byte", execution will fall through to "script_read_byte" again.
; The first value read is thus ignored and discarded.
; The second value read will be returned. All known callers of this routine will also ignore and discard the byte returned.
;===========================================
script_skip_offset:
.C:5e11  20 14 5E    JSR script_read_byte
;===========================================
; Reads from the script pointer
;
; Arguments: script_pointer 	points to data to be read
; Returns:	.A 					the data read from the pointer
;
; After execution, the pointer will be moved once to the next offset
;===========================================
script_read_byte:
;The inlined pointer is a 16-bit address
;This is a (fast?) way of implementing a pointer without using indexed addressing
.C:5e14  AD FF FF    LDA script_pointer
.C:5e17  EE 15 5E    INC script_read_pointer_lo
.C:5e1a  D0 03       BNE exit
.C:5e1c  EE 16 5E    INC script_read_pointer_hi
exit:
.C:5e1f  60          RTS
;===========================================
; Set the current script's resource base address
;
; Script types:	#00		object script
;				#01		room script
;				#02		global script
;===========================================
set_script_resource_base_address:
;Load index of current script being executed
.C:5e20  AC B8 70    LDY current_script_slot
;Switch on the script type
.C:5e23  B9 19 71    LDA script_type_for_script_slot,Y		
.C:5e26  C9 02       CMP #$02
.C:5e28  D0 15       BNE is_01
;-----------------------------
;Case #02 - global script
;-----------------------------
;Copy the script resource base address
;Add 4 to skip the header 
.C:5e2a  BE 29 71    LDX resource_index_for_script_slot,Y
.C:5e2d  BD 37 7A    LDA script_rsrc_ptrs_lo,X
.C:5e30  18          CLC
.C:5e31  69 04       ADC #$04
.C:5e33  8D 8A FE    STA current_script_rsrc_base_lo
.C:5e36  BD 97 79    LDA script_rsrc_ptrs_hi,X
.C:5e39  69 00       ADC #$00
.C:5e3b  8D 8B FE    STA current_script_rsrc_base_hi
.C:5e3e  60          RTS
;-----------------------------
is_01:
.C:5e3f  C9 01       CMP #$01
.C:5e41  D0 10       BNE is_00
;-----------------------------
;Case #01 - room script
;-----------------------------
;Copy the room resource address
.C:5e43  AE 49 71    LDX current_room
.C:5e46  BD 2A 78    LDA room_rsrc_ptrs_lo,X
.C:5e49  8D 8A FE    STA current_script_rsrc_base_lo
.C:5e4c  BD F3 77    LDA room_rsrc_ptrs_hi,X
.C:5e4f  8D 8B FE    STA current_script_rsrc_base_hi
.C:5e52  60          RTS
;-----------------------------
is_00:
.C:5e53  C9 00       CMP #$00
;Type unknown - deactivate the script
.C:5e55  D0 10       BNE find_and_deactivate_script
;-----------------------------
;Case #00 - object script
;-----------------------------
;Copy the object resource address
.C:5e57  BE 29 71    LDX resource_index_for_script_slot,Y
.C:5e5a  BD 5E 70    LDA object_rsrc_ptrs_lo,X
.C:5e5d  8D 8A FE    STA current_script_rsrc_base_lo
.C:5e60  BD 8B 70    LDA object_rsrc_ptrs_hi,X
.C:5e63  8D 8B FE    STA current_script_rsrc_base_hi
.C:5e66  60          RTS
;===========================================
; Scans through all in memory scripts,
; trying to find one with a specific resource index.
;
; If found, the script refcount will be decremented,
; and the script will be deactivated.
;
; Arguments:	.A	script resource index
;===========================================
find_and_deactivate_script:
;Use .Y as script index, start from #0F, go downwards
.C:5e67  A0 0F       LDY #$0F
check_script_resource_index:
;Compare script resource with the target resource index
;If they don't match, skip
.C:5e69  D9 29 71    CMP resource_index_for_script_slot,Y
.C:5e6c  D0 18       BNE next_script
;There's a resource match
;Is the script inactive? 
.C:5e6e  BE D9 70    LDX script_state_for_script_slot,Y
.C:5e71  E0 00       CPX #$00
;If so, skip
.C:5e73  F0 11       BEQ next_script
;------------------
;We found a matching active script
;Decrement script's memory reference count
.C:5e75  BE 29 71    LDX resource_index_for_script_slot,Y
.C:5e78  DE D7 7A    DEC script_memory_attrs,X
;Clear script resource
.C:5e7b  A9 00       LDA #$00
.C:5e7d  99 29 71    STA resource_index_for_script_slot,Y
;Set script state to inactive (#00)
.C:5e80  A9 00       LDA #$00
.C:5e82  99 D9 70    STA script_state_for_script_slot,Y
.C:5e85  60          RTS
;------------------
next_script:
.C:5e86  88          DEY
.C:5e87  D0 E0       BNE check_script_resource_index
.C:5e89  60          RTS
;===========================================
; Starts a global script
; 
; Arguments:	.A = script resource index
;===========================================
script_rsrc_index = $15

start_global_script:
;Save the script's resource
.C:5e8a  85 15       STA script_rsrc_index
;Deactive the script first, if needed
.C:5e8c  20 67 5E    JSR find_and_deactivate_script
;Is the script resource already in memory?
.C:5e8f  A6 15       LDX script_rsrc_index
.C:5e91  BD 97 79    LDA script_rsrc_ptrs_hi,X
.C:5e94  D0 07       BNE script_in_memory
;It's not in memory, load it
.C:5e96  8A          TXA
.C:5e97  20 29 3A    JSR load_script
.C:5e9a  20 B4 5D    JSR handle_script_relocation
script_in_memory:
;Increment script's memory refcount
.C:5e9d  A6 15       LDX script_rsrc_index
.C:5e9f  FE D7 7A    INC script_memory_attrs,X
;Find an available script slot
.C:5ea2  20 C0 5E    JSR find_available_script_slot
;Store resource index for the new script
.C:5ea5  A5 15       LDA script_rsrc_index
.C:5ea7  9D 29 71    STA resource_index_for_script_slot,X
;Reset script offsets
.C:5eaa  A9 00       LDA #$00
.C:5eac  9D B9 70    STA script_offsets_hi,X
.C:5eaf  9D C9 70    STA script_offsets_lo,X
;Set script state to running (#02)
.C:5eb2  A9 02       LDA #$02
.C:5eb4  9D D9 70    STA script_state_for_script_slot,X
;Set script type to global (#02)
.C:5eb7  A9 02       LDA #$02
.C:5eb9  9D 19 71    STA script_type_for_script_slot,X
;Launch the script in .X
.C:5ebc  20 D0 5E    JSR launch_script
.C:5ebf  60          RTS
;===========================================
; Finds the first available script slot
; That is, finds the first script_state with value #00
;
; Arguments: None
; Returns:	.X		script slot index (#10 if none found)
;===========================================
find_available_script_slot:
;Use .X as script slot index, start at #01, move upwards
.C:5ec0  A2 01       LDX #$01
check_script_state:
;Check if the script slot state is inactive (#00)
.C:5ec2  BD D9 70    LDA script_state_for_script_slot,X
.C:5ec5  C9 00       CMP #$00
;If not, continue with the next script
.C:5ec7  D0 01       BNE next_script_slot
;It's inactive, we can use this script slot
.C:5ec9  60          RTS
next_script_slot:
;Move to the next script slot
.C:5eca  E8          INX
;If there are still script slots pending, continue checking
.C:5ecb  E0 10       CPX #$10
.C:5ecd  D0 F3       BNE check_script_state
.C:5ecf  60          RTS
;===========================================
; Launch a script
;
; Arguments:	.X	script execution index to launch
;===========================================
launch_script:
;------------------------------------
; Save the current script being executed in the stack
; so we can resume it afterwards.
;------------------------------------
; Calculate the current relative offset: subtract script _current pointer_ from script base pointer
; Push it into the stack
.C:5ed0  AD 15 5E    LDA script_read_pointer_lo
.C:5ed3  38          SEC
.C:5ed4  ED 8A FE    SBC current_script_rsrc_base_lo
.C:5ed7  48          PHA
.C:5ed8  AD 16 5E    LDA script_read_pointer_hi
.C:5edb  ED 8B FE    SBC current_script_rsrc_base_hi
.C:5ede  48          PHA
;Fetch current script execution index
.C:5edf  AC B8 70    LDY current_script_slot
;Fetch the script resource index
.C:5ee2  B9 29 71    LDA resource_index_for_script_slot,Y
;Save both in stack
.C:5ee5  48          PHA
.C:5ee6  98          TYA
.C:5ee7  48          PHA
;------------------------------------
;So far, in the stack we have pushed: 
;
;	script execution index
;	script resource index
;	script offset hi
;	script offset lo
;
;------------------------------------
;Set the new execution script index
.C:5ee8  8E B8 70    STX current_script_slot
;Compute the base address
.C:5eeb  20 20 5E    JSR set_script_resource_base_address
.C:5eee  20 E3 5D    JSR set_current_script_read_address		;Compute script current pointer using script current offset
;Launch the script
.C:5ef1  20 97 5D    JSR execute_next_operation
;Pull script execution index from stack, so we can resume the previous one
.C:5ef4  68          PLA
;If it's #FF, then nothing was being executed, clean stack and exit
.C:5ef5  C9 FF       CMP #$FF
.C:5ef7  D0 04       BNE resume_previous_script
.C:5ef9  68          PLA
.C:5efa  68          PLA
.C:5efb  68          PLA
.C:5efc  60          RTS
;------------------------------------
resume_previous_script:
;Reset the previous execution script index
.C:5efd  8D B8 70    STA current_script_slot
.C:5f00  A8          TAY
;Restore the script resource index
.C:5f01  68          PLA
;Sanity check - validate that it matches the resource index for the script slot
.C:5f02  D9 29 71    CMP resource_index_for_script_slot,Y
;If it doesn't, we shouldn't resume it
.C:5f05  D0 11       BNE resource_mismatch
;Restore previous script's offset
.C:5f07  68          PLA
.C:5f08  99 B9 70    STA script_offsets_hi,Y
.C:5f0b  68          PLA
.C:5f0c  99 C9 70    STA script_offsets_lo,Y
;Recompute script addresses
.C:5f0f  20 20 5E    JSR set_script_resource_base_address		;Compute script base pointer based on type/index into FE8A/8B
.C:5f12  20 E3 5D    JSR set_current_script_read_address		;Compute script current pointer using script current offset
.C:5f15  4C 2A 5F    JMP exit
;------------------------------------
resource_mismatch:
;Store the mismatched values in debugging variables
.C:5f18  8D DE 6A    STA $6ADE
.C:5f1b  8C DF 6A    STY $6ADF
;Clean the stack
.C:5f1e  68          PLA
.C:5f1f  68          PLA
;Clear the current script's base address
.C:5f20  A9 00       LDA #$00
.C:5f22  8D 8A FE    STA current_script_rsrc_base_lo
.C:5f25  A9 00       LDA #$00
.C:5f27  8D 8B FE    STA current_script_rsrc_base_hi
exit:
.C:5f2a  60          RTS
;===========================================
refresh_items_displayed:
;If control mode is #00 (cutscene), exit
.C:5f2b  AD A8 FE    LDA control_mode
.C:5f2e  C9 00       CMP #$00
.C:5f30  F0 18       BEQ exit
;Save control mode
.C:5f32  AD A8 FE    LDA control_mode
.C:5f35  48          PHA
;Set control mode to #00 (cutscene)
.C:5f36  A9 00       LDA #$00
.C:5f38  8D A8 FE    STA control_mode
;map_in_io
.C:5f3b  A0 25       LDY #$25
.C:5f3d  84 01       STY processor_port_register
;Update the items being displayed
.C:5f3f  20 B3 F4    JSR update_items_displayed
;map_out_io
.C:5f42  A0 24       LDY #$24
.C:5f44  84 01       STY processor_port_register
;Restore control mode and exit
.C:5f46  68          PLA
.C:5f47  8D A8 FE    STA control_mode
exit:
.C:5f4a  60          RTS
;===========================================
; Clears the scene area in video memory.
;
; There are two main base addresses used for video matrix data: C800 and CC00.
; See video_memory_mode description for details.
; 
; The first #27 bytes are used for the message bar.
; Offsets #28-3D0 cover the scene area (where the game's graphics are displayed)
;
; So if the main base address is C800, C828-CAD0 cover the scene area.
; If it's CC00, then CC28-CED0 cover the scene area.
;
;===========================================
clear_scene_area:
;Fill memory in C828-CAD0 with #00
.C:5f4b  A9 28       LDA #$28
.C:5f4d  85 19       STA $19
.C:5f4f  A9 C8       LDA #$C8
.C:5f51  85 1A       STA $1A
.C:5f53  A9 A8       LDA #$A8
.C:5f55  85 1B       STA $1B
.C:5f57  A9 02       LDA #$02
.C:5f59  85 1C       STA $1C
.C:5f5b  A2 00       LDX #$00
.C:5f5d  20 32 5D    JSR fill_memory_with_value_2
;Fill memory in CC28-CED0 with #00
.C:5f60  A9 28       LDA #$28
.C:5f62  85 19       STA $19
.C:5f64  A9 CC       LDA #$CC
.C:5f66  85 1A       STA $1A
.C:5f68  A9 A8       LDA #$A8
.C:5f6a  85 1B       STA $1B
.C:5f6c  A9 02       LDA #$02
.C:5f6e  85 1C       STA $1C
.C:5f70  A2 00       LDX #$00
.C:5f72  20 32 5D    JSR fill_memory_with_value_2
.C:5f75  60          RTS
;===========================================
.C:5f76  00          BRK
.C:5f77  00          BRK
.C:5f78  00          BRK
;===========================================
; Compare 2 operands using the CMP instruction
;
; This will perform a subtraction of one operand from the other, and set the processor flags accordingly. 
; The caller needs to check the flags to evaluate the result of the comparison.
;
; operand 1 is stored in the accumulator (A) and operand 2 is stored in a variable (M)
; When the CMP instruction is executed, the following subtraction takes place: A-M,
; or equivalently, operand_1 - operand_2.
;
; As a reminder, here's how flags are set:
;
;	Carry		Set 	if operand_1 >= operand_2
;				Clear 	if operand_1 < operand_2
;	Zero		Set		if operand_1 == operand_2
;				Clear	if operand_1 != operand_2
;	Negative	Set		if bit 7 of the subtraction is set
;				Clear	if bit 7 of the subtraction is clear
;===========================================
operand_2 = $d0

script_compare_operands:
;Read operand 1 (a game variable) index, save it in .Y
.C:5f79  20 14 5E    JSR script_read_byte
.C:5f7c  A8          TAY
;Read operand 2, save it in operand_2
.C:5f7d  20 98 5F    JSR script_load_operand_bit7
.C:5f80  85 D0       STA operand_2
;Load operand 1 in .A, compare against operand_2 and set processor flags
.C:5f82  B9 67 FF    LDA game_vars,Y
.C:5f85  C5 D0       CMP operand_2
.C:5f87  60          RTS
;===========================================
; The script allows referencing argument values of two kinds: the value of a variable or an immediate value (a constant).
;
; To avoid having duplicated code for each kind, a mechanism is used to differentiate between them.
; The opcode (the operation code) byte not only encodes the type of operation, but also the kind of value to be used.
;
; Specific bits of the opcode are used to specify the kind.
; Bits 7, 6 and 5 are used for this, which allows an operation to use up to 3 different "parameterizable kind" arguments.
;
; For example, most operations use bit 7 for an operand's kind.
; If bit 7 is set, a variable is used.
; If bit 7 is clear, an immediate value is used.
; Bits 6 and 5 are used in the same manner, depending on whether an operation needs more arguments like this or not.
;
; When a variable is used, the variable index is read from the script, to know which variable to use.
; When an immediate value is used, the value itself is read from the script.
;
; There are 3 operand load routines, one for each bit.
; For each of them, this logic applies:
;
;	The opcode is AND'ed with a bitmask for the bit position (0x80, 0x40 and 0x20 for bits 7, 6 and 5 respectively).
;	After performing the AND, the processor flags are set according to the result.
;	If A = 0 after the AND, the Z flag will be SET.
;	Thus when executing a BNE (Branch on Not Equal, which is equivalent to Branch if Z is CLEAR), the branch will NOT be taken.
;	This conditional branch instruction is performed in script_operand_type_check.
;	All 3 operand load routines end up using script_operand_type_check.
;	When the branch is taken, a variable is used.
;	When it's not taken, an immediate value is used.
;
;	So, to sum up, if the relevant bit in the opcode is SET, the AND yields non-zero, Z is clear, the branch of BNE is taken and a variable is used.
;	If the bit is CLEAR, the AND yields zero, Z is set, the branch of BNE is not taken, and an immediate operand is used.
;
; After reading the operand, it's returned in .A
;===========================================
script_load_operand_bit5:
;Load the opcode
.C:5f88  AD 8C FE    LDA opcode
;Perform the AND (and thus set/clear the Z flag)
.C:5f8b  29 20       AND #$20		;Bit 5 bitmask
;Do the operand type check
.C:5f8d  4C 9D 5F    JMP script_operand_type_check
;===========================================
script_load_operand_bit6:
.C:5f90  AD 8C FE    LDA opcode
.C:5f93  29 40       AND #$40		;Bit 6 bitmask
.C:5f95  4C 9D 5F    JMP script_operand_type_check
;===========================================
script_load_operand_bit7:
.C:5f98  AD 8C FE    LDA opcode
.C:5f9b  29 80       AND #$80		;Bit 7 bitmask
;===========================================
script_operand_type_check:
;Branch based on the Z flag
.C:5f9d  D0 04       BNE script_load_variable
script_load_immediate:
;Immediate value, read it from the script into .A and return
.C:5f9f  20 14 5E    JSR script_read_byte
.C:5fa2  60          RTS
script_load_variable:
;Variable, read the variable index from the script
.C:5fa3  20 14 5E    JSR script_read_byte
;Read the variable value into .A and return
.C:5fa6  AA          TAX
.C:5fa7  BD 67 FF    LDA game_vars,X
.C:5faa  60          RTS
;===========================================
; Gets an object's attributes
;
; Arguments:	
; Returns:		.A		object's attributes
;===========================================
script_read_object_attributes:
;Is opcode bit 6 clear?
.C:5fab  AD 8C FE    LDA opcode
.C:5fae  29 40       AND #$40
.C:5fb0  F0 06       BEQ bit6_clear
bit6_set:
;Bit 6 set, get the object's index from the current direct object
.C:5fb2  AC 1A FE    LDY active_object_lo
.C:5fb5  4C BC 5F    JMP get_object_attributes
bit6_clear:
;Bit 6 clear, read the object's index
.C:5fb8  20 14 5E    JSR script_read_byte
.C:5fbb  A8          TAY
get_object_attributes:
;Fetch object's attributes, return them in .A
.C:5fbc  8C 52 FE    STY item_index_saved
.C:5fbf  B9 01 73    LDA object_attributes,Y
.C:5fc2  60          RTS
;===========================================
; Sets an object's attributes
;
; Arguments:	item_index_saved	object_index
; 				.A		object's attributes
;===========================================
script_set_object_attributes:
;Fetch object index
.C:5fc3  AC 52 FE    LDY item_index_saved
;Set object attributes
.C:5fc6  99 01 73    STA object_attributes,Y
;Set default camera position
.C:5fc9  A9 C8       LDA #$C8
.C:5fcb  8D 67 06    STA camera_current_position
.C:5fce  60          RTS
;===========================================
; Find a free inventory slot.
;
; This is used to store an object, when picking it up, into a free slot.
;
; Arguments: None
; Returns:	.Y		free inventory slot
;===========================================
find_free_inventory_slot:
;Use .Y as inventory slot counter, start at #01, go upwards
.C:5fcf  A0 01       LDY #$01
check_if_slot_is_free:
;Is the slot free? (That is, does it hold a #00?)
.C:5fd1  B9 31 70    LDA inventory_objects,Y
.C:5fd4  D0 01       BNE next_slot
;Yes, we found a free slot, return
.C:5fd6  60          RTS
next_slot:
;Move to next slot
.C:5fd7  C8          INY
;If there are still slots pending, continue checking
.C:5fd8  C0 2D       CPY #$2D
.C:5fda  D0 F5       BNE check_if_slot_is_free
;BUG - if there are no free inventory slots, execution will fall through
; to the next routine and crash sooner or later
;===========================================
; Compute actors distance
;
; Arguments:	reference_actor		first actor
;				current_actor		second_actor
;
;	Returns:	.A		#FF actors not in the same room
;							or not in a valid room
;
; This routine will:
;	-perform a subtraction of the X coordinates of both actors to get the X distance
;	-same thing with the Y coordinates to get the Y distance
;	-divide the Y distance by 4
;	-If X_distance > Y_Distance, return Y_distance * 2 + X_distance
;	-Otherwise, return X_distance * 2 + Y_distance
;===========================================
reference_actor = $17
current_actor = $19
actor1_x = $1b
actor1_y = $1c
actor2_x = $1d
actor2_y = $1e
compute_actors_distance:
;Load rooms for both actors
.C:5fdc  A6 17       LDX reference_actor
.C:5fde  BD FC FE    LDA room_for_character,X
.C:5fe1  A6 19       LDX current_actor
;Are they in the same room?
.C:5fe3  DD FC FE    CMP room_for_character,X
.C:5fe6  F0 03       BEQ valid_room_check
;Not in the same room - return #FF
.C:5fe8  A9 FF       LDA #$FF
.C:5fea  60          RTS
valid_room_check:
;Are they in a valid room?
.C:5feb  C9 00       CMP #$00
.C:5fed  D0 03       BNE entry
;Not a valid room - return #FF
.C:5fef  A9 FF       LDA #$FF
.C:5ff1  60          RTS
entry:
.C:5ff2  CD 49 71    CMP current_room
.C:5ff5  D0 21       BNE not_in_current_room
;---------------------------
;They are both in the current room
.C:5ff7  A6 19       LDX current_actor
.C:5ff9  BC 57 FE    LDY actor_for_costume,X
.C:5ffc  B9 41 FD    LDA position_x_for_actor,Y
.C:5fff  85 1D       STA actor2_x
.C:6001  B9 3D FD    LDA position_y_for_actor,Y
.C:6004  85 1E       STA actor2_y
.C:6006  A6 17       LDX reference_actor
.C:6008  BC 57 FE    LDY actor_for_costume,X
.C:600b  B9 41 FD    LDA position_x_for_actor,Y
.C:600e  85 1B       STA actor1_x
.C:6010  B9 3D FD    LDA position_y_for_actor,Y
.C:6013  85 1C       STA actor1_y
.C:6015  4C 30 60    JMP compute_x_distance
;---------------------------
not_in_current_room:
.C:6018  A6 19       LDX current_actor
.C:601a  BD 2E FF    LDA costume_x_destination,X
.C:601d  85 1D       STA actor2_x
.C:601f  BD 15 FF    LDA costume_y_destination,X
.C:6022  85 1E       STA actor2_y
.C:6024  A6 17       LDX reference_actor
.C:6026  BD 2E FF    LDA costume_x_destination,X
.C:6029  85 1B       STA actor1_x
.C:602b  BD 15 FF    LDA costume_y_destination,X
.C:602e  85 1C       STA actor1_y
;---------------------------
compute_x_distance:
;Subtract the 2 coordinates
.C:6030  A5 1D       LDA actor2_x
.C:6032  38          SEC
.C:6033  E5 1B       SBC actor1_x
;If the result is negative, convert it to positive
.C:6035  B0 05       BCS set_x_distance
.C:6037  49 FF       EOR #$FF
.C:6039  18          CLC
.C:603a  69 01       ADC #$01
set_x_distance:
.C:603c  85 1B       STA actor1_x
;---------------------------
compute_y_distance:
;Subtract the 2 coordinates
.C:603e  A5 1E       LDA actor2_y
.C:6040  38          SEC
.C:6041  E5 1C       SBC actor1_y
;If the result is negative, convert it to positive
.C:6043  B0 05       BCS set_y_distance
.C:6045  49 FF       EOR #$FF
.C:6047  18          CLC
.C:6048  69 01       ADC #$01
set_y_distance:
;Y distance is divided by 4
.C:604a  4A          LSR A
.C:604b  4A          LSR A
.C:604c  85 1C       STA actor1_y
;----------------------------------
;Is the Y distance <= the X distance?
.C:604e  C5 1B       CMP actor1_x
.C:6050  90 0B       BCC y_distance_le_x_distance
.C:6052  F0 09       BEQ y_distance_le_x_distance
;----------------------------------
;Y distance > X distance
; Distance = X_distance * 2 + Y_distance
.C:6054  A5 1B       LDA actor1_x
.C:6056  0A          ASL A
.C:6057  18          CLC
.C:6058  65 1C       ADC actor1_y
.C:605a  4C 63 60    JMP exit
;----------------------------------
y_distance_le_x_distance:
; Distance = Y_distance * 2 + X_distance
.C:605d  A5 1C       LDA actor1_y
.C:605f  0A          ASL A
.C:6060  18          CLC
.C:6061  65 1B       ADC actor1_x
exit:
.C:6063  60          RTS
;===========================================
; Handles paused script by advancing the pause counters.
;
; There are 3 bytes used for pause counting, constituting a 24-bit overall counter.
;
; counter_3 is incremented by one on each routine call, until it reaches zero.
; At that point, a carry takes place and counter_2 is incremented by one.
; And so on with carry propagation with counter_1.
; When counter_1 reaches 0, the script is unpaused.
;===========================================
handle_paused_scripts:
.C:6064  A2 0F       LDX #$0F
check_script:
;Is the script paused?
.C:6066  BD D9 70    LDA script_state_for_script_slot,X
.C:6069  C9 01       CMP #$01
;If not, continue
.C:606b  D0 14       BNE next_script
;Increment the pause counters, propagating carries
.C:606d  FE 09 71    INC script_pause_counter_3,X
.C:6070  D0 0F       BNE next_script
.C:6072  FE F9 70    INC script_pause_counter_2,X
.C:6075  D0 0A       BNE next_script
.C:6077  FE E9 70    INC script_pause_counter_1,X
.C:607a  D0 05       BNE next_script
;If the most significant counter reached 00, unpause the script
.C:607c  A9 02       LDA #$02
.C:607e  9D D9 70    STA script_state_for_script_slot,X
next_script:
.C:6081  CA          DEX
.C:6082  D0 E2       BNE check_script
.C:6084  60          RTS
;===========================================
; Returns a script object index (lo/hi) to be used as part of a queued sentence
;
; Script byte 0		operation mode
;					#FF		return the active indirect object indexes
;					#FE		return the active direct object indexes
;					otherwise	return the script byte 0 as low index
;								if bit 7 of opcode is set, return #01 as hi index
;								if bit 7 of opcode is clear, return #00 as hi index
;
; Returns:		low_byte
;				hi_byte		
;===========================================
low_byte = $d0
hi_byte = $d1
input_opcode = $d2

get_script_object_for_sentence:
;Read mode operand
.C:6085  20 14 5E    JSR script_read_byte
.C:6088  C9 FF       CMP #$FF
.C:608a  D0 0B       BNE check_fe
;-------------------------------------------
; Mode #FF - return active indirect object
;-------------------------------------------
.C:608c  AD 1D FE    LDA active_indirect_object
.C:608f  85 D0       STA low_byte
.C:6091  AD 1E FE    LDA active_indirect_object_hi
.C:6094  85 D1       STA hi_byte
.C:6096  60          RTS
;-------------------------------------------
check_fe:
.C:6097  C9 FE       CMP #$FE
.C:6099  D0 0B       BNE default
;-------------------------------------------
; Mode #FE - return active direct object
;-------------------------------------------
.C:609b  AD 1A FE    LDA active_object_lo
.C:609e  85 D0       STA low_byte
.C:60a0  AD 1B FE    LDA active_object_hi
.C:60a3  85 D1       STA hi_byte
.C:60a5  60          RTS
;-------------------------------------------
; ALl other values - return value as low byte
;-------------------------------------------
default:
.C:60a6  85 D0       STA low_byte
;Is bit 7 of the input_opcode set? 
.C:60a8  A5 D2       LDA input_opcode
.C:60aa  10 05       BPL set_00_hi
set_01_hi:
;Bit 7 set, set hi to #01
.C:60ac  A9 01       LDA #$01
.C:60ae  4C B3 60    JMP set_hi
set_00_hi:
;Bit 7 clear, set hi to #00
.C:60b1  A9 00       LDA #$00
set_hi:
.C:60b3  85 D1       STA hi_byte
.C:60b5  60          RTS
;===========================================
;Opcode #58 - interrupt script
;===========================================
;Calculate the current relative offset of the script
; by subtracting: script_pointer - current_script_base
; Save the result in interrupted_script_offset so we can restore it later
.C:60b6  AD 15 5E    LDA script_read_pointer_lo
.C:60b9  38          SEC
.C:60ba  ED 8A FE    SBC current_script_rsrc_base_lo
.C:60bd  8D A4 FE    STA interrupted_script_offset_lo
.C:60c0  AD 16 5E    LDA script_read_pointer_hi
.C:60c3  ED 8B FE    SBC current_script_rsrc_base_hi
.C:60c6  8D A5 FE    STA interrupted_script_offset_hi
;Save the interrupted script index
.C:60c9  AD B8 70    LDA current_script_slot
.C:60cc  8D A7 FE    STA interrupted_script_index
;The next 3 bytes are read and discarded
.C:60cf  20 14 5E    JSR script_read_byte
.C:60d2  20 11 5E    JSR script_skip_offset
.C:60d5  60          RTS
;===========================================
;Opcode #18
;
; Read a 16-bit relative offset, add it to the script pointer
;===========================================
relative_offset = $d2

script_displace_pointer:
;Read 16-bit offset
.C:60d6  20 14 5E    JSR script_read_byte
.C:60d9  85 D2       STA <relative_offset
.C:60db  20 14 5E    JSR script_read_byte
.C:60de  85 D3       STA >relative_offset
;Add offset to script_pointer
.C:60e0  AD 15 5E    LDA script_read_pointer_lo
.C:60e3  18          CLC
.C:60e4  65 D2       ADC <relative_offset
.C:60e6  8D 15 5E    STA script_read_pointer_lo
.C:60e9  AD 16 5E    LDA script_read_pointer_hi
.C:60ec  65 D3       ADC >relative_offset
.C:60ee  8D 16 5E    STA script_read_pointer_lo
.C:60f1  60          RTS
;===========================================
;Opcode #00, #A0 - stop object code
;===========================================
stop_object_code:
;Load current script index
.C:60f2  AE B8 70    LDX current_script_slot
;If it's zero, stop this script
.C:60f5  F0 06       BEQ stop_this_script
;It's nonzero - get the script's resource index
.C:60f7  BD 29 71    LDA resource_index_for_script_slot,X
;Find and deactivate it
.C:60fa  20 67 5E    JSR find_and_deactivate_script
;Stop the _current_ script we're executing (the one that ran the stop object code operation)
; by pulling the return address from the stack
stop_this_script:
.C:60fd  68          PLA
.C:60fe  68          PLA
.C:60ff  60          RTS
;===========================================
;Opcode #10 - stop script execution
;===========================================
stop_script_execution:
;Stop the _current_ script we're executing by pulling the return address from the stack
.C:6100  68          PLA
.C:6101  68          PLA
;Update the script relative offset (as we're halting execution)
.C:6102  4C B0 5D    JMP save_script_relative_offset
;===========================================
;Opcode #50, #D0 - do nothing
;===========================================
.C:6105  60          RTS
;===========================================
; Copy operand value to variable
;
; First byte: destination variable index
; Second byte: operand
;
; Opcode #1A (immediate), #9A (variable)
;===========================================
var_index = $D0
;Read variable index
.C:6106  20 14 5E    JSR script_read_byte
.C:6109  85 D0       STA var_index
;Read operand value
.C:610b  20 98 5F    JSR script_load_operand_bit7
;Copy value to variable
.C:610e  A6 D0       LDX var_index
.C:6110  9D 67 FF    STA game_vars,X
.C:6113  60          RTS
;===========================================
; Increment variable value by 1
; 
; Opcode #46
;===========================================
script_increment_var:
;Read variable index into .X
.C:6114  20 98 5F    JSR script_load_operand_bit7
.C:6117  AA          TAX
;Increment variable value
.C:6118  FE 67 FF    INC game_vars,X
.C:611b  60          RTS
;===========================================
; Decrement variable value by 1
; 
; Opcode #C6
;===========================================
script_decrement_var:
;Read variable index into .X
.C:611c  20 98 5F    JSR script_load_operand_bit7
.C:611f  AA          TAX
;Decrement variable value
.C:6120  DE 67 FF    DEC game_vars,X
.C:6123  60          RTS
;===========================================
; Add value to variable
;
; Opcode #5A (immediate), #DA (variable)
;===========================================
operand_value = $D0
;Read variable index into .Y
.C:6124  20 14 5E    JSR script_read_byte
.C:6127  A8          TAY
;Read operand value
.C:6128  20 98 5F    JSR script_load_operand_bit7
.C:612b  85 D0       STA operand_value
;Add operand value to variable
.C:612d  B9 67 FF    LDA game_vars,Y
.C:6130  18          CLC
.C:6131  65 D0       ADC operand_value
.C:6133  99 67 FF    STA game_vars,Y
.C:6136  60          RTS
;===========================================
; Subtract value from variable
;
; Opcode #3A (immediate), #BA (variable)
;===========================================
operand_value = $D0
;Read variable index into .Y
.C:6137  20 14 5E    JSR script_read_byte
.C:613a  A8          TAY
;Read operand value
.C:613b  20 98 5F    JSR script_load_operand_bit7
.C:613e  85 D0       STA operand_value
;Subtract operand value from variable
.C:6140  B9 67 FF    LDA game_vars,Y
.C:6143  38          SEC
.C:6144  E5 D0       SBC operand_value
.C:6146  99 67 FF    STA game_vars,Y
.C:6149  60          RTS
;===========================================
; Comparison operations
;
; These operations perform an arithmetic comparison of a variable against an operand.
; This comprises the most usual ones: equal, not equal, greater than, etc.
; Script execution is altered based on the comparison result.
; 
; This can be thought of as:
;
; if (condition)
; then {
;		...code block...
;		}
;
; Note that there is no explicit "else" support from the engine. Thus, this can't be done directly:
;
; if (condition)
; then {
;		...code block...
;		}
; else {
;		...another code block...
;		}
;	...common code block... (executed regardless of the condition value)
;
; In the example above, there's a code block executed only if the condition is True, another that's executed only if the condition is False, and
; finally the rest of the code (which will be executed regardless of the condition). 
;
; As there is no "else" support, code following an "if/then" block will be _always_ executed.
;
; In order to simulate an "else"-like block, the script needs to have another "if", inverting the condition, like this:
;
; if (condition)
; then {
;		...code block...
;		}
; if (opposite condition)
; then	{
;		...another code block...
;		}
;
; Bottom line: the script engine needs to know where to continue executing in case the condition is False, to skip over the instructions
; that belong to the "condition is True" block. This is a relative offset that can be applied to the current execution pointer.
;
; So to fully represent a conditional operation, we need:
;
;	-the condition operation itself
;	-the first operand (a variable)
;	-the second operand (a variable or an immediate value)
;	-the condition-False offset
;
; The order in which these bytes appear is:
;
;	comparison_opcode 
;	comparison_operand1
;	comparison_operand2 (if applicable)
;	condition_false_offset
;	<condition-True code>
;
; The script engine will read the opcode and operands and perform the condition evaluation.
; If the condition is True, then the offset is not applied and the code to be executed follow immediately after.
; It only has to skip over the offset to get to the "condition-True" code.
;
; If the condition is False, then the offset needs to be read and applied (added).
;
; So if the condition is true, the conditional branch will be taken and the displacement will be skipped (a single byte).
; If the condition is false, the conditional branch is not taken, and the displacement is added.
;===========================================
;===========================================
; Is operand non-zero?
;
; Opcode #28
;===========================================
;Load operand
.C:614a  20 98 5F    JSR script_load_operand_bit7
;Is the operand != 00? (the condition)
.C:614d  C9 00       CMP #$00
.C:614f  D0 03       BNE is_not_equal_to_zero_then
is_equal_to_zero:
;Add offset as the condition is False
.C:6151  4C D6 60    JMP script_displace_pointer
is_not_equal_to_zero_then:
;Skip offset and execute the <condition-True> code
.C:6154  20 11 5E    JSR script_skip_offset
.C:6157  60          RTS
;===========================================
; Is operand zero?
;
; Opcode #A8
;===========================================
;Load operand
.C:6158  20 98 5F    JSR script_load_operand_bit7
;Is the operand == 00? (the condition)
.C:615b  C9 00       CMP #$00
.C:615d  F0 03       BEQ is_equal_to_zero_then
is_not_equal_to_zero:
;Add offset as the condition is False
.C:615f  4C D6 60    JMP script_displace_pointer
is_equal_to_zero_then:
;Skip offset and execute the <condition-True> code
.C:6162  20 11 5E    JSR script_skip_offset
.C:6165  60          RTS
;===========================================
; Is operand 1 >= operand 2?
;
;	Carry		Set 	if operand_1 >= operand_2
;
; Opcode #38, #B8
;===========================================
;Load and compare operands
.C:6166  20 79 5F    JSR script_compare_operands
;Is operand 1 >= operand 2?
.C:6169  B0 03       BCS is_ge_then
is_not_ge:
;Add offset as the condition is False
.C:616b  4C D6 60    JMP script_displace_pointer
is_ge_then:
;Skip offset and execute the <condition-True> code
.C:616e  4C 11 5E    JMP script_skip_offset
;===========================================
; Is operand 1 <= operand 2?
;
;	Carry		Clear 	if operand_1 < operand_2
;	Zero		Set		if operand_1 == operand_2
;
; Opcode #04, #84
;===========================================
;Load and compare operands
.C:6171  20 79 5F    JSR script_compare_operands
;Is operand 1 <= operand 2?
.C:6174  90 05       BCC is_le_then
.C:6176  F0 03       BEQ is_le_then	
is_not_le:
;Add offset as the condition is False
.C:6178  4C D6 60    JMP script_displace_pointer
is_le_then:
;Skip offset and execute the <condition-True> code
.C:617b  4C 11 5E    JMP script_skip_offset
;===========================================
; Is operand 1 > operand 2?
;
;	Carry		Set 	if operand_1 >= operand_2
;	Zero		Set		if operand_1 == operand_2
;
; Opcode #44, #C4
;===========================================
;Load and compare operands
.C:617e  20 79 5F    JSR script_compare_operands
;Is operand 1 > operand 2?
.C:6181  F0 02       BEQ is_not_gt		;Equality implies: not >
.C:6183  B0 03       BCS is_gt_then		;>= and != is equivalent to >
is_not_gt:
;Add offset as the condition is False
.C:6185  4C D6 60    JMP script_displace_pointer
is_gt_then:
;Skip offset and execute the <condition-True> code
.C:6188  4C 11 5E    JMP script_skip_offset
;===========================================
; Is operand 1 < operand 2?
;
;	Carry		Clear 	if operand_1 < operand_2
;
; Opcode #78, #F8
;===========================================
;Load and compare operands
.C:618b  20 79 5F    JSR script_compare_operands
;Is operand 1 < operand 2?
.C:618e  90 03       BCC is_lt_then
is_not_lt:
;Add offset as the condition is False
.C:6190  4C D6 60    JMP script_displace_pointer
is_lt_then:
;Skip offset and execute the <condition-True> code
.C:6193  4C 11 5E    JMP script_skip_offset
;===========================================
; Is operand 1 != operand 2?
;
;	Zero		Clear	if operand_1 != operand_2
;
; Opcode #08, #88
;===========================================
;Load and compare operands
.C:6196  20 79 5F    JSR script_compare_operands
;Is operand 1 != operand 2?
.C:6199  D0 03       BNE is_ne_then
;Add offset as the condition is False
.C:619b  4C D6 60    JMP script_displace_pointer
is_ne_then:
;Skip offset and execute the <condition-True> code
.C:619e  4C 11 5E    JMP script_skip_offset
;===========================================
; Is operand 1 == operand 2?
;
;	Zero		Set		if operand_1 == operand_2
;
; Opcode #48, #C8
;===========================================
;Load and compare operands
.C:61a1  20 79 5F    JSR script_compare_operands
;Is operand 1 == operand 2?
.C:61a4  F0 03       BEQ is_eq_then
;Add offset as the condition is False
.C:61a6  4C D6 60    JMP script_displace_pointer
is_eq_then:
;Skip offset and execute the <condition-True> code
.C:61a9  4C 11 5E    JMP script_skip_offset
;===========================================
; Stop a script
;
; If the script index is #00, stops the current script
;
; Opcode #62, #E2
;===========================================
;Load operand (script index)
.C:61ac  20 98 5F    JSR script_load_operand_bit7
;Entry point for multiple opcodes (from 6AD9) - coming with .X set to #00
stop_script_index_check:
.C:61af  C9 00       CMP #$00
.C:61b1  D0 06       BNE script_nonzero
script_zero:
;The script index provided was #00, so set things to stop the current script
.C:61b3  AE B8 70    LDX current_script_slot
.C:61b6  BD 29 71    LDA resource_index_for_script_slot,X
script_nonzero:
;Load the current script index - if it's #00, stop the script
.C:61b9  AE B8 70    LDX current_script_slot
.C:61bc  F0 08       BEQ stop_script
;Check if the current script resource index matches the script index to stop
.C:61be  DD 29 71    CMP resource_index_for_script_slot,X
;If not, stop the current script
.C:61c1  D0 03       BNE stop_script
;The current script resource index does not match the script index to stop
;So stop the object code
.C:61c3  4C F2 60    JMP stop_object_code
stop_script:
.C:61c6  20 67 5E    JSR find_and_deactivate_script
.C:61c9  60          RTS
;===========================================
; Start a script
;
; Opcode #42, #C2
;===========================================
;Load operand (script index)
.C:61ca  20 98 5F    JSR script_load_operand_bit7
;Start the script
.C:61cd  20 8A 5E    JSR start_global_script
;Sanity check - validate that the current script's base address is non-zero
.C:61d0  AD 8B FE    LDA current_script_rsrc_base_hi
;If so, it's valid - exit
.C:61d3  D0 02       BNE exit
;It's zero, so something went wrong
;Stop the _current_ script we're executing by pulling the return address from the stack
;The return address would return execution to execute_next_operation
;By eliminating that routine from the stack, the script execution is effectively halted
.C:61d5  68          PLA
.C:61d6  68          PLA
exit:
.C:61d7  60          RTS
;===========================================
; Do nothing
;
; Opcode #72, #F2
;===========================================
.C:61d8  60          RTS
;===========================================
; Is object attribute's bit clear?
;
;	If the bit is CLEAR, the AND yields zero, Z is set, the branch of BNE is not taken
;	If the bit is SET, the AND yields non-zero, Z is clear, the branch of BNE is taken
;===========================================
bitmask = $d0

script_is_object_attr_bit_clear:
;Save bitmask
.C:61d9  85 D0       STA bitmask
;Read the object's attributes
.C:61db  20 AB 5F    JSR script_read_object_attributes
;AND the attributes with the bitmask - if AND yields zero, Z flag is set
.C:61de  25 D0       AND bitmask
.C:61e0  D0 03       BNE bit_is_set_then
bit_is_not_set:
;Add offset as the condition is False
.C:61e2  4C D6 60    JMP script_displace_pointer
bit_is_set_then:
;Skip offset and execute the <condition-True> code
.C:61e5  4C 11 5E    JMP script_skip_offset
;===========================================
; Is object attribute's bit set?
;
;	If the bit is CLEAR, the AND yields zero, Z is set, the branch of BEQ is taken
;	If the bit is SET, the AND yields non-zero, Z is clear, the branch of BEQ is not taken
;===========================================
bitmask = $d0

script_is_object_attr_bit_set:
;Save bitmask
.C:61e8  85 D0       STA bitmask
;Read the object's attributes
.C:61ea  20 AB 5F    JSR script_read_object_attributes
;AND the attributes with the bitmask - if AND yields zero, Z flag is set
.C:61ed  25 D0       AND bitmask
.C:61ef  F0 03       BEQ bit_is_clear_then
bit_is_not_clear:
;Add offset as the condition is False
.C:61f1  4C D6 60    JMP script_displace_pointer
bit_is_clear_then:
;Skip offset and execute the <condition-True> code
.C:61f4  4C 11 5E    JMP script_skip_offset
;===========================================
; Different entry points for the 2 routines above
; Each of these operations tests if an item's attributes bit is set or clear
;===========================================
;Opcode #AF, #EF
.C:61f7  A9 80       LDA #$80
.C:61f9  D0 ED       BNE script_is_object_attr_bit_set
;Opcode #2F, #6F
.C:61fb  A9 80       LDA #$80
.C:61fd  D0 DA       BNE script_is_object_attr_bit_clear
;Opcode #9F, #DF
.C:61ff  A9 40       LDA #$40
.C:6201  D0 E5       BNE script_is_object_attr_bit_set
;Opcode #1F, #5F
.C:6203  A9 40       LDA #$40
.C:6205  D0 D2       BNE script_is_object_attr_bit_clear
;Opcode #7F, #BF
.C:6207  A9 20       LDA #$20
.C:6209  D0 DD       BNE script_is_object_attr_bit_set
;Opcode #3F, #FF
.C:620b  A9 20       LDA #$20
.C:620d  D0 CA       BNE script_is_object_attr_bit_clear
;===========================================
; Clear an object attribute's bit
;
; Argument:	.A	bitmask used to clear a specific bit
;===========================================
and_item_attrs:
clear_bitmask = $d0
;Save the clear bitmask
.C:620f  85 D0       STA clear_bitmask
;Read the item's attributes
.C:6211  20 AB 5F    JSR script_read_object_attributes
;AND the attributes with the bitmask
.C:6214  25 D0       AND clear_bitmask
;Write back the resulting attributes
.C:6216  4C C3 5F    JMP script_set_object_attributes
;===========================================
; Set an object attribute's bit
;
; Argument:	.A	bitmask used to set a specific bit
;===========================================
or_item_attrs:
set_bitmask = $d0
;Save bitmask
.C:6219  85 D0       STA set_bitmask
;Read the item's attributes
.C:621b  20 AB 5F    JSR script_read_object_attributes
;OR the attributes with the bitmask
.C:621e  05 D0       ORA set_bitmask
;Write back the resulting attributes
.C:6220  4C C3 5F    JMP script_set_object_attributes
;===========================================
; Entry points for the 2 routines above
; Each of these operations sets or clears an objects's attributes bit
;===========================================
;Opcode #97, #D7 - Set bit 7 (OR with #80) of item attributes
.C:6223  A9 80       LDA #$80
.C:6225  D0 F2       BNE or_item_attrs
;Opcode #17, #57 - Clear bit 7 of item attributes
.C:6227  A9 7F       LDA #$7F
.C:6229  D0 E4       BNE and_item_attrs
;Opcode #B7, #F7 - Set bit 6 (OR with #40) of item attributes
.C:622b  A9 40       LDA #$40
.C:622d  D0 EA       BNE or_item_attrs
;Opcode #37, #77 - Clear bit 6 of item attributes
.C:622f  A9 BF       LDA #$BF
.C:6231  D0 DC       BNE and_item_attrs
;Opcode #8F, #CF - Set bit 5 (OR with #20) of item attributes
.C:6233  A9 20       LDA #$20
.C:6235  D0 E2       BNE or_item_attrs
;Opcode #0F, #4F - Clear bit 5 of item attributes
.C:6237  A9 DF       LDA #$DF
.C:6239  D0 D4       BNE and_item_attrs
;===========================================
;Opcode #A4 - ifNotEqualActiveObject
;===========================================
;Compare the active indirect object index but ignore the hi part
.C:623b  A9 01       LDA #$01
.C:623d  D0 02       BNE check_active_object
;===========================================
;Opcode #24
;===========================================
;Compare the active indirect object index fully (hi and low)
.C:623f  A9 00       LDA #$00
check_active_object:
.C:6241  20 5D 62    JSR compare_active_indirect_obj_indexes
.C:6244  F0 03       BEQ condition_is_true
;Add offset as the condition is False
.C:6246  4C D6 60    JMP script_displace_pointer
condition_is_true:
;Skip offset and execute the <condition-True> code
.C:6249  4C 11 5E    JMP script_skip_offset
;===========================================
;Opcode #E4 - ifEqualActiveObject
;===========================================
;Compare the active indirect object index but ignore the hi part
.C:624c  A9 01       LDA #$01
.C:624e  D0 02       BNE check_active_object
;===========================================
;Opcode #64
;===========================================
;Compare the active indirect object index fully (hi and low)
.C:6250  A9 00       LDA #$00
check_active_object:
.C:6252  20 5D 62    JSR compare_active_indirect_obj_indexes
.C:6255  D0 03       BNE condition_is_true
;Add offset as the condition is False
.C:6257  4C D6 60    JMP script_displace_pointer
condition_is_true:
;Skip offset and execute the <condition-True> code
.C:625a  4C 11 5E    JMP script_skip_offset
;===========================================
; This helper will compare the hi and lo parts of the 
; active indirect object indexes.
;
; Arguments:	.A		operation_mode
; Returns:		.A		comparison result (True/False)
;
; It has 2 modes of operation:
;	-one compares only the lo index against a byte in the script
;	-the other one compares the hi index against #00 first, then the lo index against a byte in the script
;
; If there's no equality (against #00/lo index accordingly), it returns False (#00).
; Otherwise, returns True (#01)
;===========================================
compare_active_indirect_obj_indexes:
;Branch on mode (#00 or #01)
.C:625d  F0 0A       BEQ compare_lo_and_hi
;--------------------------------------------------
; Mode #01 (only lo)
;
;In this mode, the lo index is compared with a byte read from the script
;The hi index is completely ignored
;If the lo index matches the byte read, this routine returns True (#01)
;Otherwise, it returns False (#00)
;--------------------------------------------------
compare_only_lo:
;Is the hi index of the active indirect object #00?
.C:625f  AD 1E FE    LDA active_indirect_object_hi
.C:6262  F0 02       BEQ jump_regardless
;It doesn't matter anyway, because if it isn't, jump to the next section and set .A to #00
.C:6264  A9 00       LDA #$00
jump_regardless:
.C:6266  4C 6D 62    JMP is_z_flag_set
;--------------------------------------------------
; Mode #00 (lo and hi)
;
;In this mode, the hi index is compared against #00
;If it's not #00, it returns False (#00)
;Otherwise, it compares the lo index against a byte read from the script
;If they are equal, this routine returns True (#01)
;Otherwise, it returns False (#00)
;--------------------------------------------------
compare_lo_and_hi:
.C:6269  18          CLC
.C:626a  6D 1E FE    ADC active_indirect_object_hi
is_z_flag_set:
.C:626d  F0 06       BEQ z_flag_set
;Object index hi is not #00
;Skip the next byte (index lo) as we know already the index is not equal
.C:626f  20 14 5E    JSR script_read_byte
;Return False (#00)
.C:6272  A9 00       LDA #$00
.C:6274  60          RTS
z_flag_set:
;Read the object index lo
.C:6275  20 14 5E    JSR script_read_byte
;Does it match the indirect object lo?
.C:6278  CD 1D FE    CMP active_indirect_object
;If so, return True (#01)
.C:627b  F0 03       BEQ return_01
;Otherwise return False (#00)
.C:627d  A9 00       LDA #$00
.C:627f  60          RTS
return_01:
.C:6280  A9 01       LDA #$01
.C:6282  60          RTS
;===========================================
; Opcode #90 - pickup object
;
; This routine will:
;
;	-Find an object's pointer (as a room's resource)
;	-Allocate a memory block for it
;	-Copy it to the allocated block
;	-Find a free inventory slot for it
;	-Store the object in the free slot
;	-Set the current kid as the owner
;	-Update object attributes
;	-Refresh the items displayed (the inventory)
;
;===========================================
object_index = $15
object_state = $16
object_index_copy = $97
object_size = $9c
obj_read_ptr = $98
object_ptr_lo = $15
object_ptr_hi = $16
allocated_block = $9a

;Read operand (object index)
.C:6283  20 14 5E    JSR script_read_byte
;Is index != #00? If so, we have an explicit object index
.C:6286  C9 00       CMP #$00
.C:6288  D0 03       BNE set_object_index
;Index == 00, so use the active object instead
.C:628a  AD 1A FE    LDA active_object_lo
set_object_index:
.C:628d  85 15       STA object_index
.C:628f  85 97       STA object_index_copy
.C:6291  A9 00       LDA #$00
.C:6293  85 16       STA object_state
;Find the object in the room
.C:6295  20 37 0A    JSR get_obj_resource_in_room
;Did we find it? 
.C:6298  C9 FF       CMP #$FF
.C:629a  D0 01       BNE object_found
;If not, exit
.C:629c  60          RTS
;-------------------------------------------
; Object found - find its size and allocate a memory block for it
;-------------------------------------------
object_found:
;Copy the object pointer found to obj_read_ptr
.C:629d  A5 15       LDA object_ptr_lo
.C:629f  85 98       STA <obj_read_ptr
.C:62a1  A5 16       LDA object_ptr_hi
.C:62a3  85 99       STA >obj_read_ptr
;Read the object size from the pointer
.C:62a5  A0 00       LDY #$00
.C:62a7  B1 98       LDA (obj_read_ptr),Y
.C:62a9  85 9C       STA <object_size
.C:62ab  C8          INY
.C:62ac  B1 98       LDA (obj_read_ptr),Y
.C:62ae  85 9D       STA >object_size
;Allocate a block for that size
.C:62b0  A6 9C       LDX <object_size
.C:62b2  A4 9D       LDY >object_size
.C:62b4  20 E4 54    JSR alloc_data
;Save the pointer to the allocated block
.C:62b7  86 9A       STX <allocated_block
.C:62b9  84 9B       STY >allocated_block
;-------------------------------------------
; Get pointer to object (again) 
;-------------------------------------------
;Set arguments for finding the object (again)
.C:62bb  A5 97       LDA object_index_copy
.C:62bd  85 15       STA object_index
.C:62bf  A9 00       LDA #$00
.C:62c1  85 16       STA object_state
;Find the object in the room (again) and get its pointer
.C:62c3  20 37 0A    JSR get_obj_resource_in_room
;Copy the pointer to obj_read_ptr (again)
.C:62c6  A5 15       LDA object_ptr_lo
.C:62c8  85 98       STA <obj_read_ptr
.C:62ca  A5 16       LDA object_ptr_hi
.C:62cc  85 99       STA >obj_read_ptr
;-------------------------------------------
; Copy the object's data into the allocated block
;-------------------------------------------
;Copy the object_size low byte into .Y - the hi byte is ignored
.C:62ce  A4 9C       LDY <object_size
;Use .Y as a copy counter - go downwards
.C:62d0  88          DEY
copy_loop:
;Copy from the object read pointer to the allocated block
.C:62d1  B1 98       LDA (obj_read_ptr),Y
.C:62d3  91 9A       STA (allocated_block),Y
.C:62d5  88          DEY
;Stop copying if we find #FF
.C:62d6  C0 FF       CPY #$FF
.C:62d8  D0 F7       BNE copy_loop
;-------------------------------------------
; Find and allocate an inventory slot
;-------------------------------------------
;Write the resource type in offset #02 of the block
;Resource type is #01 (object)
.C:62da  A0 02       LDY #$02
.C:62dc  A9 01       LDA #$01
.C:62de  91 9A       STA (allocated_block),Y
;Find a free inventory slot - value returned in .Y
.C:62e0  20 CF 5F    JSR find_free_inventory_slot
;Store the pointer to the object block
.C:62e3  A5 9A       LDA <allocated_block
.C:62e5  99 5E 70    STA object_rsrc_ptrs_lo,Y
.C:62e8  A5 9B       LDA >allocated_block
.C:62ea  99 8B 70    STA object_rsrc_ptrs_hi,Y
;Save the object index in the inventory slot
.C:62ed  A5 97       LDA object_index_copy
.C:62ef  99 31 70    STA inventory_objects,Y
;Write the inventory index in offset #03 of the block
.C:62f2  98          TYA
.C:62f3  A0 03       LDY #$03
.C:62f5  91 9A       STA (allocated_block),Y
;-------------------------------------------
; Update the object's owner and attributes
;-------------------------------------------
;Fetch the object attributes
.C:62f7  A4 97       LDY object_index_copy
.C:62f9  B9 01 73    LDA object_attributes,Y
;Set bits 7 and 5
;Mark object as stored in parent object
;Mark object as removed from room (to stop drawing its original state in the future)
.C:62fc  09 A0       ORA #$A0
;Set current_kid as object owner
.C:62fe  29 F0       AND #$F0
.C:6300  0D 67 FF    ORA current_kid
.C:6303  99 01 73    STA object_attributes,Y
;Set default camera position
.C:6306  A9 C8       LDA #$C8
.C:6308  8D 67 06    STA camera_current_position
.C:630b  20 B4 5D    JSR handle_script_relocation
.C:630e  20 2B 5F    JSR refresh_items_displayed
.C:6311  60          RTS
;===========================================
; Loads a room
;
; Opcode #25, #A5 - load room
;===========================================
room_index = $d0
;Load operand (room index)
.C:6312  20 98 5F    JSR script_load_operand_bit7
.C:6315  85 D0       STA room_index
;Is it the current room we're in?
.C:6317  CD 49 71    CMP current_room
.C:631a  F0 08       BEQ room_loaded
;It's not, so prepare for the new room
.C:631c  20 9D D6    JSR prepare_video_for_new_room		
;Load the room
.C:631f  A6 D0       LDX room_index
.C:6321  20 66 34    JSR load_room
room_loaded:
;Room loaded
.C:6324  20 B4 5D    JSR handle_script_relocation
;Set default camera position
.C:6327  A9 C8       LDA #$C8
.C:6329  8D 67 06    STA camera_current_position
.C:632c  60          RTS
;===========================================
;Opcode #E5 - load room with ego
;===========================================
object_index = $15
object_state = $16

.C:632d  AE 67 FF    LDX current_kid
;Check if kid is frozen (as when captured by an enemy)
.C:6330  BD E3 FE    LDA actor_vars,X
.C:6333  29 40       AND ACTOR_IS_FROZEN
.C:6335  F0 06       BEQ entry
;Kid is frozen - skip 2 bytes, stop object code, exit
.C:6337  20 11 5E    JSR script_skip_offset
.C:633a  4C F2 60    JMP stop_object_code
entry:
.C:633d  20 9D D6    JSR prepare_video_for_new_room
;Read "room entry" object index - this is the object where the player will be put at
.C:6340  20 14 5E    JSR script_read_byte
;Save object index in stack
.C:6343  48          PHA
;Read room index
.C:6344  20 14 5E    JSR script_read_byte
;Set room for current kid
.C:6347  AE 67 FF    LDX current_kid
.C:634a  9D FC FE    STA room_for_character,X
;Load the room
.C:634d  AA          TAX
.C:634e  20 66 34    JSR load_room
;Restore object index from stack, set it as argument for get_obj_resource_in_room
.C:6351  68          PLA
.C:6352  85 15       STA object_index
;Set the object search location argument to #00 - this is ignored by the routine
.C:6354  A9 00       LDA #$00
.C:6356  85 16       STA object_state
;Find the object in the room
.C:6358  20 37 0A    JSR get_obj_resource_in_room
;Did we find it?
.C:635b  C0 FF       CPY #$FF
.C:635d  D0 03       BNE object_found
;We didn't - exit
.C:635f  4C 8E 63    JMP exit
object_found:
;Set the destination based on the object's position
.C:6362  20 75 0F    JSR set_destination_for_object
;Move the current kid to the position
.C:6365  AD 67 FF    LDA current_kid
.C:6368  8D 30 FC    STA active_costume
.C:636b  AD 49 71    LDA current_room
.C:636e  8D EA FD    STA room_destination
.C:6371  20 9C 26    JSR put_actor_at_destination
;Set the camera position at the kid's position
.C:6374  AE 67 FF    LDX current_kid
.C:6377  BD 57 FE    LDA actor_for_costume,X
.C:637a  AA          TAX
.C:637b  BD 41 FD    LDA position_x_for_actor,X
.C:637e  8D 66 06    STA camera_desired_position
;Set default camera position
.C:6381  A9 C8       LDA #$C8
.C:6383  8D 67 06    STA camera_current_position
;Reset the sentence queue
.C:6386  20 CC 29    JSR reset_sentence_queue_system
;???
.C:6389  A9 00       LDA #$00
.C:638b  8D 8E FE    STA click_trigger_sentence
exit:
.C:638e  4C F2 60    JMP stop_object_code
;===========================================
; Set actor's bit attribute
;Opcode #0B, #2B, #4B, #6B, #8B, #AB, #CB, #EB
;===========================================
pointer = $d0
max_var_index = $d2
;Set up base pointer for the next operation to actor_vars (actor variables)
.C:6391  A9 E3       LDA #$E3
.C:6393  85 D0       STA <pointer
.C:6395  A9 FE       LDA #$FE
.C:6397  85 D1       STA >pointer
;Set max var value to #19 (max actor index)
.C:6399  A9 19       LDA #$19
.C:639b  85 D2       STA max_var_index
.C:639d  20 C8 63    JSR set_or_clear_bit_on_var
.C:63a0  4C 2B 5F    JMP refresh_items_displayed
;===========================================
; Get actor's bit attribute
;Opcode #1B, #5B, #9B, #DB
;===========================================
pointer = $d0
;Set up base pointer for the next operation to actor_vars (actor variables)
.C:63a3  A9 E3       LDA #$E3
.C:63a5  85 D0       STA <pointer
.C:63a7  A9 FE       LDA #$FE
.C:63a9  85 D1       STA >pointer
.C:63ab  4C EF 63    JMP test_var_bitmask
;===========================================
; Set bit on variable
;Opcode #1D, #3D, #5D, #7D, #9D, #BD, #DD, #FD - set operation
;===========================================
max_var_index = $d2
pointer = $d0
;Set up base pointer for the next operation to $FEAC (engine variables)
.C:63ae  A9 AC       LDA <pointer
.C:63b0  85 D0       STA $D0
.C:63b2  A9 FE       LDA >pointer
.C:63b4  85 D1       STA $D1
;Set max var value to #19 (max var index)
.C:63b6  A9 37       LDA #$37
.C:63b8  85 D2       STA max_var_index
.C:63ba  4C C8 63    JMP set_or_clear_bit_on_var
;===========================================
; Get bit of variable
;Opcode #31, #71, #B1, #F1 - get operation
;===========================================
pointer = $d0
;Set up base pointer for the next operation to $FEAC (engine variables)
.C:63bd  A9 AC       LDA #$AC
.C:63bf  85 D0       STA <pointer
.C:63c1  A9 FE       LDA #$FE
.C:63c3  85 D1       STA >pointer
.C:63c5  4C EF 63    JMP test_var_bitmask
;===========================================
; Set or clear a bit on a variable
;
; Arguments:		max_var_index		the maximum valid variable index
;					pointer				the base pointer for variables
;
; This routine requires 3 operands:
;	variable_index		the index of the variable to change
;	bitmask				a bitmask containing the bits to set (or clear)
;	mode				specifies whether the bits in the bitmask
;						are to be set or cleared from the variable
;						#00 is used to set, any other value to clear
;
; When mode is "clear", the bitmask will be inverted by XOR'ing with #FF,
; then AND'ed with the variable value.
;
; When mode is "set", the bitmask will be OR'ed with the variable value.
;
;===========================================
max_var_index = $d2
pointer = $d0
bitmask = $d2

set_or_clear_bit_on_var:
;Read variable index
.C:63c8  20 98 5F    JSR script_load_operand_bit7
;Check that it doesn't exceed the max var index
.C:63cb  C5 D2       CMP max_var_index
.C:63cd  90 03       BCC variable_index_valid
;Var index >= max_var_index - that's an error
;Skip the next 2 bytes and return
.C:63cf  4C 11 5E    JMP script_skip_offset
variable_index_valid:
;Store variable index #1 in .Y
.C:63d2  A8          TAY
;Read the bitmask of the bit to change
.C:63d3  20 90 5F    JSR script_load_operand_bit6
.C:63d6  85 D2       STA bitmask
;Read operation mode (set bit or clear bit)
.C:63d8  20 88 5F    JSR script_load_operand_bit5
;If mode is #00, set the bit - otherwise, clear the bit
.C:63db  C9 00       CMP #$00
.C:63dd  D0 09       BNE set_bit
clear_bit:
;Invert the bitmask (to make it a clear bitmask)
.C:63df  A5 D2       LDA bitmask
.C:63e1  49 FF       EOR #$FF
;Perform an AND with the data to clear the desired bit
.C:63e3  31 D0       AND (pointer),Y
.C:63e5  4C EC 63    JMP store_new_value
set_bit:
.C:63e8  B1 D0       LDA (pointer),Y
.C:63ea  05 D2       ORA bitmask
store_new_value:
;Store the result
.C:63ec  91 D0       STA (pointer),Y
.C:63ee  60          RTS
;===========================================
; Perform a bitwise AND on a variable and store the result
; in another variable.
;
; Equivalent to doing: result = source & bitmask
;
; Arguments:		pointer				the base pointer for variables

; This routine requires 3 operands:
;	result_variable_index		the index of the variable where the result has to be stored
;	bitmask						a bitmask containing the bits to test
;	source_variable_index		the variable actually being tested by the bitmask
;
;===========================================
result_variable_index = $d2
pointer = $d0

test_var_bitmask:
;Read result variable index
.C:63ef  20 14 5E    JSR script_read_byte
.C:63f2  85 D2       STA result_variable_index
;Read source variable index into .Y
.C:63f4  20 98 5F    JSR script_load_operand_bit7
.C:63f7  A8          TAY
;Read the AND operand
.C:63f8  20 90 5F    JSR script_load_operand_bit6
;Perform the AND against the source variable
.C:63fb  31 D0       AND (pointer),Y
;Load result variable index into .Y
.C:63fd  A4 D2       LDY result_variable_index
;If the AND yielded #00, store a #00 in the result variable
.C:63ff  C9 00       CMP #$00
.C:6401  F0 02       BEQ store_result
;Otherwise, store a #01 in the result variable
.C:6403  A9 01       LDA #$01
store_result:
;Store the result in the result variable
.C:6405  99 67 FF    STA game_vars,Y
.C:6408  60          RTS
;===========================================
; Get an object's owner
;
; Opcode #73, #F3
;===========================================
variable_index = $d0
;Read the variable index
.C:6409  20 14 5E    JSR script_read_byte
.C:640c  85 D0       STA variable_index
;Read the object number
.C:640e  20 98 5F    JSR script_load_operand_bit7
;Is it #00? If not, we have an explicit object index
.C:6411  C9 00       CMP #$00
.C:6413  D0 03       BNE fetch_object_owner
;It's #00, so use the active object
.C:6415  AD 1A FE    LDA active_object_lo
fetch_object_owner:
;Get the low nibble of the object's attributes - that's the actor owner
.C:6418  A8          TAY
.C:6419  B9 01 73    LDA object_attributes,Y
.C:641c  29 0F       AND #$0F
;Store the owner in the desired variable
.C:641e  A4 D0       LDY variable_index
.C:6420  99 67 FF    STA game_vars,Y
.C:6423  60          RTS
;===========================================
; Set an object's owner
; 
; If the item operand is set to #00, use the active object (this is useful
; to create a generic script that works for multiple objects, like when
; giving an item to the Green Tentacle).
; If the owner is set to #00, the object is removed from the inventory.
;
; Opcode #29, #69, #A9, #E9
;===========================================
owner = $d0
item = $d1

;Fetch an operand to determine the object
.C:6424  20 98 5F    JSR script_load_operand_bit7
.C:6427  C9 00       CMP #$00
.C:6429  D0 03       BNE item_determined
;If operand is #00, use the active object instead
.C:642b  AD 1A FE    LDA active_object_lo
item_determined:
.C:642e  85 D1       STA item
;Fetch another operand to determine the owner
.C:6430  20 90 5F    JSR script_load_operand_bit6
.C:6433  C9 00       CMP #$00
.C:6435  D0 05       BNE owner_determined
;If owner is #00, it means we're removing an object from the inventory
;So we need to set remove_obj_from_inv_flag
;This will force removal of objects as needed in the main_loop
;Set the flag to nonzero (#0D satisfies this)
;Set the owner to #0D as well, in the owner_determined section.
;In some cases, scripts set owner to #0D instead of #00. It has the same effect.
;Note: the game scripts do NOT care for Green Tentacle ownership (#0D would be the owner index for him)
;The only owners checked are the kids. Objects given to other characters are handled by changing variable states.
.C:6437  A9 0D       LDA #$0D
.C:6439  8D 70 06    STA remove_obj_from_inv_flag
owner_determined:
.C:643c  85 D0       STA owner
.C:643e  A4 D1       LDY item
;Get the object's attributes and keep the high nibble untouched
.C:6440  B9 01 73    LDA object_attributes,Y
.C:6443  29 F0       AND #$F0
;Set the owner in the low nibble
.C:6445  05 D0       ORA owner
.C:6447  99 01 73    STA object_attributes,Y
;Refresh the inventory items displayed
.C:644a  20 2B 5F    JSR refresh_items_displayed
.C:644d  A5 D0       LDA owner
.C:644f  20 B4 5D    JSR handle_script_relocation
.C:6452  60          RTS
;===========================================
; Remove object from inventory
;
; Arguments:	.X	 object index
;===========================================
resource_ptr = $15

remove_from_inventory:
;Get the object pointer into .X/.Y
.C:6453  20 05 0A    JSR get_obj_resource
;Did we find it in the inventory?
.C:6456  C9 00       CMP #$00
;If not, exit
.C:6458  D0 16       BNE exit
;Save inventory slot index in stack
.C:645a  98          TYA
.C:645b  48          PHA
;Set pointer to resource in .X/.Y
.C:645c  A6 15       LDX <resource_ptr
.C:645e  A4 16       LDY >resource_ptr
;Release the resource
.C:6460  20 03 55    JSR release_resource
;Restore inventory slot index from stack
.C:6463  68          PLA
.C:6464  AA          TAX
;Clear inventory slot
.C:6465  A9 00       LDA #$00
.C:6467  9D 31 70    STA inventory_objects,X
;Clear object resource pointer
.C:646a  9D 8B 70    STA object_rsrc_ptrs_hi,X
.C:646d  9D 5E 70    STA object_rsrc_ptrs_lo,X
exit:
.C:6470  60          RTS
;===========================================
;Opcode #75 - player says message
.C:6471  AD 67 FF    LDA current_kid
.C:6474  8D 9A FE    STA character_talking
;===========================================
message_ptr = $15

actor_says_message:
;Set the current script pointer as the message address
.C:6477  AD 15 5E    LDA script_read_pointer_lo
.C:647a  85 15       STA <message_ptr
.C:647c  AD 16 5E    LDA script_read_pointer_hi
.C:647f  85 16       STA >message_ptr
;Print the message
.C:6481  20 9B 27    JSR print_msg_for_actor
;Update the script pointer (it has been moved when printing the message)
;It points just past the message data
.C:6484  A5 15       LDA <message_ptr
.C:6486  8D 15 5E    STA script_read_pointer_lo
.C:6489  A5 16       LDA >message_ptr
.C:648b  8D 16 5E    STA script_read_pointer_hi
.C:648e  60          RTS
;===========================================
;Opcode #0D - player says message
;===========================================
.C:648f  AD 67 FF    LDA current_kid
.C:6492  8D 9A FE    STA character_talking
;===========================================
offset = $15
message_ptr = $15
actor_says_message_with_offset:
;Read a 16-bit offset
.C:6495  20 14 5E    JSR script_read_byte
.C:6498  85 15       STA <offset
.C:649a  20 14 5E    JSR script_read_byte
.C:649d  85 16       STA >offset
;Add offset to current script pointer to get the message address
.C:649f  18          CLC
.C:64a0  A5 15       LDA <offset
.C:64a2  6D 15 5E    ADC script_read_pointer_lo
.C:64a5  85 15       STA <message_ptr
.C:64a7  A5 16       LDA >offset
.C:64a9  6D 16 5E    ADC script_read_pointer_hi
.C:64ac  85 16       STA >message_ptr
;Subtract 1 from the address
; If we call the high and low bytes of message_ptr, "hi" and "lo" respectively, then:
;
; If lo is #00, then the address is hi/lo = hi/00
; If we subtract 1, then (hi/00) - 1 = hi-1/FF
; In this case, to subtract 1, we need to decrement hi and lo both.
;
; If instead the low byte is not #00, then (hi/lo) - 1 = (hi/lo-1).
; In this other case, to subtract 1, we only need to decrement lo.
.C:64ae  A5 15       LDA <message_ptr
.C:64b0  D0 02       BNE decrement_lo
.C:64b2  C6 16       DEC >message_ptr
decrement_lo:
.C:64b4  C6 15       DEC <message_ptr
;Print the message
.C:64b6  20 9B 27    JSR print_msg_for_actor
.C:64b9  60          RTS
;===========================================
;Opcode #14, #94 - print message
;===========================================
.C:64ba  20 98 5F    JSR script_load_operand_bit7
.C:64bd  8D 9A FE    STA character_talking
.C:64c0  4C 77 64    JMP actor_says_message
;===========================================
;Opcode #2E, #AE - actor says message (offset variant)
;===========================================
.C:64c3  20 98 5F    JSR script_load_operand_bit7
.C:64c6  8D 9A FE    STA character_talking
.C:64c9  4C 95 64    JMP actor_says_message_with_offset
;===========================================
; Get distance between two actors.
;
;Opcode #06, #34, #74, #B4, #F4
;===========================================
reference_actor = $17
current_actor = $19
destination_variable = $5f76

;Read destination variable for the distance
.C:64cc  20 14 5E    JSR script_read_byte
.C:64cf  8D 76 5F    STA destination_variable
;Read the reference actor index
.C:64d2  20 98 5F    JSR script_load_operand_bit7
.C:64d5  85 17       STA reference_actor
;Read the other actor index
.C:64d7  20 90 5F    JSR script_load_operand_bit6
.C:64da  85 19       STA current_actor
;Compute the distance
.C:64dc  20 DC 5F    JSR compute_actors_distance
;Store result in the variable
.C:64df  AE 76 5F    LDX destination_variable
.C:64e2  9D 67 FF    STA game_vars,X
.C:64e5  60          RTS
;===========================================
; Get the closest actor
;
; Opcode #66 - get closest actor
;===========================================
reference_actor = $17
current_actor = $19
destination_variable = $5f76
closest_distance = $5f77
closest_actor = $5f78

;Read destination variable for the distance
.C:64e6  20 14 5E    JSR script_read_byte
.C:64e9  8D 76 5F    STA destination_variable
;Read the reference actor index
.C:64ec  20 98 5F    JSR script_load_operand_bit7
.C:64ef  85 17       STA reference_actor
;Use current_actor as actor index, start from #19, go downwards
.C:64f1  A9 19       LDA #$19
.C:64f3  85 19       STA current_actor
init_distance_search:
;Init the search by setting the closest distance found to #FF
;Also, init the closest actor to #FF
.C:64f5  A9 FF       LDA #$FF
.C:64f7  8D 77 5F    STA closest_distance
.C:64fa  A9 FF       LDA #$FF
.C:64fc  8D 78 5F    STA closest_actor
compare_actor_distance:
;Compute the actors distance (reference_actor vs. current_actor)
.C:64ff  20 DC 5F    JSR compute_actors_distance
;Is the distance smaller than the closest distance so far?
.C:6502  CD 77 5F    CMP closest_distance
;If not, continue with the next actor
.C:6505  B0 08       BCS next_actor
;It's smaller, so save the current distance and actor as the closest ones
.C:6507  8D 77 5F    STA closest_distance
.C:650a  A5 19       LDA current_actor
.C:650c  8D 78 5F    STA closest_actor
next_actor:
;Move to next actor
.C:650f  C6 19       DEC current_actor
;Are there still actors pending? If so, continue comparing
.C:6511  D0 EC       BNE compare_actor_distance
;No more actors - set the result (the closest actor) into the variable
.C:6513  AD 78 5F    LDA closest_actor
.C:6516  AE 76 5F    LDX destination_variable
.C:6519  9D 67 FF    STA game_vars,X
.C:651c  60          RTS
;===========================================
; Get closest kid to an actor
;
; This is a variant of the routine above (get closest actor),
; but limiting it only to the kids.
;
; Opcode #26 - get closest kid
;===========================================
reference_actor = $17
current_actor = $19
destination_variable = $5f76

;Read destination variable
.C:651d  20 14 5E    JSR script_read_byte
.C:6520  8D 76 5F    STA destination_variable
;Read the reference actor index
.C:6523  20 98 5F    JSR script_load_operand_bit7
.C:6526  85 17       STA reference_actor
;Use current_actor as actor index, start from #07 (the highest kid index), go downwards
.C:6528  A9 07       LDA #$07
.C:652a  85 19       STA current_actor
;Do the search
.C:652c  4C F5 64    JMP init_distance_search
;===========================================
; Get a new random number
; 
; Opcode #16 - get random number
;===========================================
destination_variable = $5f76
;Read destination variable
.C:652f  20 14 5E    JSR script_read_byte
.C:6532  8D 76 5F    STA destination_variable
;Read the random seed
.C:6535  20 98 5F    JSR script_load_operand_bit7
.C:6538  AA          TAX
;Get a new random number using the seed
.C:6539  20 D4 D7    JSR get_random_number
;Set the result into the variable
.C:653c  AE 76 5F    LDX destination_variable
.C:653f  9D 67 FF    STA game_vars,X
.C:6542  60          RTS
;===========================================
;Opcode #56, #D6 - get actor moving
;===========================================
destination_variable = $5f76
;Read destination variable
.C:6543  20 14 5E    JSR script_read_byte
.C:6546  8D 76 5F    STA destination_variable
;Read costume index
.C:6549  20 98 5F    JSR script_load_operand_bit7
.C:654c  AA          TAX
.C:654d  BD 57 FE    LDA actor_for_costume,X
;Is there an actor assigned?
.C:6550  10 05       BPL actor_assigned
;No actor assigned - set result as #02 (stopped)
.C:6552  A9 02       LDA #$02
.C:6554  4C 5B 65    JMP set_result
actor_assigned:
.C:6557  AA          TAX
;Set result as the motion state for this actor
.C:6558  BD 68 FD    LDA motion_state_for_actor,X
set_result:
;Set the result into the variable
.C:655b  AE 76 5F    LDX destination_variable
.C:655e  9D 67 FF    STA game_vars,X
.C:6561  60          RTS
;===========================================
; Opcode #7C, #FC - is sound running
;===========================================
destination_variable = $5f76
;Read destination variable
.C:6562  20 14 5E    JSR script_read_byte
.C:6565  8D 76 5F    STA destination_variable
;Read the sound index
.C:6568  20 98 5F    JSR script_load_operand_bit7
;Check bits 6-0 (the sound refcount) - if they are nonzero, the sound is running
.C:656b  AA          TAX
.C:656c  BD 51 79    LDA sound_memory_attrs,X
.C:656f  29 7F       AND #$7F
;Set the result into the variable
.C:6571  AE 76 5F    LDX destination_variable
.C:6574  9D 67 FF    STA game_vars,X
.C:6577  60          RTS
;===========================================
; Opcode #68, #E8 - is script running
;===========================================
destination_variable = $5f76
;Read destination variable
.C:6578  20 14 5E    JSR script_read_byte
.C:657b  8D 76 5F    STA destination_variable
;Read the script index
.C:657e  20 98 5F    JSR script_load_operand_bit7
;Use .X as script slot index, start from #0F, go downwards
.C:6581  A2 0F       LDX #$0F
check_script:
;Check if the script in the slot matches the script index
.C:6583  DD 29 71    CMP resource_index_for_script_slot,X
;If not, continue with next script
.C:6586  D0 08       BNE next_script
;It matches - set result to #01
.C:6588  BD D9 70    LDA script_state_for_script_slot,X	;Unnecessary line
.C:658b  A9 01       LDA #$01
.C:658d  4C 95 65    JMP set_result
next_script:
.C:6590  CA          DEX
.C:6591  D0 F0       BNE check_script
;No more script slots to check, set result to #00
.C:6593  A9 00       LDA #$00
set_result:
;Set the result into the variable
.C:6595  AE 76 5F    LDX destination_variable
.C:6598  9D 67 FF    STA game_vars,X
.C:659b  60          RTS
;===========================================
; Set script pause counters
;
; Opcode #2A - set script pause counters
;===========================================
;Read 3 bytes and set them as the respective bytes for the pause counters
.C:659c  AE B8 70    LDX current_script_slot
.C:659f  20 14 5E    JSR script_read_byte
.C:65a2  9D 09 71    STA script_pause_counter_3,X
.C:65a5  20 14 5E    JSR script_read_byte
.C:65a8  9D F9 70    STA script_pause_counter_2,X
.C:65ab  20 14 5E    JSR script_read_byte
.C:65ae  9D E9 70    STA script_pause_counter_1,X
;Set script state as paused (#01)
.C:65b1  A9 01       LDA #$01
.C:65b3  9D D9 70    STA script_state_for_script_slot,X
;Stop script execution
.C:65b6  4C 00 61    JMP stop_script_execution
;===========================================
; Stop a sound
;
; Opcode #3C, #BC - stop sound
;===========================================
;map_in_io
.C:65b9  A0 25       LDY #$25
.C:65bb  84 01       STY processor_port_register
;Read sound index
.C:65bd  20 98 5F    JSR script_load_operand_bit7
;Stop the sound
.C:65c0  20 93 50    JSR stop_sound
;map_out_io
.C:65c3  A0 24       LDY #$24
.C:65c5  84 01       STY processor_port_register
.C:65c7  60          RTS
;===========================================
;Opcode #02 - play music
;===========================================
sound_code_ptr_lo = $6621
sound_code_ptr_hi = $6622

;If musics 1 or 2 are loaded in memory, play them
.C:65c8  A2 01       LDX #$01
.C:65ca  BD C5 78    LDA sound_rsrc_ptrs_hi,X
.C:65cd  D0 16       BNE play_music
.C:65cf  A2 02       LDX #$02
.C:65d1  BD C5 78    LDA sound_rsrc_ptrs_hi,X
.C:65d4  D0 0F       BNE play_music
;Musics 1 and 2 are not loaded
;Convert disk side ID to side # (31, 32 -> 1, 2)
.C:65d6  AD 9C FE    LDA desired_disk_id
.C:65d9  38          SEC
.C:65da  E9 30       SBC #$30
;Load the music matching the disk side number
.C:65dc  48          PHA
.C:65dd  20 E6 39    JSR load_sound
.C:65e0  20 B4 5D    JSR handle_script_relocation
.C:65e3  68          PLA
.C:65e4  AA          TAX
play_music:
.C:65e5  8E A3 FE    STX music_index
.C:65e8  FE 51 79    INC sound_memory_attrs,X
;Load music index from operand
.C:65eb  20 98 5F    JSR script_load_operand_bit7
.C:65ee  48          PHA
.C:65ef  20 E6 39    JSR load_sound
.C:65f2  AE A3 FE    LDX music_index
.C:65f5  DE 51 79    DEC sound_memory_attrs,X
;Setup music playback pointers
.C:65f8  BD C5 78    LDA sound_rsrc_ptrs_hi,X
.C:65fb  8D A1 FE    STA <music_to_start_ptr
.C:65fe  BD 0B 79    LDA sound_rsrc_ptrs_lo,X
.C:6601  8D A2 FE    STA >music_to_start_ptr
.C:6604  20 76 4C    JSR setup_music_pointers	
;Skip header (4 bytes) and compute sound code pointer (inlined)
.C:6607  AE A3 FE    LDX music_index
.C:660a  BD 0B 79    LDA sound_rsrc_ptrs_lo,X
.C:660d  18          CLC
.C:660e  69 04       ADC #$04
.C:6610  8D 21 66    STA <inlined_music_init_code_ptr
.C:6613  BD C5 78    LDA sound_rsrc_ptrs_hi,X
.C:6616  69 00       ADC #$00
.C:6618  8D 22 66    STA >inlined_music_init_code_ptr
.C:661b  68          PLA
;map_in_io
.C:661c  A0 25       LDY #$25
.C:661e  84 01       STY processor_port_register
;Execute music startup code
inlined_music_init_code_ptr = $6621
.C:6620  20 FF FF    JSR inlined_music_init_code_ptr	;Inlined
;map_out_io
.C:6623  A0 24       LDY #$24
.C:6625  84 01       STY processor_port_register
.C:6627  20 B4 5D    JSR handle_script_relocation
.C:662a  60          RTS
;===========================================
;Opcode #1C, #5C, #9C, #DC - start sound
;===========================================
sound_index = $d0

.C:662b  20 98 5F    JSR script_load_operand_bit7
start_sound_entry2:
.C:662e  85 D0       STA sound_index
;map_in_io
.C:6630  A0 25       LDY #$25
.C:6632  84 01       STY processor_port_register
;Stop the sound, in case it was already playing
.C:6634  A5 D0       LDA sound_index
.C:6636  20 93 50    JSR stop_sound
;map_out_io
.C:6639  A0 24       LDY #$24
.C:663b  84 01       STY processor_port_register
;Load the sound
.C:663d  A5 D0       LDA sound_index
.C:663f  20 E6 39    JSR load_sound
;Start the sound
.C:6642  A5 D0       LDA sound_index
;map_in_io
.C:6644  A0 25       LDY #$25
.C:6646  84 01       STY processor_port_register
.C:6648  20 0A 4D    JSR start_sound
;map_out_io
.C:664b  A0 24       LDY #$24
.C:664d  84 01       STY processor_port_register
.C:664f  20 B4 5D    JSR handle_script_relocation
.C:6652  60          RTS
;===========================================
;Opcode #76, #F6 - walk actor to object, mode #01 (object in room)
;===========================================
.C:6653  A9 01       LDA #$01
.C:6655  D0 02       BNE common
;===========================================
;Opcode #36, #B6 - walk actor to object, mode #00 (object in inventory)
;===========================================
.C:6657  A9 00       LDA #$00
common:
;Save mode in stack
.C:6659  48          PHA
;Read character
.C:665a  20 98 5F    JSR script_load_operand_bit7
.C:665d  8D 30 FC    STA active_costume
;Read object index into .X
.C:6660  20 14 5E    JSR script_read_byte
.C:6663  AA          TAX
;Get mode from stack
.C:6664  68          PLA
;Find item (pass .A as mode argument)
.C:6665  20 05 0A    JSR get_obj_resource
;If return value is #FF (item unavailable?), exit
.C:6668  C0 FF       CPY #$FF
.C:666a  F0 06       BEQ exit
;Item is available, compute destination
.C:666c  20 75 0F    JSR set_destination_for_object
.C:666f  20 1F 1C    JSR walk_actor_to_destination
exit:
.C:6672  60          RTS
;===========================================
;Opcode #4E, #CE - put actor at object, mode #01 (object in room)
;===========================================
.C:6673  A9 01       LDA #$01
.C:6675  D0 02       BNE common
;===========================================
;Opcode #0E, #8E - put actor at object, mode #00 (object in inventory)
;===========================================
.C:6677  A9 00       LDA #$00
common:
;Save mode in stack
.C:6679  48          PHA
;Read character
.C:667a  20 98 5F    JSR script_load_operand_bit7
.C:667d  8D 30 FC    STA active_costume
;Read object index into .X
.C:6680  20 14 5E    JSR script_read_byte
.C:6683  AA          TAX
;Get mode from stack
.C:6684  68          PLA
;Check item
.C:6685  20 05 0A    JSR get_obj_resource
;If return value is #FF (item unavailable?), use the default destination
.C:6688  C0 FF       CPY #$FF
.C:668a  F0 06       BEQ default_destination
;Item is available, compute destination
.C:668c  20 75 0F    JSR set_destination_for_object
.C:668f  4C 9C 66    JMP move_actor
default_destination:
.C:6692  A9 1E       LDA #$1E
.C:6694  8D E6 FD    STA x_destination
.C:6697  A9 3C       LDA #$3C
.C:6699  8D E7 FD    STA y_destination
move_actor:
;Set room destination as current room
.C:669c  AE 30 FC    LDX active_costume
.C:669f  BD FC FE    LDA room_for_character,X
.C:66a2  8D EA FD    STA room_destination
;Move actor to destination
.C:66a5  20 9C 26    JSR put_actor_at_destination
.C:66a8  20 B4 5D    JSR handle_script_relocation
.C:66ab  60          RTS
;===========================================
;Opcode #15, #55, #95, #D5 - walk actor to actor
;===========================================
;Read character index
.C:66ac  20 98 5F    JSR script_load_operand_bit7
.C:66af  8D 30 FC    STA active_costume
.C:66b2  A8          TAY
.C:66b3  B9 57 FE    LDA actor_for_costume,Y
;Is the actor assigned?
.C:66b6  10 04       BPL actor_assigned
;If not, there's nothing to do - skip 2 bytes and return
.C:66b8  20 11 5E    JSR script_skip_offset
.C:66bb  60          RTS
actor_assigned:
;Read the other actor index
.C:66bc  20 90 5F    JSR script_load_operand_bit6
.C:66bf  AA          TAX
;Is this other actor assigned?
.C:66c0  BD 57 FE    LDA actor_for_costume,X
.C:66c3  10 04       BPL both_actors_assigned
;If not, there's nothing to do - skip 1 byte and return
.C:66c5  20 14 5E    JSR script_read_byte
.C:66c8  60          RTS
both_actors_assigned:
;Read destination walking offset
.C:66c9  20 14 5E    JSR script_read_byte
;Save positive walking offset
.C:66cc  8D 65 0F    STA inlined_positive_walking_offset
;Convert walking offset to negative and save it as well
.C:66cf  49 FF       EOR #$FF
.C:66d1  18          CLC
.C:66d2  69 01       ADC #$01
.C:66d4  8D 6A 0F    STA inlined_negative_walking_offset
;Set destination for actor
.C:66d7  20 46 0F    JSR set_destination_for_actor
;Walk actor to destination
.C:66da  20 1F 1C    JSR walk_actor_to_destination
.C:66dd  60          RTS
;===========================================
;Opcode #1E, #3E, #5E, #7E, #9E, #BE, #DE, #FE - walk actor to location
;===========================================
;Read costume index
.C:66de  20 98 5F    JSR script_load_operand_bit7
.C:66e1  8D 30 FC    STA active_costume
;Read X destination
.C:66e4  20 90 5F    JSR script_load_operand_bit6
.C:66e7  8D E6 FD    STA x_destination
;Read Y destination
.C:66ea  20 88 5F    JSR script_load_operand_bit5
.C:66ed  8D E7 FD    STA y_destination
;Walk actor to destination
.C:66f0  20 1F 1C    JSR walk_actor_to_destination
.C:66f3  60          RTS
;===========================================
;Opcode #01, #21, #41, #61, #81, #A1, #C1, #E1 - put actor at location
;===========================================
;Read character index
.C:66f4  20 98 5F    JSR script_load_operand_bit7
.C:66f7  8D 30 FC    STA active_costume
;Read X destination
.C:66fa  20 90 5F    JSR script_load_operand_bit6
.C:66fd  8D E6 FD    STA x_destination
;Read Y destination
.C:6700  20 88 5F    JSR script_load_operand_bit5
.C:6703  8D E7 FD    STA y_destination
;Set room destination as current room
.C:6706  AE 30 FC    LDX active_costume
.C:6709  BD FC FE    LDA room_for_character,X
.C:670c  8D EA FD    STA room_destination
;Move actor to destination
.C:670f  20 9C 26    JSR put_actor_at_destination
.C:6712  20 B4 5D    JSR handle_script_relocation
.C:6715  60          RTS
;===========================================
;Opcode #2D, #6D, #AD, #ED - put actor in room
;===========================================
character = $d0
;Read character index
.C:6716  20 98 5F    JSR script_load_operand_bit7
.C:6719  85 D0       STA character
;Read room
.C:671b  20 90 5F    JSR script_load_operand_bit6
;Put character in room
.C:671e  A6 D0       LDX character
.C:6720  9D FC FE    STA room_for_character,X
.C:6723  60          RTS
;===========================================
;Opcode #03, #43, #83, #C3 - do sentence
;===========================================
low_byte = $d0
hi_byte = $d1
input_opcode = $d2

;Move to the next queue index
.C:6724  EE 17 FE    INC sentence_queue_index
;Use .Y as queue index
.C:6727  AC 17 FE    LDY sentence_queue_index
;Read the verb from the script and store it in the current sentence queue
.C:672a  20 14 5E    JSR script_read_byte
.C:672d  99 25 FE    STA queued_sentence_verbs,Y
;Setup the opcode for the script object helper
.C:6730  AD 8C FE    LDA opcode
.C:6733  85 D2       STA input_opcode
;Get the object index into low_byte/hi_byte (based on the opcode and next script byte)
.C:6735  20 85 60    JSR get_script_object_for_sentence
;Store object index as direct object for the sentence
.C:6738  A5 D0       LDA low_byte
.C:673a  99 2B FE    STA queued_sentence_direct_objects_lo,Y
.C:673d  A5 D1       LDA hi_byte
.C:673f  99 31 FE    STA queued_sentence_direct_objects_hi,Y
.C:6742  06 D2       ASL input_opcode
;Get the object index into low_byte/hi_byte (based on the opcode and next script byte)
.C:6744  20 85 60    JSR get_script_object_for_sentence
;Store object index as indirect object for the sentence 
.C:6747  A5 D0       LDA low_byte
.C:6749  99 3D FE    STA queued_sentence_indirect_objects_lo,Y
;Store something in the preposition as well to allow the sentence evaluator to consider it complete
.C:674c  99 37 FE    STA queued_sentence_prepositions,Y
.C:674f  A5 D1       LDA hi_byte
.C:6751  99 43 FE    STA queued_sentence_indirect_objects_hi,Y
.C:6754  60          RTS
;===========================================
; Freeze all noncurrent scripts 
;===========================================
freeze_noncurrent_scripts:
;Use .X as script slot counter, start at #0F, go downwards
.C:6755  A2 0F       LDX #$0F
check_script_state:
;Skip if the script is the current one
.C:6757  EC B8 70    CPX current_script_slot
.C:675a  F0 0C       BEQ next_script
; If the script slot is free (state == #00), do nothing
.C:675c  BD D9 70    LDA script_state_for_script_slot,X
.C:675f  C9 00       CMP #$00
.C:6761  F0 05       BEQ next_script
; Script's state is paused or running, so set bit 7 to freeze the script
.C:6763  09 80       ORA #$80
.C:6765  9D D9 70    STA script_state_for_script_slot,X
next_script:
.C:6768  CA          DEX
.C:6769  D0 EC       BNE check_script_state
.C:676b  60          RTS
;===========================================
; Unfreeze all scripts 
;===========================================
unfreeze_all_scripts:
;Use .X as script slot counter, start at #0F, go downwards
.C:676c  A2 0F       LDX #$0F
unfreeze_script:
;Clear bit 7 of the script
.C:676e  BD D9 70    LDA script_state_for_script_slot,X
.C:6771  29 7F       AND #$7F
.C:6773  9D D9 70    STA script_state_for_script_slot,X
.C:6776  CA          DEX
.C:6777  D0 F5       BNE unfreeze_script
.C:6779  60          RTS
;===========================================
;Opcode #40 - run cutscene
;===========================================
;Save current control mode to restore it later
.C:677a  AD A8 FE    LDA control_mode
.C:677d  8D A9 FE    STA saved_control_mode
;Save current room
.C:6780  AD 49 71    LDA current_room
.C:6783  8D AA FE    STA saved_room
;Freeze other scripts
.C:6786  20 55 67    JSR freeze_noncurrent_scripts	
;Setup cutscene mode and clear sentence bar
.C:6789  20 90 68    JSR setup_cutscene
;Save sentence parts
.C:678c  A2 05       LDX #$05
save_sentence_part:
.C:678e  BD 1F FE    LDA sentence_parts,X
.C:6791  9D 43 FE    STA queued_sentence_indirect_objects_hi,X
.C:6794  CA          DEX
.C:6795  10 F7       BPL save_sentence_part
;Reset the sentence queue
.C:6797  20 CC 29    JSR reset_sentence_queue_system
;???
.C:679a  A9 00       LDA #$00
.C:679c  8D 8E FE    STA click_trigger_sentence
;Save current script
.C:679f  AD B8 70    LDA current_script_slot
.C:67a2  8D A6 FE    STA saved_script_index
;Reset script offsets
.C:67a5  A9 00       LDA #$00
.C:67a7  8D A4 FE    STA interrupted_script_offset_lo
.C:67aa  A9 00       LDA #$00
.C:67ac  8D A5 FE    STA interrupted_script_offset_hi
.C:67af  60          RTS
;===========================================
;Opcode #C0 - return from cutscene
;===========================================
.C:67b0  A9 00       LDA #$00
.C:67b2  8D 6D FF    STA var_destination_x
.C:67b5  A9 00       LDA #$00
.C:67b7  8D A6 FE    STA saved_script_index
.C:67ba  A9 00       LDA #$00
.C:67bc  8D A7 FE    STA interrupted_script_index
.C:67bf  A9 00       LDA #$00
.C:67c1  8D A4 FE    STA interrupted_script_offset_lo
.C:67c4  A9 00       LDA #$00
.C:67c6  8D A5 FE    STA interrupted_script_offset_hi
;Check if we were in control mode #01 (keypad mode)
.C:67c9  AD A9 FE    LDA saved_control_mode
.C:67cc  C9 01       CMP #$01
.C:67ce  D0 12       BNE other_control_modes
;----------------------------------
;Control mode #01 (keypad)
;----------------------------------
;Restore saved control mode
.C:67d0  8D A8 FE    STA control_mode
;Reload saved_room
.C:67d3  20 9D D6    JSR prepare_video_for_new_room
.C:67d6  AE AA FE    LDX saved_room
.C:67d9  20 66 34    JSR load_room
;Unfreeze all scripts
.C:67dc  20 6C 67    JSR unfreeze_all_scripts
.C:67df  4C 00 68    JMP exit
;----------------------------------
other_control_modes:
;Save the control mode in the stack
.C:67e2  48          PHA
;Unfreeze all scripts
.C:67e3  20 6C 67    JSR unfreeze_all_scripts
;Fix camera on the current kid
.C:67e6  AD 67 FF    LDA current_kid
.C:67e9  20 1C 68    JSR fix_camera_on_actor_2
;Restore sentence parts
.C:67ec  A2 05       LDX #$05
restore_sentence_part:
.C:67ee  BD 43 FE    LDA queued_sentence_indirect_objects_hi,X
.C:67f1  9D 1F FE    STA sentence_parts,X
.C:67f4  CA          DEX
.C:67f5  10 F7       BPL restore_sentence_part
;Restore the control mode from the stack
.C:67f7  68          PLA
;Set the old mode
.C:67f8  20 8C 68    JSR set_control_mode
;Enable rendering the sentence bar
.C:67fb  A9 01       LDA #$01
.C:67fd  8D 49 FE    STA refresh_sentence_bar_flag
exit:
.C:6800  60          RTS
;===========================================
;Opcode #32, #B2 - set camera at position
;===========================================
;Set camera mode to #03 (pan to position)
.C:6801  A9 03       LDA #$03
.C:6803  8D 6A 06    STA camera_mode
;Read camera position
.C:6806  20 98 5F    JSR script_load_operand_bit7
;Set camera position
.C:6809  20 66 68    JSR set_camera_at
.C:680c  60          RTS
;===========================================
;Opcode #12, #92 - pan camera to position
;===========================================
;Set camera mode to #03 (pan to position)
.C:680d  A9 03       LDA #$03
.C:680f  8D 6A 06    STA camera_mode
;Read camera destination
.C:6812  20 98 5F    JSR script_load_operand_bit7
;Set pan destination
.C:6815  8D 6C 06    STA pan_camera_to
.C:6818  60          RTS
;===========================================
;Opcode #52, #D2 - fix camera on actor
;===========================================
;Read actor
.C:6819  20 98 5F    JSR script_load_operand_bit7
fix_camera_on_actor_2:
;Fix camera on actor
.C:681c  20 23 68    JSR fix_camera_on_actor
.C:681f  20 B4 5D    JSR handle_script_relocation
.C:6822  60          RTS
;===========================================
; Fix camera on an actor
;
; Arguments:	.A		actor to follow
;===========================================
fix_camera_on_actor:
;Save the actor to follow
.C:6823  8D 6B 06    STA camera_costume_to_follow
;Set camera mode to #02 (follow actor)
.C:6826  A9 02       LDA #$02
.C:6828  8D 6A 06    STA camera_mode
;Fetch the room for the actor
.C:682b  AE 6B 06    LDX camera_costume_to_follow
.C:682e  BD FC FE    LDA room_for_character,X
;Is it the current room?
.C:6831  CD 49 71    CMP current_room
.C:6834  D0 03       BNE not_in_current_room
.C:6836  4C 42 68    JMP in_current_room
not_in_current_room:
;Load the room
.C:6839  48          PHA
.C:683a  20 9D D6    JSR prepare_video_for_new_room
.C:683d  68          PLA
.C:683e  AA          TAX
.C:683f  20 66 34    JSR load_room
in_current_room:
;Fetch the X position of the actor to follow
.C:6842  AE 6B 06    LDX camera_costume_to_follow
.C:6845  BC 57 FE    LDY actor_for_costume,X
.C:6848  B9 41 FD    LDA position_x_for_actor,Y
;Set camera at that position
.C:684b  20 66 68    JSR set_camera_at
;Set default camera position
.C:684e  A9 C8       LDA #$C8
.C:6850  8D 67 06    STA camera_current_position
;Set all actors animation states bit 0
.C:6853  A2 03       LDX #$03
set_actor_animation_state:
.C:6855  BD 53 FE    LDA costume_for_actor,X
.C:6858  30 08       BMI next_actor
;Refresh animation
.C:685a  BD 97 FD    LDA animation_state_for_actor,X
.C:685d  09 01       ORA #$01
.C:685f  9D 97 FD    STA animation_state_for_actor,X
next_actor:
.C:6862  CA          DEX
.C:6863  10 F0       BPL set_actor_animation_state
.C:6865  60          RTS
;===========================================
; Set camera at position
;
; Arguments:	.A desired position
;===========================================
set_camera_at:
desired_destination = $d0
;Save desired position
.C:6866  85 D0       STA desired_destination
;Check the distance between the desired and the current position
.C:6868  A5 D0       LDA desired_destination
.C:686a  38          SEC
.C:686b  ED 66 06    SBC camera_desired_position
;If result is negative, make it positive (take the modulus)
.C:686e  B0 05       BCS check_threshold
.C:6870  49 FF       EOR #$FF
.C:6872  18          CLC
.C:6873  69 01       ADC #$01
;Is it within the threshold? If so, pan. Otherwise, move instantly.
check_threshold:
.C:6875  C9 14       CMP #$14
.C:6877  90 0A       BCC pan
.C:6879  F0 08       BEQ pan
move_instantly:
.C:687b  A5 D0       LDA desired_destination
;Set the camera position
.C:687d  8D 66 06    STA camera_desired_position
;Set the pan destination as well (to avoid panning to somewhere else)
.C:6880  8D 6C 06    STA pan_camera_to
;The following code could have been removed and the "pan" jump adjusted accordingly
pan:
.C:6883  A5 D0       LDA desired_destination
;Set the pan destination 
.C:6885  8D 6C 06    STA pan_camera_to
.C:6888  60          RTS
;===========================================
; Opcode #60, #E0
;
; Change control mode and update screen regions accordingly
; 
; Operand:	#00		clear sentence bar, set control mode to cutscene
;			#01		clear sentence bar, set control mode to keypad,
;					set bit 7 of all script states
;			#02		like #03 but set control mode to #02 (disable kid change)
;			#03		set mode to cutscene, redraw all interaction regions, 
;					clear bit 7 of all script states, set mode to normal
;===========================================
;Read control mode
.C:6889  20 98 5F    JSR script_load_operand_bit7
;Entry point for callers that already set the control mode into .A
set_control_mode:
;Switch on operand
.C:688c  C9 00       CMP #$00
.C:688e  D0 20       BNE check_03
;----------------------------
;Case #00 - clear sentence bar, set mode to cutscene
;Entry point as subroutine from opcode #40 (run cutscene)
;----------------------------
case_00:
setup_cutscene:
;Clear sentence bar
.C:6890  A9 00       LDA #$00
.C:6892  8D 49 FE    STA refresh_sentence_bar_flag
.C:6895  A9 D0       LDA <SENTENCE_BAR_BASE
.C:6897  85 19       STA $19
.C:6899  A9 CE       LDA >SENTENCE_BAR_BASE
.C:689b  85 1A       STA $1A
.C:689d  A9 18       LDA #$18
.C:689f  85 1B       STA $1B
.C:68a1  A9 01       LDA #$01
.C:68a3  85 1C       STA $1C
.C:68a5  A2 20       LDX #$20
.C:68a7  20 32 5D    JSR fill_memory_with_value_2
;Set control mode to #00 (cutscene)
.C:68aa  A9 00       LDA #$00
.C:68ac  8D A8 FE    STA control_mode
.C:68af  60          RTS
;----------------------------
check_03:
.C:68b0  C9 03       CMP #$03
.C:68b2  D0 19       BNE check_02
;----------------------------
;Case #03	set mode to cutscene, redraw all interaction regions, 
;			set mode to normal, unfreeze all scripts
;----------------------------
case_03:
;Set control mode to #00 (cutscene)
.C:68b4  A9 00       LDA #$00
.C:68b6  8D A8 FE    STA control_mode
;map_in_io
.C:68b9  A0 25       LDY #$25
.C:68bb  84 01       STY processor_port_register
;Redraw all interaction regions
.C:68bd  20 8C F3    JSR draw_all_regions
;map_out_io
.C:68c0  A0 24       LDY #$24
.C:68c2  84 01       STY processor_port_register
;Set control mode to #03 (normal)
.C:68c4  A9 03       LDA #$03
.C:68c6  8D A8 FE    STA control_mode
;Unfreeze all scripts
.C:68c9  20 6C 67    JSR unfreeze_all_scripts
.C:68cc  60          RTS
;----------------------------
check_02:
.C:68cd  C9 02       CMP #$02
.C:68cf  D0 09       BNE check_01
;----------------------------
;Case #02 - invoke case #03 first, then switch to mode #02
;----------------------------
.C:68d1  20 B4 68    JSR case_03
;Set control mode to #02 (normal play but disable kid change)
.C:68d4  A9 02       LDA #$02
.C:68d6  8D A8 FE    STA control_mode
.C:68d9  60          RTS
check_01:
.C:68da  C9 01       CMP #$01
.C:68dc  D0 0C       BNE default
;----------------------------
;Case #01 - invoke case #00 first, then switch to mode #01
;----------------------------
.C:68de  20 90 68    JSR case_00
;Set control mode to "keypad"
.C:68e1  A9 01       LDA #$01
.C:68e3  8D A8 FE    STA control_mode
;Freeze all noncurrent running scripts
.C:68e6  20 55 67    JSR freeze_noncurrent_scripts
.C:68e9  60          RTS
default:
.C:68ea  60          RTS
;===========================================
;Opcode #07, #87 - get actor room
;===========================================
destination_variable = $d0
;Read destination variable
.C:68eb  20 14 5E    JSR script_read_byte
.C:68ee  85 D0       STA destination_variable
;Read actor index
.C:68f0  20 98 5F    JSR script_load_operand_bit7
.C:68f3  AA          TAX
;Fetch room for actor
.C:68f4  BD FC FE    LDA room_for_character,X
;Set result in variable
.C:68f7  A6 D0       LDX destination_variable
.C:68f9  9D 67 FF    STA game_vars,X
.C:68fc  60          RTS
;===========================================
;Opcode #47, #C7 - get actor/object X
;===========================================
destination_variable = $d0
;Read destination variable
.C:68fd  20 14 5E    JSR script_read_byte
.C:6900  85 D0       STA destination_variable
;Read actor index
.C:6902  20 98 5F    JSR script_load_operand_bit7
.C:6905  AA          TAX
;Is the actor moving?
.C:6906  BD 57 FE    LDA actor_for_costume,X
.C:6909  30 07       BMI actor_moving
;Actor not moving, fetch its position
.C:690b  AA          TAX
.C:690c  BD 41 FD    LDA position_x_for_actor,X
.C:690f  4C 15 69    JMP set_value_in_var
actor_moving:
;Get the actor destination
.C:6912  BD 2E FF    LDA costume_x_destination,X
set_value_in_var:
;Set result in variable
.C:6915  A6 D0       LDX destination_variable
.C:6917  9D 67 FF    STA game_vars,X
.C:691a  60          RTS
;===========================================
;Opcode #27, #A7 - get actor/object Y
;===========================================
destination_variable = $d0
;Read destination variable
.C:691b  20 14 5E    JSR script_read_byte
.C:691e  85 D0       STA destination_variable
;Read actor index
.C:6920  20 98 5F    JSR script_load_operand_bit7
.C:6923  AA          TAX
;Is the actor moving?
.C:6924  BD 57 FE    LDA actor_for_costume,X
.C:6927  30 07       BMI actor_moving
;Actor not moving, fetch its position
.C:6929  AA          TAX
.C:692a  BD 3D FD    LDA position_y_for_actor,X
.C:692d  4C 33 69    JMP set_value_in_var
actor_moving:
;Get the actor destination
.C:6930  BD 15 FF    LDA costume_y_destination,X
set_value_in_var:
;Set result in variable
.C:6933  A6 D0       LDX destination_variable
.C:6935  9D 67 FF    STA game_vars,X
.C:6938  60          RTS
;===========================================
;Opcode #67, #E7 - get animation set for actor
;===========================================
destination_variable = $d0
;Read destination variable
.C:6939  20 14 5E    JSR script_read_byte
.C:693c  85 D0       STA destination_variable
;Read actor index
.C:693e  20 98 5F    JSR script_load_operand_bit7
.C:6941  AA          TAX
;Is the actor moving?
.C:6942  BD 57 FE    LDA actor_for_costume,X
.C:6945  30 0A       BMI actor_moving
;Actor not moving, compute facing side
.C:6947  AA          TAX
.C:6948  BD EB FD    LDA path_direction_for_actor,X
.C:694b  20 DF 3B    JSR convert_actor_direction_to_animation_set
.C:694e  4C 54 69    JMP set_value_in_var
actor_moving:
;Get the animation set for this costume
.C:6951  BD 47 FF    LDA animation_set_for_costume,X
set_value_in_var:
;Set result in variable
.C:6954  A6 D0       LDX destination_variable
.C:6956  9D 67 FF    STA game_vars,X
.C:6959  60          RTS
;===========================================
;Opcode #11, #51, #91, #D1 - animate actor
;
; Reads a new animation set and argument for a costume,
; and updates things accordingly.
;
; Byte 0 - costume index
; Byte 1 - animation set value
; Byte 2 - animation argument
;
; Animation set values of #FF, #FE or #FD are special.
; They are not used as the costume's animation sets.
;
; 	#FD		keep actor's mouth closed
; 	#FE		keep actor's mouth open
;	#FF		reset actor's animation state
;===========================================
animation_argument = $fde8
;Read costume index
.C:695a  20 98 5F    JSR script_load_operand_bit7
.C:695d  8D 30 FC    STA active_costume
;Read animation set 
.C:6960  20 90 5F    JSR script_load_operand_bit6
.C:6963  8D E9 FD    STA desired_animation_set
;Read animation argument (whether the animation loops or not)
.C:6966  20 14 5E    JSR script_read_byte
.C:6969  8D E8 FD    STA animation_argument
;-----------------------------------
;Switch based on animation_set
.C:696c  AD E9 FD    LDA desired_animation_set
.C:696f  C9 FE       CMP #$FE
.C:6971  D0 0E       BNE check_fd
;---------------------------------------
;Case #FE - keep actor's mouth open
;---------------------------------------
.C:6973  AE 30 FC    LDX active_costume
.C:6976  BC 57 FE    LDY actor_for_costume,X
.C:6979  30 05       BMI exit_1
;Set actor's mouth state to #80 (open and still)
.C:697b  A9 80       LDA #$80
.C:697d  99 9D FE    STA mouth_state_for_actor,Y
exit_1:
.C:6980  60          RTS
;---------------------------------------
check_fd:
.C:6981  C9 FD       CMP #$FD
.C:6983  D0 0E       BNE check_ff
;---------------------------------------
;Case #FD - keep actor's mouth closed
;---------------------------------------
.C:6985  AE 30 FC    LDX active_costume
.C:6988  BC 57 FE    LDY actor_for_costume,X
.C:698b  30 05       BMI exit_2
;Set actor's mouth state to #00 (closed)
.C:698d  A9 00       LDA #$00
.C:698f  99 9D FE    STA mouth_state_for_actor,Y
exit_2:
.C:6992  60          RTS
;---------------------------------------
check_ff:
.C:6993  C9 FF       CMP #$FF
.C:6995  D0 10       BNE default
;---------------------------------------
;Case #FF - reset animation
;---------------------------------------
.C:6997  AE 30 FC    LDX active_costume
.C:699a  BD 57 FE    LDA actor_for_costume,X
.C:699d  30 05       BMI exit_3
.C:699f  85 D8       STA actor
.C:69a1  20 23 2C    JSR reset_actor_animation_state
exit_3:
.C:69a4  4C AA 69    JMP exit
;---------------------------------------
; Default - use the animation set
;---------------------------------------
default:
.C:69a7  20 20 27    JSR apply_animation_set
exit:
.C:69aa  60          RTS
;===========================================
;Opcode #70, #F0 - lights
;
; Lights_status values
; #00	environment lights off, flashlights off
; #01	environment lights off, flashlight on
; #02	environment lights on
;===========================================
;Read lights status operand
.C:69ab  20 98 5F    JSR script_load_operand_bit7
.C:69ae  8D AB FE    STA lights_status
;map_in_io
.C:69b1  A0 25       LDY #$25
.C:69b3  84 01       STY processor_port_register
;Are environment lights on? (status = #02?)
.C:69b5  AD AB FE    LDA lights_status
.C:69b8  C9 02       CMP #$02
.C:69ba  F0 0A       BEQ environment_lights_on
;-----------------------------------
; Environment lights off
; Clear scene area
.C:69bc  20 4B 5F    JSR clear_scene_area
; Use #00 and #0B as colors (black and light gray)
.C:69bf  A0 00       LDY #$00
.C:69c1  A2 0B       LDX #$0B
.C:69c3  4C CA 69    JMP set_colors
;-----------------------------------
;Case #02 - use #00 and #0A as colors (black and light red/skin tone)
environment_lights_on:
.C:69c6  A2 00       LDX #$00
.C:69c8  A0 0A       LDY #$0A
;-----------------------------------
set_colors:
;Set the sprite multicolors
;These correspond to the bit pairs "11" and "01" respectively (mcolor1 and mcolor0)
.C:69ca  8C 25 D0    STY vic_sprite_mcolor0_reg
.C:69cd  8E 26 D0    STX vic_sprite_mcolor1_reg
;map_out_io
.C:69d0  A0 24       LDY #$24
.C:69d2  84 01       STY processor_port_register
;Set default camera position
.C:69d4  A9 C8       LDA #$C8
.C:69d6  8D 67 06    STA camera_current_position
.C:69d9  60          RTS
;===========================================
;Opcode #54, #D4 - set object name
;
; Used for changing an object's name.
; For instance, an empty jar getting filled with water would change its name from
; "glass jar" to "jar of water".
;===========================================
object_name_pointer = $15

;Read the object index
.C:69da  20 14 5E    JSR script_read_byte
;If it's nonzero, save it as the object index
.C:69dd  C9 00       CMP #$00
.C:69df  D0 03       BNE set_operand_to_x
;If operand is #00, use the active object instead
.C:69e1  AD 1A FE    LDA active_object_lo
set_operand_to_x:
.C:69e4  AA          TAX
;Check object location to search (room or inventory), based on opcode
.C:69e5  AD 8C FE    LDA opcode
.C:69e8  10 05       BPL set_location_to_inventory
set_location_to_room:
.C:69ea  A9 01       LDA #$01
.C:69ec  4C F1 69    JMP get_obj_name
set_location_to_inventory:
.C:69ef  A9 00       LDA #$00
get_obj_name:
;Get the object name pointer
.C:69f1  20 E3 09    JSR get_object_name_pointer
;Use .Y as copy index, start at #FF (incremented to #00 in the first iteration), go upwards
.C:69f4  A0 FF       LDY #$FF
;Copy the new object's name - it's a zero-terminated string
;Read from the script data, write into the object name pointer
copy_object_name:
.C:69f6  C8          INY
.C:69f7  20 14 5E    JSR script_read_byte
.C:69fa  91 15       STA (object_name_pointer),Y
;Did we find the termination character? (#00)
.C:69fc  C9 00       CMP #$00
;If not, keep copying
.C:69fe  D0 F6       BNE copy_object_name
;Refresh items displayed in inventory
.C:6a00  20 2B 5F    JSR refresh_items_displayed
.C:6a03  60          RTS
;===========================================
;Opcode #22, #A2 - save/load game
;===========================================
destination_variable = $d0

.C:6a04  20 E0 33    JSR init_sprites_sound
;Side 0? Save game disk?
.C:6a07  A9 30       LDA #$30
.C:6a09  8D 9C FE    STA desired_disk_id
;Read variable index
.C:6a0c  20 14 5E    JSR script_read_byte
.C:6a0f  85 D0       STA destination_variable
;Read operand for operation (load or save)
.C:6a11  20 98 5F    JSR script_load_operand_bit7
.C:6a14  C9 01       CMP #$01
.C:6a16  D0 06       BNE save_state
; Operand is #00 - load state
.C:6a18  20 A5 5C    JSR load_state_from_disk
.C:6a1b  4C 21 6A    JMP set_variable
; Operand is #01 - save state
save_state:
.C:6a1e  20 3B 5C    JSR save_state_to_disk
;Set .A into the desired variable
set_variable:
.C:6a21  A6 D0       LDX destination_variable
.C:6a23  9D 67 FF    STA game_vars,X
.C:6a26  20 B4 5D    JSR handle_script_relocation
.C:6a29  20 1C 34    JSR raster_setup
.C:6a2c  60          RTS
;===========================================
;Opcode #30, #B0 - load costume
;===========================================
;Read costume index into .X
.C:6a2d  20 98 5F    JSR script_load_operand_bit7
.C:6a30  AA          TAX
;Load costume
.C:6a31  20 A8 38    JSR load_costume
.C:6a34  20 B4 5D    JSR handle_script_relocation
.C:6a37  60          RTS
;===========================================
;Operand #4A, #CA - load room - intended to load a room resource into memory just to further get subresources from it
; Not intended to be used to load a room the player has just entered
;===========================================
;Read room index into .X
.C:6a38  20 98 5F    JSR script_load_operand_bit7
.C:6a3b  AA          TAX
;Load room resource
.C:6a3c  20 33 38    JSR load_room_resource
.C:6a3f  20 B4 5D    JSR handle_script_relocation
.C:6a42  60          RTS
;===========================================
; Load script
;Opcode #4C (immediate), #CC (variable)
;===========================================
;Read script index into .X
.C:6a43  20 98 5F    JSR script_load_operand_bit7
;Load script resource
.C:6a46  20 29 3A    JSR load_script
.C:6a49  20 B4 5D    JSR handle_script_relocation
.C:6a4c  60          RTS
;===========================================
;Opcode #0C - load sound
;===========================================
;Read sound index into .X
.C:6a4d  20 98 5F    JSR script_load_operand_bit7
;Load sound
.C:6a50  20 E6 39    JSR load_sound
.C:6a53  20 B4 5D    JSR handle_script_relocation
.C:6a56  60          RTS
;===========================================
;Opcode #20 - stop music
;===========================================
.C:6a57  20 AA 4C    JSR stop_music
.C:6a5a  60          RTS
;===========================================
;Opcode #53 - lock sound
; Sets bit 7 of the resource attribute
;===========================================
.C:6a5b  20 14 5E    JSR script_read_byte
.C:6a5e  AA          TAX
.C:6a5f  BD 51 79    LDA sound_memory_attrs,X		
.C:6a62  09 80       ORA #$80
.C:6a64  9D 51 79    STA sound_memory_attrs,X
.C:6a67  60          RTS
;===========================================
;Opcode #D3 - unlock sound
;Clears bit 7 of the resource attribute
;===========================================
.C:6a68  20 14 5E    JSR script_read_byte
.C:6a6b  AA          TAX
.C:6a6c  BD 51 79    LDA sound_memory_attrs,X		
.C:6a6f  29 7F       AND #$7F
.C:6a71  9D 51 79    STA sound_memory_attrs,X
.C:6a74  60          RTS
;===========================================
;Opcode #33 - lock script
;===========================================
.C:6a75  20 14 5E    JSR script_read_byte
.C:6a78  AA          TAX
.C:6a79  BD D7 7A    LDA script_memory_attrs,X
.C:6a7c  09 80       ORA #$80
.C:6a7e  9D D7 7A    STA script_memory_attrs,X
.C:6a81  60          RTS
;===========================================
;Opcode #B3 - unlock script
;===========================================
.C:6a82  20 14 5E    JSR script_read_byte
.C:6a85  AA          TAX
.C:6a86  BD D7 7A    LDA script_memory_attrs,X
.C:6a89  29 7F       AND #$7F
.C:6a8b  9D D7 7A    STA script_memory_attrs,X
.C:6a8e  60          RTS
;===========================================
;Opcode #13 - lock costume
;===========================================
.C:6a8f  20 14 5E    JSR script_read_byte
.C:6a92  AA          TAX
.C:6a93  BD A3 77    LDA costume_memory_attrs,X
.C:6a96  09 80       ORA #$80
.C:6a98  9D A3 77    STA costume_memory_attrs,X
.C:6a9b  60          RTS
;===========================================
;Opcode #93 - unlock costume
;===========================================
.C:6a9c  20 14 5E    JSR script_read_byte
.C:6a9f  AA          TAX
.C:6aa0  BD A3 77    LDA costume_memory_attrs,X
.C:6aa3  29 7F       AND #$7F
.C:6aa5  9D A3 77    STA costume_memory_attrs,X
.C:6aa8  60          RTS
;===========================================
;Opcode #4D - lock room
;===========================================
.C:6aa9  20 14 5E    JSR script_read_byte
.C:6aac  AA          TAX
.C:6aad  BD BC 77    LDA room_memory_attrs,X
.C:6ab0  09 80       ORA #$80
.C:6ab2  9D BC 77    STA room_memory_attrs,X
.C:6ab5  60          RTS
;===========================================
;Opcode #CD - unlock room
;===========================================
.C:6ab6  20 14 5E    JSR script_read_byte
.C:6ab9  AA          TAX
.C:6aba  BD BC 77    LDA room_memory_attrs,X
.C:6abd  29 7F       AND #$7F
.C:6abf  9D BC 77    STA room_memory_attrs,X
.C:6ac2  60          RTS
;===========================================
;Opcode #98 - restart game
;===========================================
restart_game:
;Load room #00 (kid select)
.C:6ac3  20 9D D6    JSR prepare_video_for_new_room
.C:6ac6  A2 00       LDX #$00
.C:6ac8  20 66 34    JSR load_room
;Reset stack pointer
.C:6acb  A2 FF       LDX #$FF
.C:6acd  9A          TXS
;Restart game state
.C:6ace  4C 13 04    JMP reset_game_engine
;===========================================
;Opcode #6E - setup sprites and sound
;===========================================
.C:6ad1  20 E0 33    JSR init_sprites_sound
.C:6ad4  60          RTS
;===========================================
;Opcode #EE - setup raster interrupts
;===========================================
.C:6ad5  20 1C 34    JSR raster_setup
.C:6ad8  60          RTS
;===========================================
;Opcode #05, #09, #0A, #19, #23, #2C, #34, #39, #3B
; 		#45, #49, #59, #63, #65, #6A, #6C, #79, #7A
;		#7B, #80, #82, #85, #89, #8A, #8D, #96, #99
;		#A3, #A6, #AA, #AC, #B5, #B9, #BB, #C5, #C9
;		#D8, #D9, #E3, #E6, #EA, #EC, #F5, #F9, #FA
;		#FB
;
;	Stop current script
;===========================================
.C:6ad9  A2 00       LDX #$00
.C:6adb  4C AF 61    JMP stop_script_index_check
;===========================================

;(loaded on init from track 0 sector 1)
>C:7300  00 0f 0f 0f  0f 0f 0f 0f  0f 0f 0f 0f  0f 2f 0f 0f   ............./..
>C:7310  0f 0f 0f 0f  0f 4f 0f 0f  af af 2f 0f  2f 4f af af   .....O...././O..
>C:7320  af af 0f 0f  0f 0f 0f 0f  0f 0f 0f af  af 0f 8f 8f   ................
>C:7330  af 0f 0f 2f  0f 0f 2f 2f  8f 0f 0f 0f  0f 0f 0f 0f   .../..//........
>C:7340  0f 0f 0f 0f  0f 0f 0f 0f  0f 0f 8f 0f  0f 0f 0f 0f   ................
>C:7350  0f 0f 0f 8f  8f 8f 8f 0f  0f 0f 0f 0f  0f 4f 0f 0f   .............O..
>C:7360  0f 0f 0f 8f  0f 0f 0f 0f  4f 4f 0f 0f  0f 0f 0f 0f   ........OO......
>C:7370  8f 8f 8f 8f  8f 8f 8f 0f  0f 0f 0f 4f  0f 0f 0f 4f   ...........O...O
>C:7380  4f 0f 0f 4f  0f 0f 0f 0f  0f 0f 0f 0f  2f 0f 0f 0f   O..O......../...
>C:7390  0f 0f af 0f  0f 0f 0f 0f  0f 0f 0f 0f  0f 0f 0f 0f 

;52 rooms in total
;32 means disk side 2, 31 means disk side 1
disk_side_for_room:
>C:7401  
00 32 32 32 32 32 32 32 32 32 
32 32 32 32 32 32 31 32 32 32 
32 32 32 32 32 32 32 32 32 32 
31 32 31 31 32 32 32 32 32 32 
31 31 31 32 32 31 31 31 31 31 
32 31 31 00

;Track and sector for each room
;Given a room index, multiply by 2 to get the offset in the table
;The first byte pointed will be the track, the second one the sector
disk_track_sector_for_room:
>C:7438  
00 00 01 01 01 0f 06 03 10 06 
02 04 08 0e 04 09 11 05 08 19 
0d 02 0f 0f 0c 15 04 12 07 10 
02 21 13 04 10 10 03 14 04 18 
01 1b 01 1a 01 13 0d 16 10 1c 
03 1c 00 1e 0f 1f 0c 21 03 05 
02 02 0c 07 06 09 04 0a 06 22 
00 23 00 0e 04 0a 03 17 07 15 
11 07 11 06 0b 08 0b 0f 01 0b 
05 01 12 05 09 0c 09 06 01 0c 
0e 13 01 04 02 0d 

74a2: 00 00  00 00 2e 2c  2c 2c 2c 2c  2c 2c 1e 1f
>C:74b0  13 1a 18 1f  0c 20 33 28  2a 1b 33 2e  21 1e 1f 

;74bf-7527
costume_offset_in_sector:
74bf: cd 07 b1 07 e3  0e b4 24 01  2c 6d 16 b8  1d 42 33 98
1a 9a 11 1b  0f 08 18 4a  0f 9e 0d 08  0e 96 0a 90
>C:74e0  0c 40 06 1b  0b f9 0d d8  0d 91 07 7f  21 23 22 5e
>C:74f0  18 

;74f1
room_for_script:
09 2d 32  12 12 12 08  08 10 16 1b  07 18 18 11
>C:7500  03 1c 1c 0a  12 12 12 12  19 05 05 05  05 05 05 13
>C:7510  13 13 13 13  15 15 15 2b  09 04 08 08  08 1b 0c 1b
>C:7520  15 1b 1b 09  04 01 07 07  07 01 2f 1e  12 12 12 12
>C:7530  12 12 12 12  12 12 07 1d  01 17 18 17  17 07 07 17
>C:7540  09 09 09 1a  1a 1a 1a 1a  1a 1a 1a 1a  1a 1a 1a 1f
>C:7550  11 12 2c 0c  0c 01 29 14  14 14 14 01  28 1b 2d 1f
>C:7560  1a 1f 33 1f  21 10 10 1e  2a 1e 1e 1e  33 1e 2e 2d
>C:7570  01 32 33 21  15 04 26 26  26 26 26 26  26 26 04 1f
>C:7580  01 0a 07 1a  13 13 08 01  01 09 09 1f  1f 14 1f 0c
>C:7590  09 
;7591
global_script_read_offsets:
73 06 d1  0a 12 05 20  11 d9 11 e4  11 70 0d ae   .s..... .....p..
>C:75a0  0d d2 10 ec  0b 66 0c 98  10 3c 0e 5b  0e 2b 0d 43   .....f...<.[.+.C
>C:75b0  0e 4e 09 6e  09 62 0c ef  11 4d 12 90  12 ca 12 af   .N.n.b...M......
>C:75c0  0b 57 10 86  10 a0 10 b3  10 cd 10 f3  10 66 0c ef   .W...........f..
>C:75d0  0c ea 0d 06  0e 56 0e ee  09 10 0a 96  0b 22 03 c4   .....V......."..
>C:75e0  06 aa 0e bb  0d 6d 10 14  11 e6 0c 81  0b b6 0c e1   .....m..........
>C:75f0  0d f6 0c 11  0d 08 07 d5  0e 77 18 b9  10 e6 10 db   .........w......
>C:7600  11 8b 18 a7  09 92 0e 10  13 2c 13 46  13 66 13 89   .........,.F.f..
>C:7610  13 a0 13 b7  13 cb 13 51  13 ee 13 e4  11 da 0c 1f   .......Q........
>C:7620  1a 4f 05 7a  0e 78 06 c2  06 77 12 d8  12 13 07 44   .O.z.x...w.....D
>C:7630  07 02 08 a6  08 13 0c 9b  0d 16 0f 87  0f bf 0f 9f   ................
>C:7640  10 e5 10 c3  11 c0 12 f4  13 9b 15 d2  15 a9 08 49   ...............I
>C:7650  0d ff 13 a9  06 56 0c 1e  0d 9f 1a 75  08 0a 0d 48   .....V.....u...H
>C:7660  0f 40 10 8d  10 eb 1a 66  05 3f 0d 16  0d f2 09 84   .@.....f.?......
>C:7670  16 e5 0a d5  09 0e 0b b5  0a 03 11 0e  11 99 11 35   ...............5
>C:7680  09 06 13 64  14 11 16 f3  0a 33 16 9f  06 50 0d 30   ...d.....3...P.0
>C:7690  1b 7b 05 4a  0b 5b 0c ad  0e e4 0e e5  0b 00 0c 48   .{.J.[.........H
>C:76a0  0c f2 0d 32  0e db 0f fe  0f 36 10 f9  0e bc 0b 17   ...2.....6......
>C:76b0  1c 74 0c 05  13 38 17 bb  0e d1 0e 6c  12 d1 1d 1b   .t...8.....l....
>C:76c0  1f 33 09 de  09 16 0c 43  0d 51 12 65  0d 8d 0d e6   .3.....C.Q.e....
>C:76d0  09 
;76D1
room_for_sound:
1e 21 11  18 24 01 2c  18 2c 2c 24  04 04 04 07   ..!..$.,.,,$....
>C:76e0  07 07 07 18  2b 15 05 05  05 05 11 03  0f 0a 15 19   ....+...........
>C:76f0  19 08 08 18  12 08 15 2c  01 10 17 04  1d 11 1b 05   .......,........
>C:7700  29 29 29 11  29 11 29 2d  1e 21 21 21  1e 1e 33 33   ))).).)-.!!!..33
>C:7710  0c 10 2e 33  33 10 2f 67  0f c0 1b f1  0d 25 0f 9a   ...33./g.....%..
>C:7720  07 2a 1c 05  07 91 0e 74  07 94 07 6f  07 2a 0f 14   .*.....t...o.*..
>C:7730  0f 40 0f 79  13 9a 13 b4  13 db 13 12  0f 7f 03 b1   .@.y............
>C:7740  0f 47 13 80  12 b6 12 19  13 b3 0d ba  0e a5 09 a2   .G..............
>C:7750  0c be 0e 17  0c 2d 0c 71  12 90 12 35  0f 97 14 af   .....-.q...5....
>C:7760  12 c6 0f 1b  07 26 1f 19  11 64 07 60  0f 31 0d c8   .....&...d.`.1..
>C:7770  0d 50 0d 60  13 0b 0b 20  0b 96 0b b0  13 64 0f 7e   .P.`... .....d.~
>C:7780  17 49 0b d4  0f 4b 16 99  0c 30 0d 78  0d 1a 1a 3d   .I...K...0.x...=
>C:7790  1a 57 0b 9e  0b de 0d 39  11 3d 07 2d  0c ee 0b be   .W.....9.=.-....
>C:77a0  11 92 0b 00  00 00 00 00  00 00 00 00  00 00 00 00   ................

;NOTE: code on addresses 7B00-85E4 is erased once the engine is running,
; as it becomes part of the heap

;===========================================
;Processor port bits meaning
;	7	not connected
;	6	not connected
;	5	cassette motor control
;	4	cassette switch sense
;	3	cassette data output line
;	2	select character ROM or I/O devices at D000 (1 = I/O, 0 = ROM) - abbreviated CHAREN
;	1	select KERNAL ROM or RAM at E000 (1 = KERNAL, 0 = RAM) - abbreviated HIRAM
;	0	select BASIC ROM or RAM at A000 (1 = BASIC, 0 = RAM) - abbreviated LORAM

; Data direction
; Bit set = bit used for output
; Bit clear = bit used for input
;----------------------------------------------------------------------------------
;
; CIA 2 interrupt control bits meaning (when _writing_)
;	7	Set or clear bits of this register
;			0 = "sibling" bits written with 1 will be cleared (interrupts for those bits will be disabled)
;			1 = "sibling" bits written with 1 will be set (interrupts for those bits will be enabled)
;	6	Not used
;	5	Not used
;	4	Enable/disable FLAG line interrupt (1 = enable, 0 = disable)
;	3	Enable/disable serial shift register interrupt (1 = enable, 0 = disable)
;	2	Enable/disable TOD (time of day) clock alarm interrupt (1 = enable, 0 = disable)
;	1	Enable/disable Timer B interrupt (1 = enable, 0 = disable)
;	0	Enable/disable Timer A interrupt (1 = enable, 0 = disable)
;----------------------------------------------------------------------------------
; CIA 2 Port A bits meaning
;	7	Serial bus data input (DATA IN)
;	6	Serial bus clock pulse input (CLOCK IN)
;	5	Serial bus data output (DATA OUT)
;	4	Serial bus clock pulse output (CLOCK OUT)
;	3	Serial bus ATN (attention) signal output (ATN OUT)
;	2	RS-232 data output / Pin M of User port (TXD)
; 1-0	VIC-II memory bank select


;===========================================
; Setup interrupt handler vectors and the drive custom loader code.
;
; For the drive code setup, we still need to use KERNAL routines
; to perform the communication. Once the loader's code is fully set up,
; we no longer need KERNAL and we can map a block of RAM in its place.
;===========================================
group_counter = $FA
byte_counter = $FB
destination = $FC
source = $FE

setup_vectors_and_drive_code:
;----------------------------------------------------------------
; Interrupt handler vectors setup
;----------------------------------------------------------------
;Set bits 2-0 for output, bits 7-3 for input
;This will effectively not change anything related to the cassette and will allow changing the 3 memory mapping bits
.C:7fff  A9 07       LDA #$07
.C:8001  85 00       STA processor_data_direction_reg
;Map I/O and KERNAL, map RAM instead of BASIC
.C:8003  A9 06       LDA #$06	
.C:8005  85 01       STA processor_port_register
;Disable interrups while we change interrupt handlers
.C:8007  78          SEI
;Set IRQ handler to $EA31
.C:8008  A9 31       LDA #$31
.C:800a  8D 14 03    STA <kernal_irq_vector
.C:800d  A9 EA       LDA #$EA
.C:800f  8D 15 03    STA >kernal_irq_vector
;Set BRK handler to $EA31
.C:8012  A9 31       LDA #$31
.C:8014  8D 16 03    STA <kernal_brk_vector
.C:8017  A9 EA       LDA #$EA
.C:8019  8D 17 03    STA >kernal_brk_vector
;Set NMI handler to $FE47 - original NMI handler skipping hardware NMI
.C:801c  A9 47       LDA #$47
.C:801e  8D 18 03    STA <kernal_nmi_vector
.C:8021  A9 FE       LDA #$FE
.C:8023  8D 19 03    STA >kernal_nmi_vector
; Writing #FF means:
;	Bit 7 is set -> bits that have a 1 will be set
;	Bits 6-5 are ignored, and bits 4-0 are all 1, which means they will be set and will enable them as sources of interrupts.
;
; To sum up, all five sources of interrupts are enabled
.C:8026  A9 FF       LDA #$FF
.C:8028  8D 0D DD    STA cia2_irq_status_register
;Clear all port B direction bits except for bit 5
;This means: keep User port pin J direction (input or output) unchanged
;Set pins C,D,E,F,H,K,L of User Port for input
.C:802b  AD 03 DD    LDA cia2_port_b_data_direction_reg
.C:802e  29 20       AND #$20
.C:8030  8D 03 DD    STA cia2_port_b_data_direction_reg
;----------------------------------------------------------------
; Drive code setup
;
; This part will upload code to the drive's memory.
; Specifically, it will copy it to buffer #2, which starts at $0500
; in the drive's memory space.
;
; After the upload is complete, it instructs the drive to execute that code.
; That will halt the default execution of the drive's original ROM code
; and will instead run a much simpler code supporting a small set of commands.
;
; See the loader's code dissassembly for details.
;----------------------------------------------------------------
;Port A - Clear DATA IN, DATA OUT, CLOCK IN, CLOCK OUT, ATN OUT
; Set TXD line
; Set VIC bank to #0 (0000-3FFF)
.C:8033  A9 07       LDA #$07		;0000 0111
.C:8035  8D 00 DD    STA cia2_port_a_data_register
;Set DATA IN and CLOCK IN bits 7-6 as input
;Set the rest as output
.C:8038  A9 3F       LDA #$3F		;0011 1111
.C:803a  8D 02 DD    STA cia2_port_a_data_direction_reg
;Issue a drive Initialize command
.C:803d  20 C9 80    JSR drive_initialize_cmd
;Copy data in $8121-8321 to the drive's memory and execute it
;Set source pointer = $8121
.C:8040  A9 21       LDA #$21
.C:8042  85 FE       STA <source
.C:8044  A9 81       LDA #$81
.C:8046  85 FF       STA >source
;Set destination pointer = $0500 (also called "buffer #2" in the drive's memory space)
.C:8048  A9 00       LDA #$00
.C:804a  85 FC       STA <destination
.C:804c  A9 05       LDA #$05
.C:804e  85 FD       STA >destination
; We'll write a total of #10 32-byte groups (16 * 32 = 512 bytes)
.C:8050  A2 10       LDX #$10
copy_next_group_to_drive:
.C:8052  86 FA       STX group_counter
.C:8054  20 A5 80    JSR drive_issue_write_memory_32	;.Y = 0 on return
drive_write_loop:
.C:8057  84 FB       STY byte_counter
;Load source byte
.C:8059  B1 FE       LDA (source),Y
;Write byte out to serial port
.C:805b  20 D2 FF    JSR CHROUT
;Increment byte counter
.C:805e  A4 FB       LDY byte_counter
.C:8060  C8          INY
;Check if we reached the end of the group (#20 bytes)
.C:8061  C0 20       CPY #$20
;If not, continue
.C:8063  D0 F2       BNE drive_write_loop
;Write <return> - this finishes the command string
.C:8065  A9 0D       LDA #$0D						
.C:8067  20 D2 FF    JSR CHROUT
;Close the drive's channel
.C:806a  20 F9 80    JSR drive_close_channel
;Move pointers by #20 bytes
.C:806d  20 DE 80    JSR add_20_to_pointers
;Do we have groups pending to copy?
.C:8070  A6 FA       LDX group_counter
.C:8072  CA          DEX
.C:8073  D0 DD       BNE copy_next_group_to_drive
;No groups left
;Issue a drive command to execute the code we just uploaded
.C:8075  20 90 80    JSR drive_issue_u3_command
;Prepare serial port for custom communication		
.C:8078  4C 01 81    JMP setup_serial_communication
;===========================================
; Open command channel to drive
;
; The command channel requires using the channel number 15.
;===========================================
drive_open_command_channel:
;Set filename to empty
.C:807b  A9 00       LDA #$00
.C:807d  20 BD FF    JSR SETNAM
;Set 15,8,15 as logical, device and command numbers respectively
.C:8080  A9 0F       LDA #$0F
.C:8082  A2 08       LDX #$08
.C:8084  A8          TAY
.C:8085  20 BA FF    JSR SETLFS
;Open the logical file
.C:8088  20 C0 FF    JSR OPEN
;Set channel 15 for output
.C:808b  A2 0F       LDX #$0F
.C:808d  4C C9 FF    JMP CHKOUT
;===========================================
; Issues the drive command "U3"
; This effectively causes the drive's CPU to execute a JMP $0500.
; $0500 is what's called buffer #2 in the drive's memory space.
;===========================================
drive_issue_u3_command:
.C:8090  20 7B 80    JSR drive_open_command_channel
.C:8093  A9 55       LDA #$55		;"U"
.C:8095  20 D2 FF    JSR CHROUT
.C:8098  A9 33       LDA #$33		;"3"
.C:809a  20 D2 FF    JSR CHROUT
.C:809d  A9 0D       LDA #$0D		;<return>
.C:809f  20 D2 FF    JSR CHROUT
.C:80a2  4C F9 80    JMP drive_close_channel
;===========================================
; Issues a drive command to write 32 bytes to the drive's memory.
;
; Arguments: destination		destination address in the drive's address space
;
; After issuing the command, the drive will listen for the desired data.
; 
; The data has to be sent by the caller after issuing the command.
;
; The syntax for the command string is "M-W<addr_lo><addr_hi><data_size>".
; 		addr_lo/hi	the hi and lo bytes of the destination's 16-bit address
;		data_size	the amount of data to be written, expressed in bytes
;
; Note: the command needs to be terminated by a "Return" character (#0D).
;===========================================
destination = $FC

drive_issue_write_memory_32:
.C:80a5  20 7B 80    JSR drive_open_command_channel
.C:80a8  A9 4D       LDA #$4D		;"M"
.C:80aa  20 D2 FF    JSR CHROUT
.C:80ad  A9 2D       LDA #$2D		;"-"
.C:80af  20 D2 FF    JSR CHROUT
.C:80b2  A9 57       LDA #$57		;"W"
.C:80b4  20 D2 FF    JSR CHROUT
.C:80b7  A5 FC       LDA <destination
.C:80b9  20 D2 FF    JSR CHROUT
.C:80bc  A5 FD       LDA >destination
.C:80be  20 D2 FF    JSR CHROUT
.C:80c1  A9 20       LDA #$20		;data
.C:80c3  20 D2 FF    JSR CHROUT
.C:80c6  A0 00       LDY #$00
.C:80c8  60          RTS
;===========================================
; Issues an initialize command to the drive
;
; This causes the drive to read the disk's BAM into memory.
;
; The syntax for the command string is "I<drive #>".
; "I0" will thus initialize drive 0.
;===========================================
drive_initialize_cmd:
.C:80c9  20 7B 80    JSR drive_open_command_channel
.C:80cc  A9 49       LDA #$49		;"I"
.C:80ce  20 D2 FF    JSR CHROUT
.C:80d1  A9 30       LDA #$30		;"0"
.C:80d3  20 D2 FF    JSR CHROUT
.C:80d6  A9 0D       LDA #$0D		;<return>
.C:80d8  20 D2 FF    JSR CHROUT
.C:80db  4C F9 80    JMP drive_close_channel
;===========================================
; Increase source and destination copy pointers by #20 bytes
;===========================================
source = $FE
destination = $FC

add_20_to_pointers:
.C:80de  A5 FE       LDA <source
.C:80e0  18          CLC
.C:80e1  69 20       ADC #$20
.C:80e3  85 FE       STA <source
.C:80e5  A5 FF       LDA >source
.C:80e7  69 00       ADC #$00
.C:80e9  85 FF       STA >source
.C:80eb  A5 FC       LDA <destination
.C:80ed  18          CLC
.C:80ee  69 20       ADC #$20
.C:80f0  85 FC       STA <destination
.C:80f2  A5 FD       LDA >destination
.C:80f4  69 00       ADC #$00
.C:80f6  85 FD       STA >destination
.C:80f8  60          RTS
;===========================================
 drive_close_channel:
;===========================================
.C:80f9  20 CC FF    JSR CLRCHN
.C:80fc  A9 0F       LDA #$0F
.C:80fe  4C C3 FF    JMP CLOSE
;===========================================
; Setup serial communication to disk drive
;
; The game uses custom code to transmit data between the computer and the drive.
; This routine sets up the serial communication by configuring CIA 2 Port A.
; It then sets the initial set of signals for handshaking with the drive.
;===========================================

; CIA 2 Port A bits meaning
;	7	Serial bus data input (DATA IN)
;	6	Serial bus clock pulse input (CLOCK IN)
;	5	Serial bus data output (DATA OUT)
;	4	Serial bus clock pulse output (CLOCK OUT)
;	3	Serial bus ATN (attention) signal output (ATN OUT)
;	2	RS-232 data output / Pin M of User port (TXD)
; 1-0	VIC-II memory bank select

setup_serial_communication:
; CIA 2 Port A data direction
; Bit set = bit used for output
; Bit clear = bit used for input
.C:8101  AD 02 DD    LDA cia2_port_a_data_direction_reg
; Set DATA IN, CLOCK IN for input
; Set ATN OUT, DATA OUT, CLOCK OUT for output
;Clear bits 7-2, leave bits 1-0 unchanged 
.C:8104  29 03       AND #$03		;0000 0011
;Set bits 5-2 - I think bit 2 was not really necessary to set
.C:8106  09 3C       ORA #$3C		;0011 1100
.C:8108  8D 02 DD    STA cia2_port_a_data_direction_reg
;Now clear/set bits on the port's signal lines
;Clear DATA IN and CLOCK IN
;Set ATN OUT, DATA OUT, CLOCK OUT, TXD
;Leave VIC bank unchanged
.C:810b  AD 00 DD    LDA cia2_port_a_data_register
.C:810e  29 03       AND #$03
.C:8110  09 0C       ORA #$0C
.C:8112  8D 00 DD    STA cia2_port_a_data_register
;Set busy wait counter
.C:8115  A2 C0       LDX #$C0
.C:8117  A0 00       LDY #$00
;Do a busy wait doing a countdown 
wait_loop:
.C:8119  88          DEY
.C:811a  D0 FD       BNE wait_loop
.C:811c  CA          DEX
.C:811d  D0 FA       BNE wait_loop
;Disable interrupts
.C:811f  78          SEI
.C:8120  60          RTS
;===========================================
init_memory_sound_and_video:
;Setup interrupt vector handlers
;Setup drive's custom code
.C:82f1  20 FF 7F    JSR setup_vectors_and_drive_code
;Disable interrupts
.C:82f4  78          SEI
;Processor data port direction - ignore cassette bits, allow changing memory mapping
.C:82f5  A9 07       LDA #$07
.C:82f7  85 00       STA processor_data_direction_reg
;Enable blank screen (clear bit 4)
.C:82f9  AD 11 D0    LDA vic_screen_control_register_1
.C:82fc  29 EF       AND #$EF		
.C:82fe  8D 11 D0    STA vic_screen_control_register_1
;------------------------------------------------
; Clear memory areas
;------------------------------------------------
;map_out_io
.C:8301  A0 24       LDY #$24
.C:8303  84 01       STY processor_port_register
.C:8305  20 18 85    JSR clear_gfx_memory	
.C:8308  20 67 84    JSR clear_zero_page_vars
.C:830b  20 72 84    JSR clear_game_and_engine_vars ;Also clears CAD0-CB90
.C:830e  20 0E 85    JSR init_video_memory_mode_and_fd77	;Set video_memory_mode = #00 and room_scene_clicked to #01
.C:8311  20 18 85    JSR clear_gfx_memory
.C:8314  20 BA 84    JSR setup_border_and_sprite_colors
.C:8317  20 D2 84    JSR clear_sprite_regs_and_sprite_memory
;Set new NMI handler to $18EA (which does nothing and returns immediately)
.C:831a  A9 EA       LDA #$EA
.C:831c  8D FA FF    STA nmi_handler_lo
.C:831f  A9 18       LDA #$18
.C:8321  8D FB FF    STA nmi_handler_hi
;
.C:8324  20 6A 85    JSR init_character_data
;------------------------------------------------
;Initialize sound
;------------------------------------------------
;map_in_io
.C:8327  A0 25       LDY #$25
.C:8329  84 01       STY processor_port_register
.C:832b  20 D8 48    JSR init_sound_voices
;map_out_io
.C:832e  A0 24       LDY #$24
.C:8330  84 01       STY processor_port_register
;Disable interrupts
.C:8332  78          SEI
;map_in_io
.C:8333  A0 25       LDY #$25
.C:8335  84 01       STY processor_port_register
;------------------------------------------------
; Initialize interrupt handlers, video memory layout
;------------------------------------------------
;Set new IRQ handler to irq_handler1
.C:8337  A9 7A       LDA <irq_handler1
.C:8339  8D FE FF    STA <irq_handler
.C:833c  A9 16       LDA >irq_handler1
.C:833e  8D FF FF    STA >irq_handler
;Set Blank screen, 25 rows, vertical scroll 3
.C:8341  A9 0B       LDA #$0B		
.C:8343  8D 11 D0    STA vic_screen_control_register_1
;Load value in .A for D800/C800 VIC memory layout (dot-data/video matrix)
.C:8346  A9 26       LDA #$26		
.C:8348  85 21       STA $21
.C:834a  85 BE       STA vic_memory_layout
.C:834c  8D 18 D0    STA vic_memory_control_register
;Set initial frame buffer to #01
.C:834f  A9 01       LDA #$01
.C:8351  85 23       STA frame_buffer
;Multicolor text mode on, 40 columns, horizontal fine scroll 0
.C:8353  A9 18       LDA #$18		
.C:8355  8D 16 D0    STA vic_screen_control2_reg
;Set raster line to generate interrupt on: #FA (250)
.C:8358  A9 FA       LDA #$FA
.C:835a  8D 12 D0    STA raster_line_register
;Set bits 7 and 1 - acknowledge pending screen interrupts - bit 7 ignored?
.C:835d  A9 81       LDA #$81		
.C:835f  8D 19 D0    STA vic_irq_flag_register
;Enable raster interrupt - bit 7 is ignored?
.C:8362  8D 1A D0    STA vic_irq_mask_register
;Read out pending interrupts on CIA #1
.C:8365  AD 0D DC    LDA cia1_irq_status_register
;Clear out bits 0-1 - Set VIC bank base to C000
.C:8368  AD 00 DD    LDA cia2_port_a_data_register
.C:836b  29 FC       AND #$FC		;11111100
.C:836d  09 00       ORA #$00
.C:836f  8D 00 DD    STA cia2_port_a_data_register
;Set Timers A and B to stop timer on underflow
.C:8372  A9 08       LDA #$08
.C:8374  8D 0E DC    STA cia1_control_timer_a_reg
.C:8377  A9 08       LDA #$08
.C:8379  8D 0F DC    STA cia1_control_timer_b_reg
;Set all sprites to enable drawing them on screen
.C:837c  A9 FF       LDA #$FF
.C:837e  8D 15 D0    STA vic_sprite_enable_register
;map_out_io
.C:8381  A0 24       LDY #$24
.C:8383  84 01       STY processor_port_register
;------------------------------------------------
;Copy memory from $7B7F-7BFF to $F040-F0C0 (#80 bytes)
.C:8385  A9 7F       LDA #$7F
.C:8387  85 19       STA $19
.C:8389  A9 7B       LDA #$7B
.C:838b  85 1A       STA $1A
.C:838d  A9 40       LDA #$40
.C:838f  85 1B       STA $1B
.C:8391  A9 F0       LDA #$F0
.C:8393  85 1C       STA $1C
.C:8395  A9 80       LDA #$80
.C:8397  85 15       STA $15
.C:8399  A9 00       LDA #$00
.C:839b  85 16       STA $16
.C:839d  20 A3 83    JSR copy_memory
;Relocate memory (over the KERNAL, BASIC and I/O address space)
;On exit, relocate_memory will invoke raster_setup
.C:83a0  4C C4 83    JMP relocate_memory
;===========================================
; Copy memory 
;
;	Arguments:
;		source			pointer to source data
;		destination		pointer to destination
;		byte_counter	size of data, expressed in bytes
;===========================================
byte_counter = $15
source = $19
destination = $1a

copy_memory:
.C:83a3  A0 00       LDY #$00
.C:83a5  B1 19       LDA (source),Y
.C:83a7  91 1B       STA (destination),Y
.C:83a9  E6 19       INC <source
.C:83ab  D0 02       BNE inc_dest_ptr
.C:83ad  E6 1A       INC >source
inc_dest_ptr:
.C:83af  E6 1B       INC <destination
.C:83b1  D0 02       BNE dec_counters
.C:83b3  E6 1C       INC >destination
dec_counters:
.C:83b5  A5 15       LDA <byte_counter
.C:83b7  D0 02       BNE dec_counter_lo
.C:83b9  C6 16       DEC >byte_counter
dec_counter_lo:
.C:83bb  C6 15       DEC <byte_counter
;OR'ing the counters will yield zero if both are zero - if so, exit
.C:83bd  A5 15       LDA <byte_counter
.C:83bf  05 16       ORA >byte_counter
.C:83c1  D0 E0       BNE copy_memory
.C:83c3  60          RTS
;===========================================
; Copies memory on the following ranges:
;
;	Source			Destination		Total bytes copied
; 	$95E0-9671		$0100-019B 		#9B
; 	$85E4-86A4		$CAD0-CB90 		#C0
;	$86A4-8EA4		$D000-D800 		#0800 					
; 	$8EA0-95DF		$F0C0-F7FF 		#73F
;	$7BFF-7FFF		$F800-FC00 		#0400
;
; Most of the code and data pieces being copied are 
; moved into address spaces previously used by KERNAL and BASIC.
;
; The D000-D800 address space is "shared" with the I/O registers.
;
; The decompression routines are copied into the $0100-019B address space, which was
; previously also used by BASIC.
;
; The 6510 is hardcoded to use page #1 (0100-01FF) for the stack area.
; So that leaves a usable stack address space of 19C-1FF (#63 or 99 bytes in total).
;===========================================
relocate_memory:
;Copy memory from $7BFF-7FFF to $F800-FC00 (#0400 bytes)
;This covers the character set for text and the scroll arrows
.C:83c4  A9 FF       LDA #$FF
.C:83c6  85 19       STA $19
.C:83c8  A9 7B       LDA #$7B
.C:83ca  85 1A       STA $1A
.C:83cc  A9 00       LDA #$00
.C:83ce  85 1B       STA $1B
.C:83d0  A9 F8       LDA #$F8
.C:83d2  85 1C       STA $1C
.C:83d4  A9 00       LDA #$00
.C:83d6  85 15       STA $15
.C:83d8  A9 04       LDA #$04
.C:83da  85 16       STA $16
.C:83dc  20 A3 83    JSR copy_memory
;Copy memory from $86A4-8EA4 to $D000-D800 (#0800 bytes)
;This includes the script opcode handlers (D000-D1FF)
; Graphics-related constants and data (D200-D698)
; Graphics-related code (D69D-D7FB)
.C:83df  A9 A4       LDA #$A4
.C:83e1  85 19       STA $19
.C:83e3  A9 86       LDA #$86
.C:83e5  85 1A       STA $1A
.C:83e7  A9 00       LDA #$00
.C:83e9  85 1B       STA $1B
.C:83eb  A9 D0       LDA #$D0
.C:83ed  85 1C       STA $1C
.C:83ef  A9 00       LDA #$00
.C:83f1  85 15       STA $15
.C:83f3  A9 08       LDA #$08
.C:83f5  85 16       STA $16
.C:83f7  20 A3 83    JSR copy_memory
;Copy memory from $8EA0-95DF to $F0C0-F7FF (#73F bytes)
;This includes game engine constants
.C:83fa  A9 A0       LDA #$A0
.C:83fc  85 19       STA $19
.C:83fe  A9 8E       LDA #$8E
.C:8400  85 1A       STA $1A
.C:8402  A9 C0       LDA #$C0
.C:8404  85 1B       STA $1B
.C:8406  A9 F0       LDA #$F0
.C:8408  85 1C       STA $1C
.C:840a  A9 3F       LDA #$3F
.C:840c  85 15       STA $15
.C:840e  A9 07       LDA #$07
.C:8410  85 16       STA $16
.C:8412  20 A3 83    JSR copy_memory
;Copy memory from $95E0-9671 to $0100-019B (#9B bytes)
;This is the set of decompression routines
.C:8415  A9 E0       LDA #$E0
.C:8417  85 19       STA $19
.C:8419  A9 95       LDA #$95
.C:841b  85 1A       STA $1A
.C:841d  A9 00       LDA #$00
.C:841f  85 1B       STA $1B
.C:8421  A9 01       LDA #$01
.C:8423  85 1C       STA $1C
.C:8425  A9 9B       LDA #$9B
.C:8427  85 15       STA $15
.C:8429  A9 00       LDA #$00
.C:842b  85 16       STA $16
.C:842d  20 A3 83    JSR copy_memory
;Copy memory from $85E4-86A4 to $CAD0-CB90 (#C0 bytes)
;Upon game startup, this region is filled with zeroes
.C:8430  A9 E4       LDA #$E4
.C:8432  85 19       STA $19
.C:8434  A9 85       LDA #$85
.C:8436  85 1A       STA $1A
.C:8438  A9 D0       LDA #$D0
.C:843a  85 1B       STA $1B
.C:843c  A9 CA       LDA #$CA
.C:843e  85 1C       STA $1C
.C:8440  A9 C0       LDA #$C0
.C:8442  85 15       STA $15
.C:8444  A9 00       LDA #$00
.C:8446  85 16       STA $16
.C:8448  20 A3 83    JSR copy_memory
;Set initial cursor settings
.C:844b  A9 0D       LDA #$0D
.C:844d  8D 7F CB    STA cursor_x_pixel
.C:8450  A9 1C       LDA #$1C
.C:8452  8D 81 CB    STA cursor_y_pixel
.C:8455  A9 00       LDA #$00
.C:8457  8D 88 CB    STA interaction_region
.C:845a  20 DA F7    JSR set_cursor_physics
;Hide cursor
.C:845d  A9 01       LDA #$01
.C:845f  8D 6C 16    STA hide_cursor
;Enable interrupts
.C:8462  58          CLI
;Setup the raster IRQ handlers
.C:8463  20 1C 34    JSR raster_setup
.C:8466  60          RTS
;===========================================
; Clears zero page vars in the range $15-$FF
;===========================================
clear_zero_page_vars:
.C:8467  A0 15       LDY #$15
.C:8469  A9 00       LDA #$00
clear:
.C:846b  99 00 00    STA $0000,Y
.C:846e  C8          INY
.C:846f  D0 FA       BNE clear
.C:8471  60          RTS
;===========================================
; Clears the memory range FC00-FFF3 with #00
;===========================================
clear_game_and_engine_vars:
.C:8472  A9 00       LDA #$00
.C:8474  85 19       STA <dest_pointer
.C:8476  A9 FC       LDA #$FC
.C:8478  85 1A       STA >dest_pointer
.C:847a  A9 F3       LDA #$F3
.C:847c  85 1B       STA <byte_counter
.C:847e  A9 03       LDA #$03
.C:8480  85 1C       STA >byte_counter
.C:8482  A2 00       LDX #$00
.C:8484  20 8A 84    JSR fill_memory_with_value_3
.C:8487  4C A4 84    JMP clear_cad0_cb90
;===========================================
;Fills memory with a specific value
;
; Arguments: 	.X 				value to write
;				dest_pointer		pointer to destination
;				byte_counter	total number of bytes to write
;
; This is an exact clone of "fill_memory_with_value"
;===========================================
dest_pointer = $19
byte_counter = $1B

fill_memory_with_value_3:
;We'll move the base pointer instead of Y, which will stay set at #00
.C:848a  A0 00       LDY #$00
.C:848c  8A          TXA
;Store fill value in memory
.C:848d  91 19       STA (dest_pointer),Y
;Move pointer
.C:848f  E6 19       INC <dest_pointer
.C:8491  D0 02       BNE update_counters
.C:8493  E6 1A       INC >dest_pointer
update_counters_3:
.C:8495  A5 1B       LDA <byte_counter
.C:8497  D0 02       BNE counter_lo_decrement_3
.C:8499  C6 1C       DEC >byte_counter
counter_lo_decrement_3:
.C:849b  C6 1B       DEC <byte_counter
;OR'ing both counter bytes will yield zero if both are zero
.C:849d  A5 1B       LDA <byte_counter
.C:849f  05 1C       ORA >byte_counter
.C:84a1  D0 E7       BNE fill_memory_with_value_3
.C:84a3  60          RTS
;===========================================
clear_cad0_cb90:
;Fill CAD0-CB90 with #00
.C:84a4  A9 D0       LDA #$D0
.C:84a6  85 19       STA base_ptr_lo
.C:84a8  A9 CA       LDA #$CA
.C:84aa  85 1A       STA base_ptr_hi
.C:84ac  A9 C0       LDA #$C0
.C:84ae  85 1B       STA byte_counter_lo
.C:84b0  A9 00       LDA #$00
.C:84b2  85 1C       STA byte_counter_hi
.C:84b4  A2 00       LDX #$00
.C:84b6  20 8A 84    JSR fill_memory_with_value_3
.C:84b9  60          RTS
;===========================================
setup_border_and_sprite_colors:
;map_in_io
.C:84ba  A0 25       LDY #$25
.C:84bc  84 01       STY processor_port_register
;Set border color to black
.C:84be  A9 00       LDA #$00
.C:84c0  8D 20 D0    STA vic_border_color_register
;Set sprite multicolors to #00 and #0A (black and light red/skin tone)
;These correspond to the bit pairs "11" and "01" respectively (mcolor1 and mcolor0)
.C:84c3  A9 00       LDA #$00
.C:84c5  8D 26 D0    STA vic_sprite_mcolor1_reg
.C:84c8  A9 0A       LDA #$0A
.C:84ca  8D 25 D0    STA vic_sprite_mcolor0_reg
;map_out_io
.C:84cd  A0 24       LDY #$24
.C:84cf  84 01       STY processor_port_register
.C:84d1  60          RTS
;===========================================
clear_sprite_regs_and_sprite_memory:
;map_in_io
.C:84d2  A0 25       LDY #$25
.C:84d4  84 01       STY processor_port_register
;Initialize sprite registers
.C:84d6  A9 00       LDA #$00
.C:84d8  8D 1D D0    STA vic_sprite_hor_expansion_reg		;Sprite double width register
.C:84db  8D 17 D0    STA $D017		;Sprite double height register
.C:84de  8D 1B D0    STA $D01B		;Sprite priority register
.C:84e1  8D 1E D0    STA $D01E		;Sprite-sprite collision register
.C:84e4  8D 1F D0    STA $D01F		;Sprite-bkg collision register
;Set multicolor mode for sprites 6-0
.C:84e7  A9 7F       LDA #$7F
.C:84e9  8D 1C D0    STA $D01C		;Sprite multicolor mode register
;Set sprite shape data pointer
.C:84ec  A9 F8       LDA #$F8
.C:84ee  85 8C       STA <sprite_shape_data_ptr
.C:84f0  A9 CB       LDA #$CB
.C:84f2  85 8D       STA >sprite_shape_data_ptr
;map_out_io
.C:84f4  A0 24       LDY #$24
.C:84f6  84 01       STY processor_port_register
;Fill sprite memory (E000-F000) with #00
.C:84f8  A9 00       LDA #$00
.C:84fa  85 19       STA base_ptr_lo
.C:84fc  A9 E0       LDA #$E0
.C:84fe  85 1A       STA base_ptr_hi
.C:8500  A9 00       LDA #$00
.C:8502  85 1B       STA byte_counter_lo
.C:8504  A9 10       LDA #$10
.C:8506  85 1C       STA byte_counter_hi
.C:8508  A2 00       LDX #$00
.C:850a  20 8A 84    JSR fill_memory_with_value_3
.C:850d  60          RTS
;===========================================
; video_memory_mode = #00, room_scene_clicked = #01
;===========================================
init_video_memory_mode_and_fd77:
.C:850e  A9 00       LDA #$00
.C:8510  85 22       STA video_memory_mode
.C:8512  A9 01       LDA #$01
.C:8514  8D 77 FD    STA room_scene_clicked
.C:8517  60          RTS
;===========================================
;Clears the two "frame buffers" used for
; the scene graphical area.
; Clears the D800-E000 area.
; Fills color RAM with color #0E.
;===========================================
clear_gfx_memory:
;Clear frame buffer 1 (C800) with #00 values
.C:8518  A9 00       LDA #$00
.C:851a  85 19       STA base_ptr_lo
.C:851c  A9 C8       LDA #$C8
.C:851e  85 1A       STA base_ptr_hi
.C:8520  A9 E8       LDA #$E8
.C:8522  85 1B       STA byte_counter_lo
.C:8524  A9 03       LDA #$03
.C:8526  85 1C       STA byte_counter_hi
.C:8528  A2 00       LDX #$00
.C:852a  20 8A 84    JSR fill_memory_with_value_3
;Clear frame buffer 2 (CC00) with #00
.C:852d  A9 00       LDA #$00
.C:852f  85 19       STA base_ptr_lo
.C:8531  A9 CC       LDA #$CC
.C:8533  85 1A       STA base_ptr_hi
.C:8535  A9 E8       LDA #$E8
.C:8537  85 1B       STA byte_counter_lo
.C:8539  A9 03       LDA #$03
.C:853b  85 1C       STA byte_counter_hi
.C:853d  A2 00       LDX #$00
.C:853f  20 8A 84    JSR fill_memory_with_value_3
;Clear dot-data (D800-E000) with #00
.C:8542  A9 00       LDA #$00
.C:8544  85 19       STA base_ptr_lo
.C:8546  A9 D8       LDA #$D8
.C:8548  85 1A       STA base_ptr_hi
.C:854a  A9 00       LDA #$00
.C:854c  85 1B       STA byte_counter_lo
.C:854e  A9 08       LDA #$08
.C:8550  85 1C       STA byte_counter_hi
.C:8552  A2 00       LDX #$00
.C:8554  20 8A 84    JSR fill_memory_with_value_3
;map_in_io
.C:8557  A0 25       LDY #$25
.C:8559  84 01       STY processor_port_register
;Fill message bar color (D800-D827) with #0E
.C:855b  A0 27       LDY #$27
fill_color_loop:
.C:855d  A9 0E       LDA #$0E
.C:855f  99 00 D8    STA color_ram,Y
.C:8562  88          DEY
.C:8563  10 F8       BPL fill_color_loop
;map_out_io
.C:8565  A0 24       LDY #$24
.C:8567  84 01       STY processor_port_register
.C:8569  60          RTS
;===========================================
init_character_data:
.C:856a  A9 E0       LDA #$E0
.C:856c  8D 2F FC    STA >actor_sprite_base
.C:856f  A9 E1       LDA #$E1
.C:8571  8D 6D FD    STA <room_scene_mask_layer_ptr
.C:8574  A9 6A       LDA #$6A
.C:8576  8D 6E FD    STA >room_scene_mask_layer_ptr
.C:8579  A0 00       LDY #$00
loop:
.C:857b  A9 FF       LDA #$FF
.C:857d  99 32 FC    STA actor_sprite_index,Y
.C:8580  C8          INY
.C:8581  C0 04       CPY #$04
.C:8583  D0 F6       BNE loop
.C:8585  60          RTS
;===========================================
init_game_engine:
;Init sentence queue system
.C:8586  A9 FF       LDA #$FF
.C:8588  8D 17 FE    STA sentence_queue_index
.C:858b  A9 06       LDA #$06
.C:858d  8D 18 FE    STA sentence_queue_free_capacity
;Set message bar standard delay
.C:8590  A9 1E       LDA #$1E
.C:8592  85 CD       STA <standard_message_delay
.C:8594  A9 00       LDA #$00
.C:8596  85 CE       STA >standard_message_delay
;Set initial text speed factor
.C:8598  A9 06       LDA #$06
.C:859a  85 CF       STA text_delay
;Set current verb to "Walk to"
.C:859c  A9 0D       LDA #$0D
.C:859e  8D 1F FE    STA current_verb
;Enable refreshing the sentence bar
.C:85a1  A9 01       LDA #$01
.C:85a3  8D 49 FE    STA refresh_sentence_bar_flag
;Set environment lights on
.C:85a6  A9 01       LDA #$01
.C:85a8  8D AB FE    STA lights_status
;Set desired disk ID = game disk side 2
.C:85ab  A9 32       LDA #$32		;Side 2 Disk ID
.C:85ad  8D 9C FE    STA desired_disk_id		;Desired disk ID
;Init camera position
.C:85b0  A9 C8       LDA #$C8
.C:85b2  8D 67 06    STA camera_current_position
;Loop over all characters
.C:85b5  A2 18       LDX #$18
loop:
;Set default animation set to "standing looking down"
.C:85b7  A9 06       LDA #$06
.C:85b9  9D 47 FF    STA animation_set_for_costume,X
;Unassign actor for costume
.C:85bc  A9 FF       LDA #$FF
.C:85be  9D 57 FE    STA actor_for_costume,X
.C:85c1  CA          DEX
.C:85c2  10 F3       BPL loop
;Reset actor attributes and "in use" settings
.C:85c4  A2 03       LDX #$03
reset_actor:
.C:85c6  A9 80       LDA #$80
.C:85c8  9D EB FD    STA path_direction_for_actor,X
;Set all actors as "not in use"
.C:85cb  A9 FF       LDA #$FF
.C:85cd  9D 53 FE    STA costume_for_actor,X
.C:85d0  CA          DEX
.C:85d1  10 F3       BPL reset_actor
;Unused vars
.C:85d3  A9 01       LDA #$01
.C:85d5  8D 82 FE    STA $FE82
.C:85d8  8D 81 FE    STA $FE81
;Init random number seed
.C:85db  A9 4D       LDA #$4D	
.C:85dd  85 DD       STA random_1
.C:85df  A9 97       LDA #$97
.C:85e1  85 DE       STA random_2
.C:85e3  60          RTS
;===========================================


;CC00-CC27 - Top bar message being displayed

opcode_handlers_lo:
>C:d000  
f2 f4 c8 24  71 d9 cc eb  96 d9 d9 91  4d 8f 77 37
00 5a 0d 8f  ba ac 2f 27  d6 d9 06 a3  2b ae de 03
57 f4 04 d9  3f 12 1d 1b  4a 24 9c 91  d9 16 c3 fb
2d bd 01 75  cc d9 57 2f  66 d9 37 d9  b9 ae de 0b
7a f4 ca 24  7e d9 14 fd  a1 d9 38 91  43 a9 73 37
05 5a 19 5b  da ac 43 27  b6 d9 24 a3  2b ae de 03
89 f4 ac d9  50 d9 e6 39  78 24 d9 91  d9 16 d1 fb
ab bd d8 09  cc 71 53 2f  8b d9 d9 d9  62 ae de 07
d9 f4 d9 24  71 d9 cc eb  96 d9 d9 91  4d d9 77 33
83 5a 0d 9c  ba ac d9 23  c3 d9 06 a3  2b ae de ff
f2 f4 04 d9  3b 12 d9 1b  58 24 d9 91  d9 16 c3 f7
2d bd 01 82  cc d9 57 2b  66 d9 37 d9  b9 ae de 07
b0 f4 ca 24  7e d9 1c fd  a1 d9 38 91  43 b6 73 33
05 5a 19 68  da ac 43 23  d9 d9 24 a3  2b ae de ff
89 f4 ac d9  4c 2d d9 39  78 24 d9 91  d9 16 d5 f7
ab bd d8 09  cc d9 53 2b  8b d9 d9 d9  62 ae de 0b

opcode_handlers_hi:
>C:d100  60 66 65 67  61 6a 64 68  61 6a 6a 63  6a 64 66 62
>C:d110  61 69 68 6a  64 66 65 62  60 6a 61 63  66 63 66 62
>C:d120  6a 66 6a 6a  62 63 65 69  61 64 65 63  6a 67 64 61
>C:d130  6a 63 68 6a  64 6a 66 62  61 6a 61 6a  65 63 66 62
>C:d140  67 66 61 67  61 6a 61 68  61 6a 6a 63  6a 6a 66 62
>C:d150  61 69 68 6a  69 66 65 62  60 6a 61 63  66 63 66 62
>C:d160  68 66 61 6a  62 6a 64 69  65 64 6a 63  6a 67 6a 61
>C:d170  69 63 61 64  64 64 66 62  61 6a 6a 6a  65 63 66 62
>C:d180  6a 66 6a 67  61 6a 6a 68  61 6a 6a 63  6a 6a 66 62
>C:d190  62 69 68 6a  64 66 6a 62  6a 6a 61 63  66 63 66 61
>C:d1a0  60 66 6a 6a  62 63 6a 69  61 64 6a 63  6a 67 64 61
>C:d1b0  6a 63 68 6a  64 6a 66 62  61 6a 61 6a  65 63 66 62
>C:d1c0  67 66 61 67  61 6a 61 68  61 6a 6a 63  6a 6a 66 62
>C:d1d0  61 69 68 6a  69 66 65 62  6a 6a 61 63  66 63 66 61
>C:d1e0  68 66 61 6a  62 63 6a 69  65 64 6a 63  6a 67 6a 61
>C:d1f0  69 63 61 64  64 6a 66 62  61 6a 6a 6a  65 63 66 62

;#00 60F2
;#01 66F4	Shared
;#02 65C8
;#03 6724	Shared
;#04 6171
;#05 6AD9	Shared
;#06 64CC
;#07 68EB
;#08 6196	Is not equal
;#09 6AD9	Shared
;#0A 6AD9	Shared
;#0B 6391	Shared
;#0C 6A4D
;#0D 648F
;#0E 6677
;#0F 6237
;#10 6100
;#11 695A
;#12 680D
;#13 6A8F
;#14 64BA
;#15 66AC
;#16 652F
;#17 6227
;#18 60D6	Displace pointer (2-byte offset)
;#19 6AD9	Copy immediate value to variable
;#1A 6106
;#1B 63A3
;#1C 662B
;#1D 63AE	Shared
;#1E 66DE	Shared
;#1F 6203
;#20 6A57
;#21 66F4	Shared
;#22 6A04
;#23 6AD9	Shared
;#24 623F
;#25 6312
;#26 651D
;#27 691B
;#28 614A	Is not zero
;#29 6424
;#2A 659C
;#2B 6391	Shared
;#2C 6AD9	Shared
;#2D 6716
;#2E 64C3
;#2F 61FB
;#30 6A2D
;#31 63BD
;#32 6801
;#33 6A75
;#34 64CC	Shared
;#35 6AD9	Shared
;#36 6657
;#37 622F
;#38 6166 
;#39 6AD9	Shared
;#3A 6137	Subtract immediate value from variable
;#3B 6AD9	Shared
;#3C 65B9
;#3D 63AE	Shared
;#3E 66DE	Shared
;#3F 620B
;#40 677A
;#41 66F4	Shared
;#42 61CA
;#43 6724	Shared
;#44 617E
;#45 6AD9	Shared
;#46 6114	Increment variable value by 1
;#47 68FD
;#48 61A1	Is equal
;#49 6AD9	Shared
;#4A 6A38
;#4B 6391	Shared
;#4C 6A43
;#4D 6AA9
;#4E 6673
;#4F 6237	Shared
;#50 6105	Do nothing
;#51 695A
;#52 6819
;#53 6A5B
;#54 69DA
;#55 66AC
;#56 6543
;#57 6227
;#58 60B6
;#59 6AD9
;#5A 6124	Add immediate value to variable
;#5B 63A3
;#5C 662B
;#5D 63AE
;#5E 66DE
;#5F 6203
;#60 6889
;#61 66F4
;#62 61AC
;#63 6AD9
;#64 6250
;#65 6AD9
;#66 64E6
;#67 6939
;#68 6578
;#69 6424
;#6A 6AD9
;#6B 6391
;#6C 6AD9
;#6D 6716
;#6E 6AD1
;#6F 61FB
;#70 69AB
;#71 63BD
;#72 61D8	Do nothing
;#73 6409
;#74 64CC
;#75 6471
;#76 6653
;#77 622F
;#78 618B	Is less than
;#79 6AD9
;#7A 6AD9
;#7B 6AD9
;#7C 6562
;#7D 63AE
;#7E 66DE
;#7F 6207
;#80 6AD9
;#81 66F4
;#82 6AD9
;#83 6724
;#84 6171
;#85 6AD9
;#86 6ACC	Invalid address
;#87 68EB
;#88 6196	Is not equal
;#89 6AD9
;#8A 6AD9
;#8B 6391
;#8C 6A4D
;#8D 6AD9
;#8E 6677
;#8F 6233
;#90 6283
;#91 695A
;#92 680D
;#93 6A9C
;#94 64BA
;#95 66AC
;#96 6AD9
;#97 6223
;#98 6AC3
;#99 6AD9
;#9A 6106 	Copy variable value to variable
;#9B 63A3
;#9C 662B
;#9D 63AE
;#9E 66DE
;#9F 61FF
;#A0 60F2
;#A1 66F4
;#A2 6A04
;#A3 6AD9
;#A4 623B
;#A5 6312
;#A6 6AD9
;#A7 691B
;#A8 6158	Is zero
;#A9 6424
;#AA 6AD9
;#AB 6391
;#AC 6AD9
;#AD 6716
;#AE 64C3
;#AF 61F7
;#B0 6A2D
;#B1 63BD
;#B2 6801
;#B3 6A82
;#B4 64CC
;#B5 6AD9
;#B6 6657
;#B7 622B
;#B8 6166
;#B9 6AD9
;#BA 6137	Subtract variable value from variable
;#BB 6AD9
;#BC 65B9
;#BD 63AE
;#BE 66DE
;#BF 6207
;#C0 67B0
;#C1 66F4
;#C2 61CA
;#C3 6724
;#C4 617E
;#C5 6AD9
;#C6 611C	Decrement variable value by 1
;#C7 68FD
;#C8 61A1
;#C9 6AD9
;#CA 6A38
;#CB 6391
;#CC 6A43
;#CD 6AB6
;#CE 6673
;#CF 6233
;#D0 6105	Do nothing
;#D1 695A
;#D2 6819
;#D3 6A68
;#D4 69DA
;#D5 66AC
;#D6 6543
;#D7 6223
;#D8 6AD9
;#D9 6AD9
;#DA 6124	Add variable value to variable
;#DB 63A3
;#DC 662B
;#DD 63AE
;#DE 66DE
;#DF 61FF
;#E0 6889
;#E1 66F4
;#E2 61AC
;#E3 6AD9
;#E4 624C
;#E5 632D
;#E6 6AD9
;#E7 6939
;#E8 6578
;#E9 6424
;#EA 6AD9
;#EB 6391
;#EC 6AD9
;#ED 6716
;#EE 6AD5
;#EF 61F7
;#F0 69AB
;#F1 63BD
;#F2 61D8
;#F3 6409
;#F4 64CC
;#F5 6AD9
;#F6 6653
;#F7 622B
;#F8 618B
;#F9 6AD9
;#FA 6AD9
;#FB 6AD9
;#FC 6562
;#FD 63AE
;#FE 66DE
;#FF 620B

sprite_mask_patterns:
>C:d200  ff fc fc fc  f3 f0 f0 f0  f3 f0 f0 f0  f3 f0 f0 f0
>C:d210  cf cc cc cc  c3 c0 c0 c0  c3 c0 c0 c0  c3 c0 c0 c0
>C:d220  cf cc cc cc  c3 c0 c0 c0  c3 c0 c0 c0  c3 c0 c0 c0
>C:d230  cf cc cc cc  c3 c0 c0 c0  c3 c0 c0 c0  c3 c0 c0 c0
>C:d240  3f 3c 3c 3c  33 30 30 30  33 30 30 30  33 30 30 30
>C:d250  0f 0c 0c 0c  03 00 00 00  03 00 00 00  03 00 00 00
>C:d260  0f 0c 0c 0c  03 00 00 00  03 00 00 00  03 00 00 00
>C:d270  0f 0c 0c 0c  03 00 00 00  03 00 00 00  03 00 00 00
>C:d280  3f 3c 3c 3c  33 30 30 30  33 30 30 30  33 30 30 30
>C:d290  0f 0c 0c 0c  03 00 00 00  03 00 00 00  03 00 00 00
>C:d2a0  0f 0c 0c 0c  03 00 00 00  03 00 00 00  03 00 00 00
>C:d2b0  0f 0c 0c 0c  03 00 00 00  03 00 00 00  03 00 00 00
>C:d2c0  3f 3c 3c 3c  33 30 30 30  33 30 30 30  33 30 30 30
>C:d2d0  0f 0c 0c 0c  03 00 00 00  03 00 00 00  03 00 00 00
>C:d2e0  0f 0c 0c 0c  03 00 00 00  03 00 00 00  03 00 00 00
>C:d2f0  0f 0c 0c 0c  03 00 00 00  03 00 00 00  03 00 00 00

flipped_patterns:
>C:d300  00 40 80 c0  10 50 90 d0  20 60 a0 e0  30 70 b0 f0
>C:d310  04 44 84 c4  14 54 94 d4  24 64 a4 e4  34 74 b4 f4
>C:d320  08 48 88 c8  18 58 98 d8  28 68 a8 e8  38 78 b8 f8
>C:d330  0c 4c 8c cc  1c 5c 9c dc  2c 6c ac ec  3c 7c bc fc
>C:d340  01 41 81 c1  11 51 91 d1  21 61 a1 e1  31 71 b1 f1
>C:d350  05 45 85 c5  15 55 95 d5  25 65 a5 e5  35 75 b5 f5
>C:d360  09 49 89 c9  19 59 99 d9  29 69 a9 e9  39 79 b9 f9
>C:d370  0d 4d 8d cd  1d 5d 9d dd  2d 6d ad ed  3d 7d bd fd
>C:d380  02 42 82 c2  12 52 92 d2  22 62 a2 e2  32 72 b2 f2
>C:d390  06 46 86 c6  16 56 96 d6  26 66 a6 e6  36 76 b6 f6
>C:d3a0  0a 4a 8a ca  1a 5a 9a da  2a 6a aa ea  3a 7a ba fa
>C:d3b0  0e 4e 8e ce  1e 5e 9e de  2e 6e ae ee  3e 7e be fe
>C:d3c0  03 43 83 c3  13 53 93 d3  23 63 a3 e3  33 73 b3 f3
>C:d3d0  07 47 87 c7  17 57 97 d7  27 67 a7 e7  37 77 b7 f7
>C:d3e0  0b 4b 8b cb  1b 5b 9b db  2b 6b ab eb  3b 7b bb fb
>C:d3f0  0f 4f 8f cf  1f 5f 9f df  2f 6f af ef  3f 7f bf ff

;Note that the possible mask values are:
; 00, 01, 04, 05
; 10, 11, 14, 15
; 40, 41, 44, 45
; 50, 51, 54, 55
;
; This means that all the possible nibble values are: 0, 1, 4 and 5.
; 0 = all bits clear
; 1 = bit 0 set
; 4 = bit 2 set
; 5 = bits 0 and 2 set
;
; So for a low nibble, only bits 0 and 2 might be set.
; For the high nibble, bits 4 and 6 might be set accordingly.
; To sum up, only the even bits might be set in these masks.
; Doing the following AND operation: bitmask AND #55 ...
; ...doesn't have any net effect, as it keeps only even bits set.
; This will become relevant in the "apply_mask" subroutine, which uses these masks.
mask_bit_patterns = $d400
mask_bit_patterns:
>C:d400  00 00 00 01  00 00 00 01  00 00 00 01  04 04 04 05
>C:d410  00 00 00 01  00 00 00 01  00 00 00 01  04 04 04 05
>C:d420  00 00 00 01  00 00 00 01  00 00 00 01  04 04 04 05
>C:d430  10 10 10 11  10 10 10 11  10 10 10 11  14 14 14 15
>C:d440  00 00 00 01  00 00 00 01  00 00 00 01  04 04 04 05
>C:d450  00 00 00 01  00 00 00 01  00 00 00 01  04 04 04 05
>C:d460  00 00 00 01  00 00 00 01  00 00 00 01  04 04 04 05
>C:d470  10 10 10 11  10 10 10 11  10 10 10 11  14 14 14 15
>C:d480  00 00 00 01  00 00 00 01  00 00 00 01  04 04 04 05
>C:d490  00 00 00 01  00 00 00 01  00 00 00 01  04 04 04 05
>C:d4a0  00 00 00 01  00 00 00 01  00 00 00 01  04 04 04 05
>C:d4b0  10 10 10 11  10 10 10 11  10 10 10 11  14 14 14 15
>C:d4c0  40 40 40 41  40 40 40 41  40 40 40 41  44 44 44 45
>C:d4d0  40 40 40 41  40 40 40 41  40 40 40 41  44 44 44 45
>C:d4e0  40 40 40 41  40 40 40 41  40 40 40 41  44 44 44 45
>C:d4f0  50 50 50 51  50 50 50 51  50 50 50 51  54 54 54 55

;The sprite row pixel offsets usage starts from index #08 instead of #00
>C:d500  00 00 00 00  00 00 00 00  
sprite_row_offsets_hi:
00 00 00 00  00 00 00 00
>C:d510  00 00 00 01  01 01 01 01  01 01 01 01  01 01 01 01
>C:d520  01 01 01 01  01 01 01 02  02 02 02 02  02 02 02 02
>C:d530  02 02 02 02  02 02 02 02  02 02 02 03  03 03 03 03
>C:d540  03 03 03 03  03 03 03 03  03 03 03 03  03 03 03 04
>C:d550  04 04 04 04  04 04 04 04  04 04 04 04  04 04 04 04
>C:d560  04 04 04 05  05 05 05 05  05 05 05 05  05 05 05 05
>C:d570  05 05 05 05  05 05 05 06  06 06 06 06  06 06 06 06
>C:d580  06 06 06 06  06 06 06 06  06 06 06 07  07 07 07 07
>C:d590  07 07 07 07  07 07 07 07  07 07 07 07  07 07 07 07

>C:d5a0  00 03 06 09  0c 0f 12 15  
sprite_row_offsets_lo:
18 1b 1e 21  24 27 2a 2d
>C:d5b0  30 33 36 39  3c 00 03 06  09 0c 0f 12  15 18 1b 1e   
>C:d5c0  21 24 27 2a  2d 30 33 36  39 3c 00 03  06 09 0c 0f   
>C:d5d0  12 15 18 1b  1e 21 24 27  2a 2d 30 33  36 39 3c 00   
>C:d5e0  03 06 09 0c  0f 12 15 18  1b 1e 21 24  27 2a 2d 30   
>C:d5f0  33 36 39 3c  00 03 06 09  0c 0f 12 15  18 1b 1e 21   
>C:d600  24 27 2a 2d  30 33 36 39  3c 00 03 06  09 0c 0f 12   
>C:d610  15 18 1b 1e  21 24 27 2a  2d 30 33 36  39 3c 00 03   
>C:d620  06 09 0c 0f  12 15 18 1b  1e 21 24 27  2a 2d 30 33   
>C:d630  36 39 3c 00  03 06 09 0c  0f 12 15 18  1b 1e 21 24   

;Offsets for room scene rows, relative to the room scene base
room_scene_row_offsets_lo:
d640:
00 28 50 78 a0 c8 f0 18 
40 68 90 b8 e0 08 30 58   
80 a8 d0 f8 20 48 70 98 c0 

room_scene_row_offsets_hi:
d659:
00 00 00 00 00 00 00 01 
01 01 01 01 01 02 02 02 
02 02 02 02 03 03 03 03 03 

actor_text_color:
01 07 02 0e 08 0f 03 07 07 0f 
01 0d 01 04 05 05 04 03 01 05 
01 01 01 01 

d68a:
07 00 00 27 10 01 01 ff ff 09 08 08 1f 08 ff ff 01 01 09 
;===========================================
prepare_video_for_new_room:
;Hide cursor
.C:d69d  A9 01       LDA #$01
.C:d69f  8D 6C 16    STA hide_cursor
;Make all actors not visible
.C:d6a2  20 CE 3B    JSR clear_actors_visibility_in_scene
.C:d6a5  A9 41       LDA #$41
.C:d6a7  85 15       STA $15
.C:d6a9  A9 F2       LDA #$F2
.C:d6ab  85 16       STA $16
.C:d6ad  20 34 28    JSR reset_talking		;Clear text from top bar?
.C:d6b0  A9 00       LDA #$00
.C:d6b2  A2 00       LDX #$00
.C:d6b4  20 34 D7    JSR do_shutter_effect		
.C:d6b7  20 4B 5F    JSR clear_scene_area
.C:d6ba  20 5B 07    JSR switch_to_frame_buffer_2
;Set synchronization signal and wait for it to be cleared (in irq_handler1)
.C:d6bd  A9 01       LDA #$01
.C:d6bf  85 8E       STA video_update_signal
wait_for_signal_clear:
.C:d6c1  A5 8E       LDA video_update_signal
.C:d6c3  D0 FC       BNE wait_for_signal_clear
.C:d6c5  60          RTS
;===========================================
open_shutter:
.C:d6c6  A9 01       LDA #$01
.C:d6c8  A2 09       LDX #$09
.C:d6ca  20 34 D7    JSR do_shutter_effect
;Show cursor
.C:d6cd  A9 00       LDA #$00
.C:d6cf  8D 6C 16    STA hide_cursor
.C:d6d2  60          RTS
;===========================================
.C:d6d3  A5 B7       LDA $B7
.C:d6d5  D0 1C       BNE $D6F3
.C:d6d7  A5 23       LDA frame_buffer
.C:d6d9  C9 01       CMP #$01
.C:d6db  D0 0B       BNE $D6E8
;---------------------------------------
.C:d6dd  A9 28       LDA #$28
.C:d6df  85 A0       STA $A0
.C:d6e1  A9 C8       LDA #$C8
.C:d6e3  85 A1       STA $A1
.C:d6e5  4C 23 D7    JMP $D723
;---------------------------------------
.C:d6e8  A9 28       LDA #$28
.C:d6ea  85 A0       STA $A0
.C:d6ec  A9 CC       LDA #$CC
.C:d6ee  85 A1       STA $A1
.C:d6f0  4C 23 D7    JMP $D723
;---------------------------------------
.C:d6f3  A5 23       LDA frame_buffer
.C:d6f5  C9 01       CMP #$01
.C:d6f7  D0 13       BNE $D70C
.C:d6f9  A9 28       LDA #$28
.C:d6fb  85 A0       STA $A0
.C:d6fd  A9 CC       LDA #$CC
.C:d6ff  85 A1       STA $A1
.C:d701  A9 28       LDA #$28
.C:d703  85 9E       STA $9E
.C:d705  A9 C8       LDA #$C8
.C:d707  85 9F       STA $9F
.C:d709  4C 1C D7    JMP $D71C
;---------------------------------------
.C:d70c  A9 28       LDA #$28
.C:d70e  85 A0       STA $A0
.C:d710  A9 C8       LDA #$C8
.C:d712  85 A1       STA $A1
.C:d714  A9 28       LDA #$28
.C:d716  85 9E       STA $9E
.C:d718  A9 CC       LDA #$CC
.C:d71a  85 9F       STA $9F
;---------------------------------------
.C:d71c  8A          TXA
.C:d71d  48          PHA
.C:d71e  20 54 18    JSR copy_color_ram_wrapper
.C:d721  68          PLA
.C:d722  AA          TAX
.C:d723  A9 89       LDA #$89
.C:d725  85 A2       STA $A2
.C:d727  A9 6D       LDA #$6D
.C:d729  85 A3       STA $A3
.C:d72b  A9 00       LDA #$00
.C:d72d  85 A4       STA $A4
.C:d72f  A9 D8       LDA #$D8
.C:d731  85 A5       STA $A5
.C:d733  60          RTS
;===========================================
; Possible "shutter opening" effect routine
do_shutter_effect:
.C:d734  85 B7       STA $B7
.C:d736  20 D3 D6    JSR $D6D3
.C:d739  A0 00       LDY #$00
loop1:
.C:d73b  BD 8B D6    LDA $D68B,X
.C:d73e  99 AE 00    STA $00AE,Y
.C:d741  E8          INX
.C:d742  C8          INY
.C:d743  C0 09       CPY #$09
.C:d745  D0 F4       BNE loop1
big_loop:
.C:d747  20 BA D7    JSR $D7BA
.C:d74a  A6 AE       LDX $AE
.C:d74c  A4 AF       LDY $AF
.C:d74e  20 8E D7    JSR $D78E
loop2:
.C:d751  E4 B0       CPX $B0
.C:d753  F0 07       BEQ $D75C
.C:d755  20 8E D7    JSR $D78E
.C:d758  E8          INX
.C:d759  4C 51 D7    JMP loop2
loop3:
.C:d75c  C4 B1       CPY $B1
.C:d75e  F0 07       BEQ $D767
.C:d760  20 8E D7    JSR $D78E
.C:d763  C8          INY
.C:d764  4C 5C D7    JMP loop3
loop4:
.C:d767  E4 AE       CPX $AE
.C:d769  F0 07       BEQ $D772
.C:d76b  20 8E D7    JSR $D78E
.C:d76e  CA          DEX
.C:d76f  4C 67 D7    JMP loop4
loop5:
.C:d772  C4 AF       CPY $AF
.C:d774  F0 07       BEQ $D77D
.C:d776  20 8E D7    JSR $D78E
.C:d779  88          DEY
.C:d77a  4C 72 D7    JMP loop5
.C:d77d  A2 03       LDX #$03
loop6:
.C:d77f  18          CLC
.C:d780  B5 AE       LDA $AE,X
.C:d782  75 B2       ADC $B2,X
.C:d784  95 AE       STA $AE,X
.C:d786  CA          DEX
.C:d787  10 F6       BPL loop6
.C:d789  C6 B6       DEC $B6
.C:d78b  D0 BA       BNE big_loop
.C:d78d  60          RTS
;===========================================
.C:d78e  98          TYA
.C:d78f  48          PHA
.C:d790  8A          TXA
.C:d791  48          PHA
.C:d792  A2 02       LDX #$02
loop1:
.C:d794  B5 9E       LDA $9E,X
.C:d796  18          CLC
.C:d797  79 BA 3E    ADC screen_row_offsets_lo,Y
.C:d79a  95 A6       STA $A6,X
.C:d79c  B5 9F       LDA $9F,X
.C:d79e  79 A1 3E    ADC screen_row_offsets_hi,Y
.C:d7a1  95 A7       STA $A7,X
.C:d7a3  CA          DEX
.C:d7a4  CA          DEX
.C:d7a5  10 ED       BPL loop1
.C:d7a7  68          PLA
.C:d7a8  AA          TAX
.C:d7a9  A8          TAY
.C:d7aa  A5 B7       LDA $B7
.C:d7ac  D0 05       BNE $D7B3
.C:d7ae  91 A8       STA ($A8),Y
.C:d7b0  4C B7 D7    JMP $D7B7
.C:d7b3  B1 A6       LDA ($A6),Y
.C:d7b5  91 A8       STA ($A8),Y
.C:d7b7  68          PLA
.C:d7b8  A8          TAY
.C:d7b9  60          RTS
;===========================================
.C:d7ba  A2 00       LDX #$00
;Do raster setup until it's no longer needed
raster_setup_check:
.C:d7bc  A5 96       LDA raster_setup_needed
.C:d7be  F0 06       BEQ set_irq_handler1_signal
.C:d7c0  20 1C 34    JSR raster_setup
.C:d7c3  4C BC D7    JMP raster_setup_check
set_irq_handler1_signal:
.C:d7c6  A9 01       LDA #$01
.C:d7c8  8D 6B 16    STA irq_handler1_video_processed_signal
wait_for_irq_handler1_signal_to_clear:
.C:d7cb  AD 6B 16    LDA irq_handler1_video_processed_signal
.C:d7ce  D0 FB       BNE wait_for_irq_handler1_signal_to_clear
.C:d7d0  CA          DEX
.C:d7d1  10 F3       BPL set_irq_handler1_signal
.C:d7d3  60          RTS
;===========================================
; Get a random number
; 
; Arguments:	.X	seed
;===========================================
random_4 = $e1
random_5 = $e2

get_random_number:
.C:d7d4  A0 07       LDY #$07
rotate_and_xor:
.C:d7d6  A5 DD       LDA random_1
.C:d7d8  0A          ASL A
.C:d7d9  45 DE       EOR random_2
.C:d7db  0A          ASL A
.C:d7dc  26 DD       ROL random_1
.C:d7de  26 DE       ROL random_2
.C:d7e0  26 DF       ROL random_3
.C:d7e2  88          DEY
.C:d7e3  10 F1       BPL rotate_and_xor
;--------------------------------------
.C:d7e5  A5 DF       LDA random_3
.C:d7e7  85 E2       STA random_5
.C:d7e9  86 E1       STX random_4
.C:d7eb  A9 00       LDA #$00
.C:d7ed  F0 04       BEQ zero
carry:
.C:d7ef  46 E1       LSR random_4
.C:d7f1  65 E1       ADC random_4
zero:
.C:d7f3  06 E2       ASL random_5
.C:d7f5  B0 F8       BCS carry
.C:d7f7  46 E1       LSR random_4
.C:d7f9  D0 F8       BNE zero
.C:d7fb  60          RTS
;===========================================

>C:f040  00 10 00 00  10 00 00 10  00 00 10 00  00 92 00 00   ................
>C:f050  7c 00 00 38  00 10 10 10  08 00 20 0c  00 60 fe 00   |..8...... ..`..
>C:f060  fe 0c 00 60  08 00 20 10  10 10 00 38  00 00 7c 00   ...`.. ....8..|.
>C:f070  00 92 00 00  10 00 00 10  00 00 10 00  00 10 00 00   ................
>C:f080  00 00 00 00  00 00 cc 00  00 88 00 00  88 00 00 48   ...............H
>C:f090  03 e0 68 0f  f8 38 1e 3c  7c 1d de 7e  3d ef 07 5e   ..h..8.<|..~=..^
>C:f0a0  6f 03 d7 df  01 c8 3f 01  ef fe 00 df  fd 00 3f fb   o.....?.......?.
>C:f0b0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00

character_sprite_bkg_colors:
>C:f0c0  00 07 02 06  09 01 03 07  07 01 01 09  01 04 05 05
>C:f0d0  04 01 00 05  04 02 02 07  07 00 

;------------------------------------------------
; Character animation settings
;
;Bit 7 represents whether a character animates its mouth when speaking (0 = it animates)
;Bit 6 represents the same thing, but it's used in a different routine (print_msg_for_actor)
;Bits 5-0 represent the sound to be played when walking (footsteps)
;Note that Jeff has #00 as he's barefoot
;
;00 - Has speaking animation, no sound played when walking
;06 - Has speaking animation, sound 6 played when walking (footsteps)
;46 - No speaking animation, sound 6 played when walking (footsteps)
;C0 - No speaking animation, no sound played when walking
;FF - No speaking animation, sound #3F played when walking
;------------------------------------------------
f0d9 
character_animation_settings: 
00 
06 06 06 06 06 06 00 	;Kids (Jeff has #00)
46 						;Radiation suit
06 06 06 06 			;Fred, Edna, Ed, Ted
ff ff					;Purple and green tentacles 
06  					;Meteor police
c0 						;Meteor
06 06 					;Mark Eteer, Talkshow host
00 						;Chuck the Plant
c0 c0 					;Meteor radiation, Edsel car
00 						;Meteor
06 06 					;Sandy

;Word pointers to character names
;Note: Pointers to "Dr Fred" (f14e) and "Meteor" (f199) are repeated twice
;		"Plant" is repeated 3 times (f1a0)
;		"Sandy" is repeated 4 times (f1a6)
f0f2	character_names_hi ;(24 in total - from " " to "Sandy")
f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 f1 

f10a	character_names_lo
22 24 28 2e 33 3b 43 49 4e 4e 56 61 6a 7a 8a 99 99 a0 a0 a0 a6 a6 a6 a6 
;f122	0	" "
;f124	1	"Syd"
;f128	2	"Razor"
;f12e	3	"Dave"
;f133	4	"Michael"
;f13b	5	"Bernard"
;f143	6	"Wendy"
;f149	7	"Jeff"
;f14e	8	"Dr Fred"
;f14e	9	"Dr Fred"
;f156	A	"Nurse Edna"
;f161	B	"Weird Ed"
;f16a	C	"Dead Cousin Ted"
;f17a	D	"Purple Tentacle"
;f18a	E	"Green Tentacle"
;f199	F	"Meteor"
;f199	10	"Meteor"
;f1a0	11	"Plant"
;f1a0	12	"Plant"
;f1a0	13	"Plant"		- This seems to be the only plant actor used in scripts
;f1a6	14	"Sandy"
;f1a6	15	"Sandy"
;f1a6	16	"Sandy"		- Sandy in talk show and in the lab
;f1a6	17	"Sandy"		- Sandy

;

f122: 20 00  ;" "
f124: 53 79 64 00  ;"Syd"
f128: 52 61 7a 6f 72 00  ;"Razor"
f12e: 44 61 76 65 00 ;"Dave"
f133: 4d 69 63 68 61 65 6c 00 ;"Michael"
f13b: 42 65 72 6e 61 72 64 00 ;"Bernard"
f143: 57 65 6e 64 79 00 ;"Wendy"
f149: 4a 65 66 66 00 ;"Jeff"
f14e: 44 72 20 46 72 65 64 00 ;"Dr Fred"
f156: 4e 75 72 73 65 20 45 64 6e 61 00 ;"Nurse Edna"
f161: 57 65 69 72 64 20 45 64 00 ;"Weird Ed"
f16a: 44 65 61 64 20 43 6f 75 73 69 6e 20 54 65 64 00 ;"Dead Cousin Ted"
f17a: 50 75 72 70 6c 65 20 54 65 6e 74 61 63 6c 65 00 ;"Purple Tentacle"
f18a: 47 72 65 65 6e 20 54 65 6e 74 61 63 6c 65 00 ;"Green Tentacle"
f199: 4d 65 74 65 6f 72 00 ;"Meteor"
f1a0: 50 6c 61 6e 74 00 ;"Plant"
f1a6: 53 61 6e 64 79 00 ;"Sandy"


   
>C:f1a0    4f 70 65 6e   Plant.Sandy
;.Open
>C:f1b0  00 43 6c 6f  73 65 00 47  69 76 65 00  54 75 72 6e   .Close.Give.Turn
>C:f1c0  20 6f 6e 00  54 75 72 6e  20 6f 66 66  00 46 69 78    on.Turn off.Fix
>C:f1d0  00 4e 65 77  20 4b 69 64  00 55 6e 6c  6f 63 6b 00   .New Kid.Unlock.
>C:f1e0  50 75 73 68  00 50 75 6c  6c 00 55 73  65 00 52 65   Push.Pull.Use.Re
>C:f1f0  61 64 00 57  61 6c 6b 20  74 6f 00 50  69 63 6b 20   ad.Walk to.Pick 
>C:f200  75 70 00 57  68 61 74 20  69 73 00 				  up.What is

f20b	verb_pointers_hi	;(15 in total)
f21b	verb_pointers_lo
f22b	preposition_pointers_hi
f22e	preposition_pointers_lo

f20B f1 f1 f1 f1   ......
>C:f210  f1 f1 f1 f1  f1 f1 f1 f1  f1 f1 f2 00  ac b1 b7 bc   ................
>C:f220  c4 cd d1 d9  e0 e5 ea ee  f3 fb 03 f2  f2 f2 f2 33   ...............3
>C:f230  36 3b 3e 69  6e 00 77 69  74 68 00 6f  6e 00 74 6f   6;>in.with.on.to
>C:f240  00 20 00 01  12 00 28 00  00 12 13 00  28 04 00 13   

;------------------------------------------------
;Values of CB88 (interaction_region)
;------------------------------------------------
;00 = Upper half of screen (room + top bar)
;06 = Action bar
;0C = "Push" verb
;12 = "Open" verb
;18 = "Walk to" verb
;1E = "New kid" verb
;24 = "Turn on" verb
;2A = "Pull" verb
;30 = "Close" verb
;36 = "Pick up" verb
;3C = "Unlock" verb
;42 = "Turn off" verb
;48 = "Give" verb
;4E = "Read" verb
;54 = "What is" verb
;5A = "Use" verb
;60 = "Fix" verb
;66 = top left inventory item
;6C = scroll up inventory arrow
;72 = top right inventory item
;78 = bottom left inventory item
;7E = scroll down inventory arrow
;84 = bottom right inventory item

;Max index = 84

;------------------------------------------------
;Interaction region handlers
;------------------------------------------------
;Contains data to handle the cursor entering each of the specific regions in the "interaction" area.
;That is, everything from the action bar to the bottom of the screen.
;The specific region indexes are enumerated above (from 00-84).
;Each element takes 6 bytes.
;
;	Offset		Purpose
;	0			Lower character row
;	1			Upper character row
;	2			Lower character column
;	3			Upper character column
;	4			Index to routine handlers
;	5			For a verb: the associated verb index
;				For an inventory item:	the associated visible item index (0-3)
;				For a scroll arrow: the direction of scroll (0 = up, 1 = down)

; The interaction handler indexes are:
;
;	Upper half of screen	0		
;	Verbs					1
;	Inventory items			2
;	Inventory scroll		3
;	Action bar				4
int_region_start_row = $f243
int_region_end_row = $f244
int_region_start_col = $f245
int_region_end_col = $f246
interaction_region_handlers = $f247
int_region_operand = $f248

f243:
01 12 
00 28
00 00 ;Upper half of screen

12 13 
00 28 
04 00 ;Action bar

13 14 
00 08 
01 09 ;"Push" verb

13 14 
08 0f 
01 01 ;"Open" verb

13 14 
0f 18 
01 0d ;"Walk to" verb

13 14 
18 20 
01 07 ;"New kid" verb

13 14 
20 28 
01 04 ;"Turn on" verb

14 15 
00 08 
01 0a ;"Pull" verb

14 15 
08 0f 
01 02 ;"Close" verb

14 15 
0f 18 
01 0e ;"Pick up" verb

14 15 
18 20 
01 08 ;"Unlock" verb

14 15 
20 28 
01 05 ;"Turn off" verb

15 16 
00 08 
01 03 ;"Give" verb

15 16 
08 0f 
01 0c ;"Read" verb

15 16 
0f 18 
01 0f ;"What is" verb

15 16 
18 20 
01 0b ;"Use" verb

15 16 
20 28 
01 06 ;"Fix" verb

16 17 
00 12 
02 00 ;top left inventory item 

16 17 
12 16 
03 00 ;scroll up inventory arrow

16 17 
16 28 
02 01 ;top right inventory item

17 18 
00 12 
02 02 ;bottom left inventory item

17 18 
12 16 
03 01 ;scroll down inventory arrow 

17 18 
16 28 
02 03 ;bottom right inventory item

region_normal_colors = $f2cd
f2cd:
00 05 04 06 04

region_highlight_colors = $f2d2
f2d2:
00 07 07 07 07 

cursor_physics_for_region = $f2d7
f2d7:
01 00 00 00 00

f2dc: 20 01 02 00
f2e0: 20 03 04 00  

f2e4:
;f2dc
;f2e0

region_highlight_handlers = $f2e8
region_highlight_handlers:
;f3e8	0			do_nothing
;f3e9	1			highlight_colors
;f3e9	2			highlight_colors
;f3e9	3			highlight_colors
;f3e9	4			highlight_colors

click_handlers = $f2f2
click_handlers:
;f427		0		handle_click_on_upper_half_region
;f42d		1		handle_click_on_verb
;f452		2		handle_click_on_inventory_item
;f48f		3		handle_click_on_inventory_scroll_arrow
;f44d		4		handle_click_on_action_bar

region_dehighlight_handlers = $f2fc
region_dehighlight_handlers:
	; f3e8		0		do_nothing
	; f3f8		1		dehighlight_colors
	; f3f8		2		dehighlight_colors
	; f3f8		3		dehighlight_colors
	; f3f8		4		dehighlight_colors
	
region_entry_handlers = $f306
region_entry_handlers:
	; f3e8		0		do_nothing
	; f407		1		handle_verb_region_entry
	; f40d		2		handle_inventory_item_region_entry
	; f413		3		handle_inventory_scroll_region_entry
	; f419		4		handle_action_bar_region_entry

;	Upper half of screen	0		
;	Verbs					1
;	Inventory items			2
;	Inventory scroll		3
;	Action bar				4

h_acceleration_masks:
f310: FA FA
v_acceleration_masks:
f312: FF FF
cursor_drag_powers:
f314: 07 07

OUT_OF_BOUNDS_REGION = #$8A
;===========================================
handle_cursor_and_interaction_area:
.C:f316  20 B6 F6    JSR update_cursor_speed
.C:f319  20 49 F6    JSR update_cursor_fraction_coords
.C:f31c  20 5C F6    JSR get_interaction_region
.C:f31f  EC 88 CB    CPX interaction_region
.C:f322  F0 44       BEQ check_for_click
.C:f324  8A          TXA
.C:f325  48          PHA
.C:f326  A9 00       LDA #$00
.C:f328  8D 8A CB    STA button_presses
;---------------------------------------
;Handle region exit to dehighlight text
.C:f32b  AE 88 CB    LDX interaction_region
.C:f32e  E0 8A       CPX OUT_OF_BOUNDS_REGION
.C:f330  F0 14       BEQ $F346
.C:f332  BD 47 F2    LDA interaction_region_handlers,X
.C:f335  0A          ASL A
.C:f336  A8          TAY
;Inline subroutine address
.C:f337  B9 FC F2    LDA region_dehighlight_handlers,Y
.C:f33a  8D 44 F3    STA <inlined_dehighlight_handler
.C:f33d  B9 FD F2    LDA region_dehighlight_handlers+1,Y
.C:f340  8D 45 F3    STA >inlined_dehighlight_handler
inlined_dehighlight_handler = $f344
.C:f343  20 00 00    JSR $0000		;Inlined address
.C:f346  68          PLA
.C:f347  8D 88 CB    STA interaction_region
;---------------------------------------
;Handle region's cursor physics (acceleration and drag) 
.C:f34a  20 DA F7    JSR set_cursor_physics
;---------------------------------------
;Handle region entry to highlight text
.C:f34d  AE 88 CB    LDX interaction_region
.C:f350  E0 8A       CPX OUT_OF_BOUNDS_REGION
.C:f352  F0 14       BEQ check_for_click
.C:f354  BD 47 F2    LDA interaction_region_handlers,X
.C:f357  0A          ASL A
.C:f358  A8          TAY
;Inline subroutine address
.C:f359  B9 E8 F2    LDA region_highlight_handlers,Y
.C:f35c  8D 66 F3    STA <inlined_highlight_handler
.C:f35f  B9 E9 F2    LDA region_highlight_handlers+1,Y
.C:f362  8D 67 F3    STA >inlined_highlight_handler
inlined_highlight_handler = $f366
.C:f365  20 00 00    JSR $0000		;Inlined address
;---------------------------------------
;Handle button click
check_for_click:
.C:f368  20 CB F7    JSR handle_joystick_button
.C:f36b  F0 1E       BEQ exit
.C:f36d  AE 88 CB    LDX interaction_region
.C:f370  E0 8A       CPX OUT_OF_BOUNDS_REGION
.C:f372  F0 14       BEQ exit
.C:f374  BD 47 F2    LDA interaction_region_handlers,X
.C:f377  0A          ASL A
.C:f378  A8          TAY
;Inline subroutine address
.C:f379  B9 F2 F2    LDA click_handlers,Y
.C:f37c  8D 86 F3    STA <inlined_click_handler
.C:f37f  B9 F3 F2    LDA click_handlers+1,Y
.C:f382  8D 87 F3    STA >inlined_click_handler		
inlined_click_handler = $f386
.C:f385  20 00 00    JSR $0000	;Inlined address
.C:f388  EE 8A CB    INC button_presses
exit:
.C:f38b  60          RTS
;===========================================
; Invokes the draw/entry region handler
; for each interaction region.
;===========================================
draw_all_regions:
;Start with region #00
.C:f38c  A9 00       LDA #$00
.C:f38e  8D 88 CB    STA interaction_region
draw_region:
;Sanity check for out of bounds (unnecessary)
.C:f391  AE 88 CB    LDX interaction_region
.C:f394  E0 8A       CPX OUT_OF_BOUNDS_REGION
.C:f396  F0 14       BEQ next_region
;Load the region handler index
.C:f398  BD 47 F2    LDA interaction_region_handlers,X
.C:f39b  0A          ASL A
.C:f39c  A8          TAY
;Inline subroutine address
.C:f39d  B9 06 F3    LDA region_entry_handlers,Y
.C:f3a0  8D AA F3    STA <inlined_region_handler
.C:f3a3  B9 07 F3    LDA region_entry_handlers+1,Y
.C:f3a6  8D AB F3    STA >inlined_region_handler
inlined_region_handler = $f3aa
;Invoke the handler
.C:f3a9  20 00 00    JSR $0000			;Inlined address
next_region:
;Move to next region
.C:f3ac  18          CLC
.C:f3ad  AD 88 CB    LDA interaction_region
.C:f3b0  69 06       ADC #$06
.C:f3b2  8D 88 CB    STA interaction_region
;If we reached the end, exit to the cursor physics routine
.C:f3b5  C9 8A       CMP OUT_OF_BOUNDS_REGION
.C:f3b7  D0 D8       BNE draw_region
.C:f3b9  4C DA F7    JMP set_cursor_physics
;===========================================
; Returns:
;		.A
;		.X
;		.Y
;===========================================
; If cursor_y_pixel >= 90, cursor_y_pixel++
; If cursor_y_pixel >= 8, cursor_y_pixel++
; Y = cursor_y_pixel + 28
.C:f3bc  AD 81 CB    LDA cursor_y_pixel
.C:f3bf  C9 90       CMP #$90
.C:f3c1  69 00       ADC #$00
.C:f3c3  C9 08       CMP #$08
.C:f3c5  69 00       ADC #$00
.C:f3c7  69 28       ADC #$28
.C:f3c9  A8          TAY
;$cb8c = $cb7e + 80
.C:f3ca  18          CLC
.C:f3cb  AD 7E CB    LDA $cb7e
.C:f3ce  69 80       ADC #$80
.C:f3d0  8D 8C CB    STA $cb8c
;$cb8d = cursor_x_pixel + 6
.C:f3d3  AD 7F CB    LDA cursor_x_pixel
.C:f3d6  69 06       ADC #$06
.C:f3d8  8D 8D CB    STA $cb8d
; X = cursor_x * 2
.C:f3db  AD 8C CB    LDA $cb8c
.C:f3de  0A          ASL A
.C:f3df  AD 8D CB    LDA $cb8d
.C:f3e2  2A          ROL A
.C:f3e3  AA          TAX
; A = carry of cursor_x * 2
.C:f3e4  A9 00       LDA #$00
.C:f3e6  2A          ROL A
.C:f3e7  60          RTS
;===================================================
do_nothing:
.C:f3e8  60          RTS
;===================================================
highlight_colors:
.C:f3e9  AE 88 CB    LDX interaction_region
.C:f3ec  BC 47 F2    LDY interaction_region_handlers,X
.C:f3ef  B9 D2 F2    LDA region_highlight_colors,Y
.C:f3f2  8D 8F CB    STA region_text_color
.C:f3f5  4C 0A F6    JMP update_region_color
;===================================================
dehighlight_colors:
.C:f3f8  AE 88 CB    LDX interaction_region
.C:f3fb  BC 47 F2    LDY interaction_region_handlers,X
.C:f3fe  B9 CD F2    LDA region_normal_colors,Y
.C:f401  8D 8F CB    STA region_text_color
.C:f404  4C 0A F6    JMP update_region_color
;===================================================
handle_verb_region_entry:
.C:f407  20 30 F5    JSR copy_verb_to_region
.C:f40a  4C F8 F3    JMP dehighlight_colors
;===================================================
handle_inventory_item_region_entry:
.C:f40d  20 43 F5    JSR copy_item_to_region
.C:f410  4C F8 F3    JMP dehighlight_colors
;===================================================
handle_inventory_scroll_region_entry:
.C:f413  20 F7 F4    JSR display_inventory_arrows
.C:f416  4C F8 F3    JMP dehighlight_colors
;===================================================
handle_action_bar_region_entry:
;Point source to $F609, which contains a #00 
;Thus copying an empty string
.C:f419  A9 09       LDA #$09
.C:f41b  85 C5       STA $C5
.C:f41d  A9 F6       LDA #$F6
.C:f41f  85 C6       STA $C6
.C:f421  20 BB F5    JSR copy_data_to_int_region
.C:f424  4C F8 F3    JMP dehighlight_colors
;===================================================
handle_click_on_upper_half_region:
.C:f427  A9 01       LDA #$01
.C:f429  8D 77 FD    STA room_scene_clicked
.C:f42c  60          RTS
;===================================================
handle_click_on_verb:
;Fetch verb for the interaction region
.C:f42d  AE 88 CB    LDX interaction_region
.C:f430  BD 48 F2    LDA int_region_operand,X
;Set it as the current verb
.C:f433  8D 1F FE    STA current_verb
.C:f436  AD 8A CB    LDA button_presses
.C:f439  F0 07       BEQ reset_sentence_queue_system
;Rebuild the action sentence
.C:f43b  A9 01       LDA #$01
.C:f43d  85 95       STA rebuild_action_sentence
.C:f43f  4C 47 F4    JMP refresh_sentence
reset_sentence_queue_system:
;Reset the sentence queue
.C:f442  A9 01       LDA #$01
.C:f444  8D 8F FE    STA reset_sentence_queue_system_flag
refresh_sentence:
.C:f447  A9 01       LDA #$01
.C:f449  8D 49 FE    STA refresh_sentence_bar_flag
.C:f44c  60          RTS
;===================================================
handle_click_on_action_bar:
;Rebuild the action sentence
.C:f44d  A9 01       LDA #$01
.C:f44f  85 95       STA rebuild_action_sentence
.C:f451  60          RTS
;===================================================
handle_click_on_inventory_item:
.C:f452  AE 88 CB    LDX interaction_region
.C:f455  BD 48 F2    LDA int_region_operand,X
.C:f458  20 73 F5    JSR check_item_in_possession
.C:f45b  B0 23       BCS item_not_in_possession
;Item is in possession
.C:f45d  A0 00       LDY #$00
.C:f45f  AD 22 FE    LDA preposition
.C:f462  D0 09       BNE $F46D
.C:f464  8E 20 FE    STX direct_object_idx_lo
.C:f467  8C 21 FE    STY direct_object_idx_hi
.C:f46a  4C 80 F4    JMP $F480
:
.C:f46d  EC 20 FE    CPX direct_object_idx_lo
.C:f470  D0 08       BNE $F47A
.C:f472  CC 21 FE    CPY direct_object_idx_hi
.C:f475  D0 03       BNE $F47A
.C:f477  4C 80 F4    JMP $F480
:
.C:f47a  8E 23 FE    STX indirect_object_idx_lo
.C:f47d  8C 24 FE    STY indirect_object_idx_hi
item_not_in_possession:
.C:f480  AD 8A CB    LDA button_presses
.C:f483  F0 04       BEQ $F489
.C:f485  A9 01       LDA #$01
.C:f487  85 95       STA rebuild_action_sentence
:
.C:f489  A9 01       LDA #$01
.C:f48b  8D 49 FE    STA refresh_sentence_bar_flag
.C:f48e  60          RTS
;===================================================
; Handles a click on the inventory scroll arrows.
; Updates the display offset and then redraws
; the inventory items and scroll arrows.
;===================================================
handle_click_on_inventory_scroll_arrow:
.C:f48f  AE 88 CB    LDX interaction_region
;The operand will be #00 if scroll up is clicked, #01 if scroll down is clicked
.C:f492  BD 48 F2    LDA int_region_operand,X
.C:f495  D0 03       BNE scroll_down
.C:f497  4C A6 F4    JMP scroll_up
scroll_down:
;Add 2 to the item display offset
.C:f49a  18          CLC
.C:f49b  AD 8B CB    LDA inv_display_item_offset
.C:f49e  69 02       ADC #$02
.C:f4a0  8D 8B CB    STA inv_display_item_offset
.C:f4a3  4C B3 F4    JMP update_items_displayed
scroll_up:
;Subtract 2 from item display offset
.C:f4a6  38          SEC
.C:f4a7  AD 8B CB    LDA inv_display_item_offset
.C:f4aa  E9 02       SBC #$02
;If the subtraction yielded negative, set it to #00
.C:f4ac  10 02       BPL set_display_offset
.C:f4ae  A9 00       LDA #$00
set_display_offset:
.C:f4b0  8D 8B CB    STA inv_display_item_offset
;Fall through to next routine
;===================================================
; Updates the inventory items being displayed.
; Display scroll arrows as applicable.
;===================================================
update_items_displayed:
;Count how many items are in the inventory
.C:f4b3  20 99 F5    JSR count_items_in_inventory
;Subtract 4 from the count
.C:f4b6  38          SEC
.C:f4b7  E9 04       SBC #$04
.C:f4b9  10 02       BPL clamp_offset
;If the result is negative, set the display item offset to #00
.C:f4bb  A9 00       LDA #$00
clamp_offset:
.C:f4bd  CD 8B CB    CMP inv_display_item_offset
.C:f4c0  10 03       BPL save_region
.C:f4c2  8D 8B CB    STA inv_display_item_offset
save_region:
;Save region in stack
.C:f4c5  AD 88 CB    LDA interaction_region
.C:f4c8  48          PHA
;The underlying idea is to scan through ALL regions,
;filter those that are either an item or a scroll arrow,
;and display those as applicable
;
;Set region to #00 as we will scan through every region and its handler
.C:f4c9  A9 00       LDA #$00
.C:f4cb  8D 88 CB    STA interaction_region
check_region:
;Get the region and its handler
.C:f4ce  AE 88 CB    LDX interaction_region
.C:f4d1  BD 47 F2    LDA interaction_region_handlers,X
;Is it of type #02? That is, is it an inventory item?
.C:f4d4  C9 02       CMP #$02
.C:f4d6  D0 06       BNE check_arrow
;If so, copy the item's text to the region
.C:f4d8  20 43 F5    JSR copy_item_to_region
.C:f4db  4C E5 F4    JMP next_region
check_arrow:
;Is it of type #03? That is, is it an inventory scroll arrow?
.C:f4de  C9 03       CMP #$03
.C:f4e0  D0 03       BNE next_region
;If so, display the arrows as needed
.C:f4e2  20 F7 F4    JSR display_inventory_arrows
next_region:
;Add 6 to point to the next region
.C:f4e5  18          CLC
.C:f4e6  AD 88 CB    LDA interaction_region
.C:f4e9  69 06       ADC #$06
.C:f4eb  8D 88 CB    STA interaction_region
;Check if we reached the end - otherwise, continue
.C:f4ee  C9 8A       CMP OUT_OF_BOUNDS_REGION
.C:f4f0  D0 DC       BNE check_region
;Recover region from stack
.C:f4f2  68          PLA
.C:f4f3  8D 88 CB    STA interaction_region
.C:f4f6  60          RTS
;===================================================
source = $C5
display_inventory_arrows:
.C:f4f7  AE 88 CB    LDX interaction_region
.C:f4fa  BC 48 F2    LDY int_region_operand,X
.C:f4fd  D0 08       BNE $F507
.C:f4ff  AD 8B CB    LDA inv_display_item_offset
.C:f502  C9 01       CMP #$01
.C:f504  4C 10 F5    JMP $F510
:
.C:f507  20 99 F5    JSR count_items_in_inventory
.C:f50a  38          SEC
.C:f50b  ED 8B CB    SBC inv_display_item_offset
.C:f50e  C9 05       CMP #$05
:
.C:f510  90 13       BCC empty_string
.C:f512  AE 88 CB    LDX interaction_region
.C:f515  BC 48 F2    LDY int_region_operand,X
.C:f518  B9 E4 F2    LDA $F2E4,Y
.C:f51b  85 C5       STA $C5
.C:f51d  B9 E6 F2    LDA $F2E6,Y
.C:f520  85 C6       STA $C6
.C:f522  4C 2D F5    JMP copy_and_exit
empty_string:
;Point source to $F609, which contains a #00 
;Thus copying an empty string
.C:f525  A9 09       LDA #$09
.C:f527  85 C5       STA $C5
.C:f529  A9 F6       LDA #$F6
.C:f52b  85 C6       STA $C6
copy_and_exit:
.C:f52d  4C BB F5    JMP copy_data_to_int_region
;===================================================
; Copies the text of the region's verb to the appropriate
; place in the video memory
;
; 	Arguments:	interaction_region
;===================================================
source = $C5

copy_verb_to_region:
;Fetch region and region's operand
.C:f530  AE 88 CB    LDX interaction_region
.C:f533  BC 48 F2    LDY int_region_operand,X
;The operand is the verb index
;Point to the verb's text
.C:f536  B9 1B F2    LDA verb_pointers_lo,Y
.C:f539  85 C5       STA <source
.C:f53b  B9 0B F2    LDA verb_pointers_hi,Y
.C:f53e  85 C6       STA >source
.C:f540  4C BB F5    JMP copy_data_to_int_region
;===================================================
; Copies the text of the item's name to the appropriate
; place in the video memory
;
; 	Arguments:	interaction_region
;===================================================
source = $C5

copy_item_to_region:
.C:f543  AE 88 CB    LDX interaction_region
.C:f546  BD 48 F2    LDA int_region_operand,X
.C:f549  20 73 F5    JSR check_item_in_possession
.C:f54c  90 0B       BCC item_in_possession
;Item NOT in possession
;Point source to $F609, which contains a #00 
;Thus copying an empty string
.C:f54e  A9 09       LDA #$09
.C:f550  85 C5       STA <source
.C:f552  A9 F6       LDA #$F6
.C:f554  85 C6       STA >source
.C:f556  4C 70 F5    JMP exit
item_in_possession:
.C:f559  B9 5E 70    LDA object_rsrc_ptrs_lo,Y
.C:f55c  85 C5       STA <source
.C:f55e  B9 8B 70    LDA object_rsrc_ptrs_hi,Y
.C:f561  85 C6       STA >source
;Read the object name's offset from offset #0D
.C:f563  A0 0D       LDY #$0D
.C:f565  18          CLC
.C:f566  A5 C5       LDA <source
;Add it to the source pointer
.C:f568  71 C5       ADC (source),Y
.C:f56a  85 C5       STA <source
.C:f56c  90 02       BCC exit
.C:f56e  E6 C6       INC >source
exit:
.C:f570  4C BB F5    JMP copy_data_to_int_region
;===================================================
; Checks if an inventory item is in possession of the current kid
;
; Argument:	.A	Inventory item in display index
;				0 - top left
;				1 - top right
;				2 - bottom left
;				3 - bottom right
;
; Returns:	Carry set		if item is NOT in possession
;			Carry clear		if item is in possession
;===================================================
counter = $cb8c
check_item_in_possession:
;Add the "item displayed" index (0-3) to the item offset (the item index of the top left item)
.C:f573  18          CLC
.C:f574  6D 8B CB    ADC inv_display_item_offset
.C:f577  8D 8C CB    STA counter
;Scan through all items starting from #00
.C:f57a  A0 00       LDY #$00
check_possession:
;Fetch item ID
.C:f57c  BE 31 70    LDX inventory_objects,Y	;Items that can be picked up?
;Is it #00? If so, skip
.C:f57f  F0 11       BEQ next_item
;Fetch attributes for the item
.C:f581  BD 01 73    LDA object_attributes,X	;Item attributes
;Get the low nibble, which represents which character ID possesses the item
.C:f584  29 0F       AND #$0F		
;Is it the current kid?
.C:f586  CD 67 FF    CMP current_kid
;If not, skip
.C:f589  D0 07       BNE next_item
;If it is, count down
.C:f58b  CE 8C CB    DEC counter
;Have we finished the count? If not, continue with next item
.C:f58e  10 02       BPL next_item
;Item in possession - return with carry clear
.C:f590  18          CLC
.C:f591  60          RTS
next_item:
.C:f592  C8          INY
;Have we reached the max item ID?
.C:f593  C0 2D       CPY #$2D	
;If not, check if item is in possession
.C:f595  D0 E5       BNE check_possession
;We reached the max item ID, so item is NOT in possessions
;Return with carry set
.C:f597  38          SEC
.C:f598  60          RTS
;===================================================
; Count the total items in inventory
;
; Returns:	.A	# of items in inventory
;===================================================
counter = $cb8c

count_items_in_inventory:
.C:f599  A9 00       LDA #$00
.C:f59b  8D 8C CB    STA counter
.C:f59e  A0 00       LDY #$00
check_item:
;Get item ID - if it's #00, skip
.C:f5a0  BE 31 70    LDX inventory_objects,Y
.C:f5a3  F0 0D       BEQ next_item
;Get item's attributes
.C:f5a5  BD 01 73    LDA object_attributes,X
;Check if they are in the current kid's inventory
.C:f5a8  29 0F       AND #$0F
.C:f5aa  CD 67 FF    CMP current_kid
;If not, skip
.C:f5ad  D0 03       BNE next_item
;They are in the inventory, so increment the counter
.C:f5af  EE 8C CB    INC counter
next_item:
;Move to next Item ID
.C:f5b2  C8          INY
;Did we reach the max item ID? If so, exit; otherwise, loop
.C:f5b3  C0 2D       CPY #$2D
.C:f5b5  D0 E9       BNE check_item
.C:f5b7  AD 8C CB    LDA counter
.C:f5ba  60          RTS
;===================================================
; Copies data to an interaction region
;
; Arguments:		interaction_region
;					source
;===================================================
source = $C5
dest = $C7
copy_data_to_int_region:
;Is it a valid region?
.C:f5bb  AE 88 CB    LDX interaction_region
.C:f5be  E0 8A       CPX OUT_OF_BOUNDS_REGION
.C:f5c0  D0 01       BNE get_region_offsets
;If not, exit
.C:f5c2  60          RTS
set_region_start_offset:
;Set offset = #$CC00 + the row offset
.C:f5c3  BC 43 F2    LDY int_region_start_row,X
.C:f5c6  18          CLC
.C:f5c7  B9 BA 3E    LDA screen_row_offsets_lo,Y
.C:f5ca  69 00       ADC #$00
.C:f5cc  85 C7       STA <dest
.C:f5ce  B9 A1 3E    LDA screen_row_offsets_hi,Y
.C:f5d1  69 CC       ADC #$CC
.C:f5d3  85 C8       STA >dest
;Add the column offset
.C:f5d5  18          CLC
.C:f5d6  A5 C7       LDA <dest
.C:f5d8  7D 45 F2    ADC int_region_start_col,X
.C:f5db  85 C7       STA <dest
.C:f5dd  90 02       BCC compute_column_length
.C:f5df  E6 C8       INC >dest
;Calculate how many columns to copy
compute_column_length:
.C:f5e1  38          SEC
.C:f5e2  BD 46 F2    LDA int_region_end_col,X
.C:f5e5  FD 45 F2    SBC int_region_start_col,X
.C:f5e8  8D 05 F6    STA inlined_column_length		;Inline of argument
.C:f5eb  A0 00       LDY #$00
.C:f5ed  A2 00       LDX #$00
read_next_byte:
.C:f5ef  8A          TXA
.C:f5f0  D0 0F       BNE write_to_dest
.C:f5f2  B1 C5       LDA (source),Y
.C:f5f4  C9 40       CMP #$40
.C:f5f6  D0 02       BNE check_space_conversion
;Byte is #40 - convert it to #00
.C:f5f8  A9 00       LDA #$00
check_space_conversion:
;If byte is #00, write out #20 (a space)
.C:f5fa  C9 00       CMP #$00
.C:f5fc  D0 03       BNE write_to_dest
.C:f5fe  A9 20       LDA #$20
.C:f600  AA          TAX
write_to_dest:
.C:f601  91 C7       STA (dest),Y
.C:f603  C8          INY
inlined_column_length = $f605
.C:f604  C0 12       CPY #$FF		;Inlined argument
.C:f606  D0 E7       BNE read_next_byte
.C:f608  60          RTS
;===================================================
.C:f609  00          BRK
;===================================================
; Updates a region color
;
; Arguments:	interaction_region
;				region_text_color
;===================================================
text_color_ptr = $c7
color_base_addr = #$D800

update_region_color:
.C:f60a  AE 88 CB    LDX interaction_region
;Is it a valid region?
.C:f60d  E0 8A       CPX OUT_OF_BOUNDS_REGION
.C:f60f  D0 01       BNE get_region_text_boundaries
;If not, exit
.C:f611  60          RTS
get_region_text_boundaries:
;Load the region's boundaries for row and column
;Inline the top boundaries in the code below
.C:f612  BD 46 F2    LDA int_region_end_col,X
.C:f615  8D 3D F6    STA inlined_max_column		;Inline argument
.C:f618  BD 44 F2    LDA int_region_end_row,X
.C:f61b  8D 45 F6    STA inlined_max_row		;Inline argument
.C:f61e  BC 43 F2    LDY int_region_start_row,X
set_color_in_row:
.C:f621  8C 8C CB    STY $cb8c	;Value is in the range 0-25 decimal (#00-#19)
;Fetch the video offset for the current character row and add it to the color_base_addr
;Store the result in text_color_ptr
;text_color_ptr = color_base_addr + row_offset
.C:f624  18          CLC
.C:f625  B9 BA 3E    LDA screen_row_offsets_lo,Y
.C:f628  69 00       ADC <color_base_addr
.C:f62a  85 C7       STA <text_color_ptr
.C:f62c  B9 A1 3E    LDA screen_row_offsets_hi,Y
.C:f62f  69 D8       ADC >color_base_addr
.C:f631  85 C8       STA >text_color_ptr
.C:f633  BC 45 F2    LDY int_region_start_col,X
;Fetch the desired text color
.C:f636  AD 8F CB    LDA region_text_color
;Set the color within the region boundaries
set_region_text_color:
.C:f639  91 C7       STA (text_color_ptr),Y
.C:f63b  C8          INY
;Check if we reached the max column. If not, loop
inlined_max_column = $f63d
.C:f63c  C0 0F       CPY #$FF		;Inlined argument
.C:f63e  D0 F9       BNE set_region_text_color
;Move to the next row
.C:f640  AC 8C CB    LDY $cb8c
.C:f643  C8          INY
inlined_max_row = $f645
;Check if we reached the max row. If not, loop.
;Note: all regions below the graphics area are only 1 row long
;So the comparison below will always be equal in those cases
.C:f644  C0 15       CPY #$FF		;Inlined argument
.C:f646  D0 D9       BNE set_color_in_row
.C:f648  60          RTS
;===================================================
update_cursor_fraction_coords:
;cursor_x_pixel_quarter_relative = cursor_x_pixel / 4
.C:f649  AD 7F CB    LDA cursor_x_pixel
.C:f64c  4A          LSR A
.C:f64d  4A          LSR A
.C:f64e  8D 7E FE    STA cursor_x_pixel_quarter_relative
;cursor_y_pixel_half = (cursor_y_pixel + 8) / 2
.C:f651  18          CLC
.C:f652  AD 81 CB    LDA cursor_y_pixel
.C:f655  69 08       ADC #$08
.C:f657  4A          LSR A
.C:f658  8D 7D FE    STA cursor_y_pixel_half
.C:f65b  60          RTS
;===================================================
; Gets the interaction region index for the current cursor position
;
; Arguments:	cursor_x_pixel
;				cursor_y_pixel
;
; Returns:		.X	the interaction region index
;	If no region could be matched, .X = #8A
;===================================================
get_interaction_region:
;cursor_x_grid = cursor_x_pixel / 4
.C:f65c  AD 7F CB    LDA cursor_x_pixel
.C:f65f  4A          LSR A
.C:f660  4A          LSR A
.C:f661  8D 86 CB    STA cursor_x_grid
;cursor_y_grid = cursor_y_pixel / 8
.C:f664  AD 81 CB    LDA cursor_y_pixel
.C:f667  4A          LSR A
.C:f668  4A          LSR A
.C:f669  4A          LSR A
.C:f66a  8D 87 CB    STA cursor_y_grid
;Start with region #00
.C:f66d  A2 00       LDX #$00
;Check if the grid coordinates fall within the current region boundaries
;If not, proceed to the next region
is_cursor_in_region:
.C:f66f  AD 87 CB    LDA cursor_y_grid
.C:f672  DD 43 F2    CMP int_region_start_row,X
.C:f675  90 13       BCC next_region
.C:f677  DD 44 F2    CMP int_region_end_row,X
.C:f67a  B0 0E       BCS next_region
.C:f67c  AD 86 CB    LDA cursor_x_grid
.C:f67f  DD 45 F2    CMP int_region_start_col,X
.C:f682  90 06       BCC next_region
.C:f684  DD 46 F2    CMP int_region_end_col,X
.C:f687  B0 01       BCS next_region
.C:f689  60          RTS
;Move to next region (add 6 to the index)
next_region:
.C:f68a  18          CLC
.C:f68b  8A          TXA
.C:f68c  69 06       ADC #$06
;Check if we exhausted regions
.C:f68e  AA          TAX
.C:f68f  E0 8A       CPX OUT_OF_BOUNDS_REGION
;If not, continue
.C:f691  D0 DC       BNE is_cursor_in_region
;No more regions to check, return
;Note: .X will be set to #8A
.C:f693  60          RTS
;===================================================
; This array maps each value that can be read from the joystick
; to a "direction index".
;
; The direction index is used for the horizontal and vertical
; deltas arrays below.
;
; Note that only 8 values are meaningful out of the total 16.
;
;Input value	Bitmask		Index	Direction
;E				1110		1		up
;A				1010		2		up-left
;B				1011		3		left
;9				1001		4		down-left
;D				1101		5		down
;5				0101		6		down-right
;7				0111		7		right
;6				0110		8		up-right
;===================================================
joy_direction_indexes:
f694  
00 00 00 00 00 ;0-4
06 08 07 00 04 ;5-9
02 03 00 05 01 ;A-E
00

;Deltas for each joystick direction
;The possible delta values are: 0, +1 or -1 (#FF)
joy_direction_hdeltas:
f6a4 00 00 FF FF FF 00 01 01 01 
joy_direction_vdeltas:
f6ad 00 FF FF 00 01 01 01 00 FF 
;===================================================
drag = $cb8c
drag_upper = $cb8e

update_cursor_speed:
;Calculate drag 
;Copy the 16-bit speed into a 16-bit drag value
.C:f6b6  AD 82 CB    LDA cursor_x_speed_lo
.C:f6b9  8D 8C CB    STA <drag
.C:f6bc  AD 83 CB    LDA cursor_x_speed_hi
.C:f6bf  8D 8D CB    STA >drag
;Compute half of drag's value - but taking only the hi-word
;This will be achieved by shifting left 7 times to imitate a shift right one time
;
;Set up how many times we'll shift left
;Note: cursor_drag_power is always 7
.C:f6c2  AE 7D CB    LDX cursor_drag_power
.C:f6c5  F0 09       BEQ adjust_drag_sign
;Perform cursor_drag_power (7 in total) 16-bit shift left operations on drag
;				Drag_hi							Drag_lo
; Pre shift		15 14 13 12 11 10 09 08 | 07 06 05 04 03 02 01 00
; Post shift 7 times
;			   08 07 06 05 04 03 02 01 | 00  0  0  0  0  0  0  0		(result A)
; Bit 09 will go to the carry
;
; If instead we did one 16-bit shift right of drag, we would get
; 	    	   xx 15 14 13 12 11 10 09 | 08 07 06 05 04 03 02 01		(result B)
;
; We see that drag_lo in result B has exactly the same bits as drag_hi in result A.
; So the "7-times left shift" drag_hi is equal to the "16-bit shift right" drag_lo.
; This is equivalent to:
;  	ROR >drag 
;	ROR <drag 
;
; but without looping.
;
; Of the resulting 16-bit drag value, only the low byte will be used
; Effectively, we will compute a drag value equal to half the speed
shift_16bit_left:
.C:f6c7  0E 8C CB    ASL <drag
.C:f6ca  2E 8D CB    ROL >drag
;Repeat until we exhaust the power value
.C:f6cd  CA          DEX
.C:f6ce  D0 F7       BNE shift_16_left
;Set carry and drag_upper based on the speed's sign
;
; If speed is positive, and as speed_hi can't exceed #01 in magnitude,
; then bits 15-09 of speed will be zero. Specifically, bit 9 will be 0.
; As bit 9 has been rotated to the carry, the carry is clear.
;
; If speed is negative, bits 15-09 of speed_hi will be set, and the carry will be set.
;
;So speed positive, carry clear - speed negative, carry set
adjust_drag_sign:
.C:f6d0  90 04       BCC speed_is_positive
;Negative speed - decrement .X from #00 to #FF, carry remains set
;drag_upper will use the value in .X and will then be #FF
.C:f6d2  CA          DEX
.C:f6d3  4C D9 F6    JMP set_drag_upper
speed_is_positive:
;Positive speed - leave .X unchanged at #00
;Compare X with drag. If drag is 0, carry will be set. Otherwise, carry will be clear.
;drag_upper will use the value in .X and will then be #00
.C:f6d6  EC 8C CB    CPX <drag
set_drag_upper:
.C:f6d9  8E 8E CB    STX drag_upper
;Subtract drag/drag_upper from speed, using the carry previously set
.C:f6dc  AD 82 CB    LDA cursor_x_speed_lo
.C:f6df  ED 8D CB    SBC >drag
.C:f6e2  8D 82 CB    STA cursor_x_speed_lo
.C:f6e5  AD 83 CB    LDA cursor_x_speed_hi
.C:f6e8  ED 8E CB    SBC drag_upper
.C:f6eb  8D 83 CB    STA cursor_x_speed_hi
;-------------------
;Repeat the same logic with the vertical speed and drag
.C:f6ee  AD 84 CB    LDA cursor_y_speed_lo
.C:f6f1  8D 8C CB    STA <drag
.C:f6f4  AD 85 CB    LDA cursor_y_speed_hi
.C:f6f7  8D 8D CB    STA >drag
.C:f6fa  AE 7D CB    LDX cursor_drag_power
.C:f6fd  F0 09       BEQ adjust_drag_sign_2
shift_16bit_left_2:
.C:f6ff  0E 8C CB    ASL <drag
.C:f702  2E 8D CB    ROL >drag
.C:f705  CA          DEX
.C:f706  D0 F7       BNE shift_16_left_2
adjust_drag_sign_2:
.C:f708  90 04       BCC speed_is_positive_2
.C:f70a  CA          DEX
.C:f70b  4C 11 F7    JMP set_drag_upper_2
speed_is_positive_2:
.C:f70e  EC 8C CB    CPX <drag
set_drag_upper_2:
.C:f711  8E 8E CB    STX drag_upper
.C:f714  AD 84 CB    LDA cursor_y_speed_lo
.C:f717  ED 8D CB    SBC >drag
.C:f71a  8D 84 CB    STA cursor_y_speed_lo
.C:f71d  AD 85 CB    LDA cursor_y_speed_hi
.C:f720  ED 8E CB    SBC drag_upper
.C:f723  8D 85 CB    STA cursor_y_speed_hi
;--------------------------
;Read joystick inputs
.C:f726  A5 33       LDA joy_state
;Mask low nibble (which contains bits for directions)
.C:f728  29 0F       AND #$0F
.C:f72a  AA          TAX
;Read the direction index for this input
.C:f72b  BC 94 F6    LDY joy_direction_indexes,X
;--------------------------
;Read the horizontal delta to be applied for this input
.C:f72e  B9 A4 F6    LDA joy_direction_hdeltas,Y
;If it's zero, skip to the vertical delta section
.C:f731  F0 16       BEQ check_vertical_delta
;Set carry if delta is #FF
.C:f733  C9 80       CMP #$80
;Save flags in stack
.C:f735  08          PHP
;ROR A = 01, C = 0 -> A = 00, C = 1
;ROR A = FF, C = 1 -> A = FF, C = 1
.C:f736  6A          ROR A
;Restore flags (and carry)
.C:f737  28          PLP
;Save A
.C:f738  48          PHA
;XOR A with mask to get acceleration
;Note: the mask is always #FA
;So #FF ^ #FA = 05
;And #00 ^ #FA = FA
.C:f739  4D 7B CB    EOR cursor_h_xor_mask
;Add acceleration to speed lo
.C:f73c  6D 82 CB    ADC cursor_x_speed_lo
.C:f73f  8D 82 CB    STA cursor_x_speed_lo
;Restore A, add it with carry to speed hi
.C:f742  68          PLA
.C:f743  6D 83 CB    ADC cursor_x_speed_hi
.C:f746  8D 83 CB    STA cursor_x_speed_hi
;--------------------------
check_vertical_delta:
;Read the vertical delta to be applied for this input
.C:f749  B9 AD F6    LDA joy_direction_vdeltas,Y
;If it's zero, skip to the speed application section
.C:f74c  F0 16       BEQ apply_horizontal_speed
;Set carry if delta is #FF
.C:f74e  C9 80       CMP #$80
;Save flags in stack
.C:f750  08          PHP
;ROR A = 01, C = 0 -> A = 00, C = 1
;ROR A = FF, C = 1 -> A = FF, C = 1
.C:f751  6A          ROR A
;Restore flags (and carry)
.C:f752  28          PLP
;Save A
.C:f753  48          PHA
;XOR A with mask to get acceleration
;Note: the mask is always #Ff
;So #FF ^ #FF = 00
;And #00 ^ #FF = FF
.C:f754  4D 7C CB    EOR cursor_v_xor_mask
;Add acceleration to speed lo
.C:f757  6D 84 CB    ADC cursor_y_speed_lo
.C:f75a  8D 84 CB    STA cursor_y_speed_lo
;Restore A, add it with carry to speed hi
.C:f75d  68          PLA
.C:f75e  6D 85 CB    ADC cursor_y_speed_hi
.C:f761  8D 85 CB    STA cursor_y_speed_hi
;--------------------------
apply_horizontal_speed:
; .X = x_speed_lo + previous speed
.C:f764  18          CLC
.C:f765  AD 7E CB    LDA $cb7e
.C:f768  6D 82 CB    ADC cursor_x_speed_lo
.C:f76b  AA          TAX
;Add x_speed_hi with carry to the X coordinate
;The result will be stored back as the new coordinate
;This means that only when the hi-byte is non-zero does the coordinate change
;The lo-byte is thus used to ramp up speed until it overflows into the hi-byte
.C:f76c  AD 7F CB    LDA cursor_x_pixel
.C:f76f  6D 83 CB    ADC cursor_x_speed_hi
;Check if new coordinate is out of bounds
; Anything >= A0 is past the "right edge"
; Anything < 0 is past the "left edge"
; Negative values will have bit 7 set, so they will also be > A0
; To sum up, if the new coordinate < A0, it's valid
.C:f772  C9 A0       CMP #$A0		
.C:f774  90 15       BCC update_x_coordinate
;Coordinate is out of bounds - load the speed to evaluate its sign
.C:f776  A2 00       LDX #$00
.C:f778  AD 83 CB    LDA cursor_x_speed_hi
;Set X speed to 0 to stop movement
.C:f77b  8E 82 CB    STX cursor_x_speed_lo
.C:f77e  8E 83 CB    STX cursor_x_speed_hi
;Set boundary value depending on speed sign (and thus direction)
.C:f781  10 05       BPL hspeed_positive
;Speed is negative, set boundary as #00
.C:f783  A9 00       LDA #$00
.C:f785  4C 8B F7    JMP update_x_coordinate
hspeed_positive:
;Speed is positive, set boundary as #9F
.C:f788  A9 9F       LDA #$9F
;Set X to #FF
.C:f78a  CA          DEX
update_x_coordinate:
;Update the X coordinate (either with a boundary or with the new valid position)
.C:f78b  8D 7F CB    STA cursor_x_pixel
;Update previous speed?
.C:f78e  8E 7E CB    STX $cb7e
;--------------------------
;Repeat the same logic with the vertical speed and coordinate
; .X = y_speed_lo + previous speed
.C:f791  18          CLC
.C:f792  AD 80 CB    LDA $CB80
.C:f795  6D 84 CB    ADC cursor_y_speed_lo
.C:f798  AA          TAX
;Add y_speed_hi with carry to the Y coordinate
.C:f799  AD 81 CB    LDA cursor_y_pixel
.C:f79c  6D 85 CB    ADC cursor_y_speed_hi
;Check if new coordinate is out of bounds
.C:f79f  C9 C0       CMP #$C0
.C:f7a1  90 15       BCC update_y_coordinate
;Coordinate is out of bounds - load the speed to evaluate its sign
.C:f7a3  A2 00       LDX #$00
.C:f7a5  AD 85 CB    LDA cursor_y_speed_hi
;Set Y speed to 0 to stop movement
.C:f7a8  8E 84 CB    STX cursor_y_speed_lo
.C:f7ab  8E 85 CB    STX cursor_y_speed_hi
;Set boundary value depending on speed sign (and thus direction)
.C:f7ae  10 05       BPL vspeed_positive
.C:f7b0  A9 00       LDA #$00
.C:f7b2  4C B8 F7    JMP update_y_coordinate
vspeed_positive:
.C:f7b5  A9 BF       LDA #$BF
.C:f7b7  CA          DEX
update_y_coordinate:
;Update the Y coordinate (either with a boundary or with the new valid position)
.C:f7b8  8D 81 CB    STA cursor_y_pixel
;Update previous speed?
.C:f7bb  8E 80 CB    STX $CB80
;The lower boundary is capped at #08 - adjust if needed
.C:f7be  AD 81 CB    LDA cursor_y_pixel
.C:f7c1  C9 08       CMP #$08
.C:f7c3  B0 05       BCS exit
.C:f7c5  A9 08       LDA #$08
.C:f7c7  8D 81 CB    STA cursor_y_pixel
exit:
.C:f7ca  60          RTS
;===================================================
handle_joystick_button:
.C:f7cb  A5 33       LDA joy_state
.C:f7cd  29 10       AND #$10
.C:f7cf  AA          TAX
.C:f7d0  4D 89 CB    EOR $CB89
.C:f7d3  2D 89 CB    AND $CB89
.C:f7d6  8E 89 CB    STX $CB89
.C:f7d9  60          RTS
;===================================================
; Set the cursor's acceleration and drag constants
; depending on the screen region.
;
; There's one set of constants for the upper half,
; another for the bottom half.
;
; On exit, these values will be updated:
;
;		cursor_h_xor_mask
;		cursor_v_xor_mask
;		cursor_drag_power
;===================================================
set_cursor_physics:
.C:f7da  AE 88 CB    LDX interaction_region
.C:f7dd  E0 8A       CPX OUT_OF_BOUNDS_REGION
.C:f7df  D0 05       BNE get_region_index
;Out of bounds region - set X to #00 (treat it as bottom half)
.C:f7e1  A2 00       LDX #$00
.C:f7e3  4C EC F7    JMP get_constants
get_region_index:
.C:f7e6  BC 47 F2    LDY interaction_region_handlers,X
.C:f7e9  BE D7 F2    LDX cursor_physics_for_region,Y	;X will be #1 for upper half, 0 for everything else
get_constants:
.C:f7ec  BD 10 F3    LDA h_acceleration_masks,X
.C:f7ef  8D 7B CB    STA cursor_h_xor_mask
.C:f7f2  BD 12 F3    LDA v_acceleration_masks,X
.C:f7f5  8D 7C CB    STA cursor_v_xor_mask
.C:f7f8  BD 14 F3    LDA cursor_drag_powers,X
.C:f7fb  8D 7D CB    STA cursor_drag_power
.C:f7fe  60          RTS
;===================================================


